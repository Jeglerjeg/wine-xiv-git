From 073496cf26df6d8b46e4ccd2f67db9344d6c0a36 Mon Sep 17 00:00:00 2001
From: marzent <marc_aurel@me.com>
Date: Fri, 20 May 2022 22:22:02 +0200
Subject: [PATCH] backport proton ffxiv launcher fixes

---
 dlls/jscript/Makefile.in             |    1 +
 dlls/jscript/array.c                 |   10 +-
 dlls/jscript/arraybuf.c              | 1427 +++++++++++++
 dlls/jscript/dispex.c                | 1058 +++++++++-
 dlls/jscript/engine.c                |   21 +-
 dlls/jscript/enumerator.c            |   17 +-
 dlls/jscript/error.c                 |   13 +
 dlls/jscript/function.c              |  578 +++++-
 dlls/jscript/global.c                |   54 +-
 dlls/jscript/jscript.c               |   55 +-
 dlls/jscript/jscript.h               |  209 +-
 dlls/jscript/jscript.rc              |   13 +
 dlls/jscript/json.c                  |  126 +-
 dlls/jscript/jsregexp.c              |   17 +-
 dlls/jscript/jsutils.c               |   87 +-
 dlls/jscript/object.c                |   35 +-
 dlls/jscript/parser.h                |    5 +
 dlls/jscript/parser.y                |   45 +-
 dlls/jscript/resource.h              |   13 +
 dlls/jscript/set.c                   |   43 +-
 dlls/jscript/string.c                |    2 +-
 dlls/jscript/tests/api.js            |   66 +-
 dlls/mshtml/binding.h                |    1 +
 dlls/mshtml/dispex.c                 | 2353 +++++++++++++++++----
 dlls/mshtml/editor.c                 |    9 +-
 dlls/mshtml/htmlanchor.c             |    3 +-
 dlls/mshtml/htmlarea.c               |    3 +-
 dlls/mshtml/htmlattr.c               |  264 ++-
 dlls/mshtml/htmlbody.c               |    5 +-
 dlls/mshtml/htmlcomment.c            |  225 +-
 dlls/mshtml/htmlcurstyle.c           | 2846 +++++++++++++++++++++++++-
 dlls/mshtml/htmldoc.c                |  881 ++++++--
 dlls/mshtml/htmlelem.c               | 1015 +++++++--
 dlls/mshtml/htmlelemcol.c            |   36 +-
 dlls/mshtml/htmlevent.c              |  116 +-
 dlls/mshtml/htmlevent.h              |    8 +-
 dlls/mshtml/htmlform.c               |  136 +-
 dlls/mshtml/htmlframe.c              |   18 +-
 dlls/mshtml/htmlgeneric.c            |    3 +-
 dlls/mshtml/htmlhead.c               |   34 +-
 dlls/mshtml/htmlimg.c                |   78 +-
 dlls/mshtml/htmlinput.c              |  615 +++++-
 dlls/mshtml/htmllink.c               |    3 +-
 dlls/mshtml/htmllocation.c           |   39 +-
 dlls/mshtml/htmlnode.c               |   29 +-
 dlls/mshtml/htmlobject.c             |  148 +-
 dlls/mshtml/htmlscript.c             |    3 +-
 dlls/mshtml/htmlselect.c             |  228 ++-
 dlls/mshtml/htmlstorage.c            |    7 +-
 dlls/mshtml/htmlstyle.c              |  215 +-
 dlls/mshtml/htmlstyle.h              |    5 +-
 dlls/mshtml/htmlstyleelem.c          |    6 +-
 dlls/mshtml/htmlstylesheet.c         |  282 ++-
 dlls/mshtml/htmltable.c              |   30 +-
 dlls/mshtml/htmltextarea.c           |  140 +-
 dlls/mshtml/htmltextnode.c           |   25 +-
 dlls/mshtml/htmlwindow.c             |  971 +++++++--
 dlls/mshtml/main.c                   |   66 +
 dlls/mshtml/mshtml.inf               |   24 +
 dlls/mshtml/mshtml_classes.idl       |   18 +
 dlls/mshtml/mshtml_private.h         |  383 +++-
 dlls/mshtml/mshtml_private_iface.idl |  150 +-
 dlls/mshtml/mutation.c               |   28 +-
 dlls/mshtml/navigate.c               |   18 +-
 dlls/mshtml/nsembed.c                |   62 +-
 dlls/mshtml/nsevents.c               |    4 +-
 dlls/mshtml/nsiface.idl              |   33 +-
 dlls/mshtml/nsio.c                   |   72 +-
 dlls/mshtml/omnavigator.c            |  774 ++++++-
 dlls/mshtml/persist.c                |    2 +-
 dlls/mshtml/range.c                  |   19 +-
 dlls/mshtml/script.c                 |   21 +-
 dlls/mshtml/selection.c              |   12 +-
 dlls/mshtml/task.c                   |   74 +-
 dlls/mshtml/tests/documentmode.js    | 1733 +++++++++++++++-
 dlls/mshtml/tests/dom.c              |  122 ++
 dlls/mshtml/tests/dom.js             |   54 +-
 dlls/mshtml/tests/es5.js             | 1189 ++++++++++-
 dlls/mshtml/tests/events.c           |   36 +-
 dlls/mshtml/tests/events.js          |   18 +-
 dlls/mshtml/tests/htmldoc.c          |   19 +
 dlls/mshtml/tests/script.c           |    1 +
 dlls/mshtml/tests/xhr.js             |   29 +-
 dlls/mshtml/tests/xmlhttprequest.c   |   15 +
 dlls/mshtml/xmlhttprequest.c         |  132 +-
 dlls/urlmon/Makefile.in              |    1 +
 dlls/urlmon/sec_mgr.c                |   12 +-
 dlls/urlmon/tests/misc.c             |    8 +-
 dlls/urlmon/uri.c                    |   56 +-
 dlls/wininet/tests/http.c            |    7 +
 include/mshtmdid.h                   |    4 +
 include/mshtml.idl                   |   42 +
 92 files changed, 18376 insertions(+), 1537 deletions(-)
 create mode 100644 dlls/jscript/arraybuf.c

diff --git a/dlls/jscript/Makefile.in b/dlls/jscript/Makefile.in
index 3e019201eb8..ccf38825dfa 100644
--- a/dlls/jscript/Makefile.in
+++ b/dlls/jscript/Makefile.in
@@ -4,6 +4,7 @@ IMPORTS   = oleaut32 ole32 user32 advapi32
 C_SRCS = \
 	activex.c \
 	array.c \
+	arraybuf.c \
 	bool.c \
 	compile.c \
 	date.c \
diff --git a/dlls/jscript/array.c b/dlls/jscript/array.c
index 5a8131f092c..e3572c31d58 100644
--- a/dlls/jscript/array.c
+++ b/dlls/jscript/array.c
@@ -93,7 +93,7 @@ static HRESULT set_length(jsdisp_t *obj, DWORD length)
     return jsdisp_propput_name(obj, L"length", jsval_number(length));
 }
 
-static WCHAR *idx_to_str(DWORD idx, WCHAR *ptr)
+WCHAR *idx_to_str(DWORD idx, WCHAR *ptr)
 {
     if(!idx) {
         *ptr = '0';
@@ -944,8 +944,14 @@ static HRESULT Array_toString(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsi
     TRACE("\n");
 
     array = array_this(vthis);
-    if(!array)
+    if(!array) {
+        if(ctx->version >= SCRIPTLANGUAGEVERSION_ES5) {
+            if(is_undefined(vthis) || is_null(vthis))
+                return JS_E_OBJECT_EXPECTED;
+            return Object_toString(ctx, vthis, flags, argc, argv, r);
+        }
         return JS_E_ARRAY_EXPECTED;
+    }
 
     return array_join(ctx, &array->dispex, array->length, L",", 1, to_string, r);
 }
diff --git a/dlls/jscript/arraybuf.c b/dlls/jscript/arraybuf.c
new file mode 100644
index 00000000000..1abe0c423e1
--- /dev/null
+++ b/dlls/jscript/arraybuf.c
@@ -0,0 +1,1427 @@
+/*
+ * Copyright 2022 Gabriel IvÄƒncescu for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+
+#include <math.h>
+#include <limits.h>
+#include <assert.h>
+#include "windef.h"
+#include "ntsecapi.h"
+
+#include "jscript.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(jscript);
+
+typedef struct {
+    jsdisp_t dispex;
+    DWORD size;
+
+    /* align the buffer */
+    union {
+        double _align_;
+        BYTE buf[1];
+    };
+} ArrayBufferInstance;
+
+typedef struct {
+    jsdisp_t dispex;
+
+    jsdisp_t *buffer;
+    DWORD offset;
+    DWORD size;
+} DataViewInstance;
+
+typedef struct {
+    jsdisp_t dispex;
+
+    jsdisp_t *buffer;
+    DWORD offset;
+    DWORD length;
+} TypedArrayInstance;
+
+static inline ArrayBufferInstance *arraybuf_from_jsdisp(jsdisp_t *jsdisp)
+{
+    return CONTAINING_RECORD(jsdisp, ArrayBufferInstance, dispex);
+}
+
+static inline DataViewInstance *dataview_from_jsdisp(jsdisp_t *jsdisp)
+{
+    return CONTAINING_RECORD(jsdisp, DataViewInstance, dispex);
+}
+
+static inline TypedArrayInstance *typedarr_from_jsdisp(jsdisp_t *jsdisp)
+{
+    return CONTAINING_RECORD(jsdisp, TypedArrayInstance, dispex);
+}
+
+static inline ArrayBufferInstance *arraybuf_this(jsval_t vthis)
+{
+    jsdisp_t *jsdisp = is_object_instance(vthis) ? to_jsdisp(get_object(vthis)) : NULL;
+    return (jsdisp && is_class(jsdisp, JSCLASS_ARRAYBUFFER)) ? arraybuf_from_jsdisp(jsdisp) : NULL;
+}
+
+static HRESULT create_arraybuf(script_ctx_t*,DWORD,jsdisp_t**);
+
+static HRESULT ArrayBuffer_get_byteLength(script_ctx_t *ctx, jsdisp_t *jsthis, jsval_t *r)
+{
+    TRACE("%p\n", jsthis);
+
+    *r = jsval_number(arraybuf_from_jsdisp(jsthis)->size);
+    return S_OK;
+}
+
+static HRESULT ArrayBuffer_slice(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv,
+        jsval_t *r)
+{
+    ArrayBufferInstance *arraybuf;
+    DWORD begin = 0, end, size;
+    jsdisp_t *obj;
+    HRESULT hres;
+    double n;
+
+    TRACE("\n");
+
+    if(!(arraybuf = arraybuf_this(vthis)))
+        return JS_E_ARRAYBUFFER_EXPECTED;
+    end = arraybuf->size;
+    if(!r)
+        return S_OK;
+
+    if(argc) {
+        hres = to_integer(ctx, argv[0], &n);
+        if(FAILED(hres))
+            return hres;
+        if(n < 0.0)
+            n += arraybuf->size;
+        if(n >= 0.0 && n < arraybuf->size) {
+            begin = n;
+            if(argc > 1 && !is_undefined(argv[1])) {
+                hres = to_integer(ctx, argv[1], &n);
+                if(FAILED(hres))
+                    return hres;
+                if(n < 0.0)
+                    n += arraybuf->size;
+                if(n >= 0.0) {
+                    end = n < arraybuf->size ? n : arraybuf->size;
+                    end = end < begin ? begin : end;
+                }else
+                    end = begin;
+            }
+        }else
+            end = 0;
+    }
+
+    size = end - begin;
+    hres = create_arraybuf(ctx, size, &obj);
+    if(FAILED(hres))
+        return hres;
+    memcpy(arraybuf_from_jsdisp(obj)->buf, arraybuf->buf + begin, size);
+
+    *r = jsval_obj(obj);
+    return S_OK;
+}
+
+static const builtin_prop_t ArrayBuffer_props[] = {
+    {L"byteLength",            NULL, 0,                    ArrayBuffer_get_byteLength},
+    {L"slice",                 ArrayBuffer_slice,          PROPF_METHOD|2},
+};
+
+static const builtin_info_t ArrayBuffer_info = {
+    JSCLASS_ARRAYBUFFER,
+    NULL,
+    ARRAY_SIZE(ArrayBuffer_props),
+    ArrayBuffer_props,
+    NULL,
+    NULL
+};
+
+static const builtin_prop_t ArrayBufferInst_props[] = {
+    {L"byteLength",            NULL, 0,                    ArrayBuffer_get_byteLength},
+};
+
+static const builtin_info_t ArrayBufferInst_info = {
+    JSCLASS_ARRAYBUFFER,
+    NULL,
+    ARRAY_SIZE(ArrayBufferInst_props),
+    ArrayBufferInst_props,
+    NULL,
+    NULL
+};
+
+static HRESULT create_arraybuf(script_ctx_t *ctx, DWORD size, jsdisp_t **ret)
+{
+    ArrayBufferInstance *arraybuf;
+    HRESULT hres;
+
+    if(!(arraybuf = heap_alloc_zero(FIELD_OFFSET(ArrayBufferInstance, buf[size]))))
+        return E_OUTOFMEMORY;
+
+    hres = init_dispex_from_constr(&arraybuf->dispex, ctx, &ArrayBufferInst_info, ctx->arraybuf_constr);
+    if(FAILED(hres)) {
+        heap_free(arraybuf);
+        return hres;
+    }
+
+    arraybuf->size = size;
+
+    *ret = &arraybuf->dispex;
+    return S_OK;
+}
+
+static HRESULT ArrayBufferConstr_isView(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv,
+        jsval_t *r)
+{
+    BOOL ret = FALSE;
+    jsdisp_t *obj;
+
+    TRACE("\n");
+
+    if(!r)
+        return S_OK;
+
+    if(argc && is_object_instance(argv[0]) && (obj = to_jsdisp(get_object(argv[0]))) &&
+       obj->builtin_info->class >= FIRST_VIEW_JSCLASS && obj->builtin_info->class <= LAST_VIEW_JSCLASS)
+        ret = TRUE;
+
+    *r = jsval_bool(ret);
+    return S_OK;
+}
+
+static HRESULT ArrayBufferConstr_value(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv,
+        jsval_t *r)
+{
+    DWORD size = 0;
+    jsdisp_t *obj;
+    HRESULT hres;
+
+    TRACE("\n");
+
+    switch(flags) {
+    case DISPATCH_METHOD:
+    case DISPATCH_CONSTRUCT: {
+        if(argc) {
+            double n;
+            hres = to_integer(ctx, argv[0], &n);
+            if(FAILED(hres))
+                return hres;
+            if(n < 0.0)
+                return JS_E_INVALID_LENGTH;
+            if(n > (UINT_MAX - FIELD_OFFSET(ArrayBufferInstance, buf[0])))
+                return E_OUTOFMEMORY;
+            size = n;
+        }
+
+        if(r) {
+            hres = create_arraybuf(ctx, size, &obj);
+            if(FAILED(hres))
+                return hres;
+            *r = jsval_obj(obj);
+        }
+        break;
+    }
+    default:
+        FIXME("unimplemented flags: %x\n", flags);
+        return E_NOTIMPL;
+    }
+
+    return S_OK;
+}
+
+static const builtin_prop_t ArrayBufferConstr_props[] = {
+    {L"isView",                ArrayBufferConstr_isView,   PROPF_METHOD|1},
+};
+
+static const builtin_info_t ArrayBufferConstr_info = {
+    JSCLASS_FUNCTION,
+    Function_value,
+    ARRAY_SIZE(ArrayBufferConstr_props),
+    ArrayBufferConstr_props,
+    NULL,
+    NULL
+};
+
+static inline DataViewInstance *dataview_this(jsval_t vthis)
+{
+    jsdisp_t *jsdisp = is_object_instance(vthis) ? to_jsdisp(get_object(vthis)) : NULL;
+    return (jsdisp && is_class(jsdisp, JSCLASS_DATAVIEW)) ? dataview_from_jsdisp(jsdisp) : NULL;
+}
+
+static HRESULT DataView_get_buffer(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv,
+        jsval_t *r)
+{
+    DataViewInstance *view;
+
+    TRACE("\n");
+
+    if(!(view = dataview_this(vthis)))
+        return JS_E_NOT_DATAVIEW;
+    if(r) *r = jsval_obj(jsdisp_addref(view->buffer));
+    return S_OK;
+}
+
+static HRESULT DataView_get_byteLength(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv,
+        jsval_t *r)
+{
+    DataViewInstance *view;
+
+    TRACE("\n");
+
+    if(!(view = dataview_this(vthis)))
+        return JS_E_NOT_DATAVIEW;
+    if(r) *r = jsval_number(view->size);
+    return S_OK;
+}
+
+static HRESULT DataView_get_byteOffset(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv,
+        jsval_t *r)
+{
+    DataViewInstance *view;
+
+    TRACE("\n");
+
+    if(!(view = dataview_this(vthis)))
+        return JS_E_NOT_DATAVIEW;
+    if(r) *r = jsval_number(view->offset);
+    return S_OK;
+}
+
+static inline void copy_type_data(void *dst, const void *src, unsigned type_size, BOOL little_endian)
+{
+#ifdef WORDS_BIGENDIAN
+    BOOL swap = little_endian;
+#else
+    BOOL swap = !little_endian;
+#endif
+    const BYTE *in = src;
+    BYTE *out = dst;
+    unsigned i;
+
+    if(swap)
+        for(i = 0; i < type_size; i++)
+            out[i] = in[type_size - i - 1];
+    else
+        memcpy(out, in, type_size);
+}
+
+static HRESULT get_data(script_ctx_t *ctx, jsval_t vthis, unsigned argc, jsval_t *argv, unsigned type_size, void *ret)
+{
+    BOOL little_endian = FALSE;
+    DataViewInstance *view;
+    HRESULT hres;
+    DWORD offset;
+    BYTE *data;
+    double n;
+
+    if(!(view = dataview_this(vthis)))
+        return JS_E_NOT_DATAVIEW;
+    if(!argc || is_undefined(argv[0]))
+        return JS_E_DATAVIEW_NO_ARGUMENT;
+
+    hres = to_integer(ctx, argv[0], &n);
+    if(FAILED(hres))
+        return hres;
+
+    if(n < 0.0 || n >= view->size)
+        return JS_E_DATAVIEW_INVALID_ACCESS;
+
+    offset = n;
+    if(view->size - offset < type_size)
+        return JS_E_DATAVIEW_INVALID_ACCESS;
+    data = &arraybuf_from_jsdisp(view->buffer)->buf[view->offset + offset];
+
+    if(type_size == 1) {
+        *(BYTE*)ret = data[0];
+        return S_OK;
+    }
+
+    if(argc > 1) {
+        hres = to_boolean(argv[1], &little_endian);
+        if(FAILED(hres))
+            return hres;
+    }
+
+    copy_type_data(ret, data, type_size, little_endian);
+    return S_OK;
+}
+
+static HRESULT set_data(script_ctx_t *ctx, jsval_t vthis, unsigned argc, jsval_t *argv, unsigned type_size, const void *val)
+{
+    BOOL little_endian = FALSE;
+    DataViewInstance *view;
+    HRESULT hres;
+    DWORD offset;
+    BYTE *data;
+    double n;
+
+    if(!(view = dataview_this(vthis)))
+        return JS_E_NOT_DATAVIEW;
+    if(is_undefined(argv[0]) || is_undefined(argv[1]))
+        return JS_E_DATAVIEW_NO_ARGUMENT;
+
+    hres = to_integer(ctx, argv[0], &n);
+    if(FAILED(hres))
+        return hres;
+
+    if(n < 0.0 || n >= view->size)
+        return JS_E_DATAVIEW_INVALID_ACCESS;
+
+    offset = n;
+    if(view->size - offset < type_size)
+        return JS_E_DATAVIEW_INVALID_ACCESS;
+    data = &arraybuf_from_jsdisp(view->buffer)->buf[view->offset + offset];
+
+    if(type_size == 1) {
+        data[0] = *(const BYTE*)val;
+        return S_OK;
+    }
+
+    if(argc > 2) {
+        hres = to_boolean(argv[2], &little_endian);
+        if(FAILED(hres))
+            return hres;
+    }
+
+    copy_type_data(data, val, type_size, little_endian);
+    return S_OK;
+}
+
+static HRESULT DataView_getFloat32(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv, jsval_t *r)
+{
+    HRESULT hres;
+    float v;
+
+    TRACE("\n");
+
+    hres = get_data(ctx, vthis, argc, argv, sizeof(v), &v);
+    if(FAILED(hres))
+        return hres;
+    if(r) *r = jsval_number(v);
+    return S_OK;
+}
+
+static HRESULT DataView_getFloat64(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv, jsval_t *r)
+{
+    HRESULT hres;
+    double v;
+
+    TRACE("\n");
+
+    hres = get_data(ctx, vthis, argc, argv, sizeof(v), &v);
+    if(FAILED(hres))
+        return hres;
+    if(r) *r = jsval_number(v);
+    return S_OK;
+}
+
+static HRESULT DataView_getInt8(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv, jsval_t *r)
+{
+    HRESULT hres;
+    INT8 v;
+
+    TRACE("\n");
+
+    hres = get_data(ctx, vthis, argc, argv, sizeof(v), &v);
+    if(FAILED(hres))
+        return hres;
+    if(r) *r = jsval_number(v);
+    return S_OK;
+}
+
+static HRESULT DataView_getInt16(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv, jsval_t *r)
+{
+    HRESULT hres;
+    INT16 v;
+
+    TRACE("\n");
+
+    hres = get_data(ctx, vthis, argc, argv, sizeof(v), &v);
+    if(FAILED(hres))
+        return hres;
+    if(r) *r = jsval_number(v);
+    return S_OK;
+}
+
+static HRESULT DataView_getInt32(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv, jsval_t *r)
+{
+    HRESULT hres;
+    INT32 v;
+
+    TRACE("\n");
+
+    hres = get_data(ctx, vthis, argc, argv, sizeof(v), &v);
+    if(FAILED(hres))
+        return hres;
+    if(r) *r = jsval_number(v);
+    return S_OK;
+}
+
+static HRESULT DataView_getUint8(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv, jsval_t *r)
+{
+    HRESULT hres;
+    UINT8 v;
+
+    TRACE("\n");
+
+    hres = get_data(ctx, vthis, argc, argv, sizeof(v), &v);
+    if(FAILED(hres))
+        return hres;
+    if(r) *r = jsval_number(v);
+    return S_OK;
+}
+
+static HRESULT DataView_getUint16(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv, jsval_t *r)
+{
+    HRESULT hres;
+    UINT16 v;
+
+    TRACE("\n");
+
+    hres = get_data(ctx, vthis, argc, argv, sizeof(v), &v);
+    if(FAILED(hres))
+        return hres;
+    if(r) *r = jsval_number(v);
+    return S_OK;
+}
+
+static HRESULT DataView_getUint32(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv, jsval_t *r)
+{
+    HRESULT hres;
+    UINT32 v;
+
+    TRACE("\n");
+
+    hres = get_data(ctx, vthis, argc, argv, sizeof(v), &v);
+    if(FAILED(hres))
+        return hres;
+    if(r) *r = jsval_number(v);
+    return S_OK;
+}
+
+static HRESULT DataView_setFloat32(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv, jsval_t *r)
+{
+    HRESULT hres;
+    double n;
+    float v;
+
+    TRACE("\n");
+
+    if(argc < 2)
+        return JS_E_DATAVIEW_NO_ARGUMENT;
+    hres = to_number(ctx, argv[1], &n);
+    if(FAILED(hres))
+        return hres;
+    v = n;  /* FIXME: don't assume rounding mode is round-to-nearest ties-to-even */
+
+    hres = set_data(ctx, vthis, argc, argv, sizeof(v), &v);
+    if(FAILED(hres))
+        return hres;
+    if(r) *r = jsval_undefined();
+    return S_OK;
+}
+
+static HRESULT DataView_setFloat64(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv, jsval_t *r)
+{
+    HRESULT hres;
+    double v;
+
+    TRACE("\n");
+
+    if(argc < 2)
+        return JS_E_DATAVIEW_NO_ARGUMENT;
+    hres = to_number(ctx, argv[1], &v);
+    if(FAILED(hres))
+        return hres;
+
+    hres = set_data(ctx, vthis, argc, argv, sizeof(v), &v);
+    if(FAILED(hres))
+        return hres;
+    if(r) *r = jsval_undefined();
+    return S_OK;
+}
+
+static HRESULT DataView_setInt8(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv, jsval_t *r)
+{
+    HRESULT hres;
+    INT32 n;
+    INT8 v;
+
+    TRACE("\n");
+
+    if(argc < 2)
+        return JS_E_DATAVIEW_NO_ARGUMENT;
+    hres = to_int32(ctx, argv[1], &n);
+    if(FAILED(hres))
+        return hres;
+    v = n;
+
+    hres = set_data(ctx, vthis, argc, argv, sizeof(v), &v);
+    if(FAILED(hres))
+        return hres;
+    if(r) *r = jsval_undefined();
+    return S_OK;
+}
+
+static HRESULT DataView_setInt16(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv, jsval_t *r)
+{
+    HRESULT hres;
+    INT32 n;
+    INT16 v;
+
+    TRACE("\n");
+
+    if(argc < 2)
+        return JS_E_DATAVIEW_NO_ARGUMENT;
+    hres = to_int32(ctx, argv[1], &n);
+    if(FAILED(hres))
+        return hres;
+    v = n;
+
+    hres = set_data(ctx, vthis, argc, argv, sizeof(v), &v);
+    if(FAILED(hres))
+        return hres;
+    if(r) *r = jsval_undefined();
+    return S_OK;
+}
+
+static HRESULT DataView_setInt32(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv, jsval_t *r)
+{
+    HRESULT hres;
+    INT32 v;
+
+    TRACE("\n");
+
+    if(argc < 2)
+        return JS_E_DATAVIEW_NO_ARGUMENT;
+    hres = to_int32(ctx, argv[1], &v);
+    if(FAILED(hres))
+        return hres;
+
+    hres = set_data(ctx, vthis, argc, argv, sizeof(v), &v);
+    if(FAILED(hres))
+        return hres;
+    if(r) *r = jsval_undefined();
+    return S_OK;
+}
+
+static const builtin_prop_t DataView_props[] = {
+    {L"getFloat32",            DataView_getFloat32,        PROPF_METHOD|1},
+    {L"getFloat64",            DataView_getFloat64,        PROPF_METHOD|1},
+    {L"getInt16",              DataView_getInt16,          PROPF_METHOD|1},
+    {L"getInt32",              DataView_getInt32,          PROPF_METHOD|1},
+    {L"getInt8",               DataView_getInt8,           PROPF_METHOD|1},
+    {L"getUint16",             DataView_getUint16,         PROPF_METHOD|1},
+    {L"getUint32",             DataView_getUint32,         PROPF_METHOD|1},
+    {L"getUint8",              DataView_getUint8,          PROPF_METHOD|1},
+    {L"setFloat32",            DataView_setFloat32,        PROPF_METHOD|1},
+    {L"setFloat64",            DataView_setFloat64,        PROPF_METHOD|1},
+    {L"setInt16",              DataView_setInt16,          PROPF_METHOD|1},
+    {L"setInt32",              DataView_setInt32,          PROPF_METHOD|1},
+    {L"setInt8",               DataView_setInt8,           PROPF_METHOD|1},
+    {L"setUint16",             DataView_setInt16,          PROPF_METHOD|1},
+    {L"setUint32",             DataView_setInt32,          PROPF_METHOD|1},
+    {L"setUint8",              DataView_setInt8,           PROPF_METHOD|1},
+};
+
+static void DataView_destructor(jsdisp_t *dispex)
+{
+    DataViewInstance *view = dataview_from_jsdisp(dispex);
+    if(view->buffer)
+        jsdisp_release(view->buffer);
+    heap_free(view);
+}
+
+static HRESULT DataView_gc_traverse(jsdisp_t *dispex, void *arg)
+{
+    DataViewInstance *view = dataview_from_jsdisp(dispex);
+    return gc_process_linked_obj(dispex, view->buffer, (void**)&view->buffer, arg);
+}
+
+static const builtin_info_t DataView_info = {
+    JSCLASS_DATAVIEW,
+    NULL,
+    ARRAY_SIZE(DataView_props),
+    DataView_props,
+    DataView_destructor,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    DataView_gc_traverse
+};
+
+static const builtin_info_t DataViewInst_info = {
+    JSCLASS_DATAVIEW,
+    NULL,
+    0,
+    NULL,
+    DataView_destructor,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    DataView_gc_traverse
+};
+
+static HRESULT DataViewConstr_value(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv,
+        jsval_t *r)
+{
+    ArrayBufferInstance *arraybuf;
+    DataViewInstance *view;
+    DWORD offset = 0, size;
+    HRESULT hres;
+
+    TRACE("\n");
+
+    switch(flags) {
+    case DISPATCH_METHOD:
+    case DISPATCH_CONSTRUCT: {
+        if(!argc || !(arraybuf = arraybuf_this(argv[0])))
+            return JS_E_DATAVIEW_NO_ARGUMENT;
+        size = arraybuf->size;
+
+        if(argc > 1) {
+            double offs, len, maxsize = size;
+            hres = to_integer(ctx, argv[1], &offs);
+            if(FAILED(hres))
+                return hres;
+            if(offs < 0.0 || offs > maxsize)
+                return JS_E_DATAVIEW_INVALID_OFFSET;
+            offset = offs;
+
+            if(argc > 2 && !is_undefined(argv[2])) {
+                hres = to_integer(ctx, argv[2], &len);
+                if(FAILED(hres))
+                    return hres;
+                if(len < 0.0 || offs+len > maxsize)
+                    return JS_E_DATAVIEW_INVALID_OFFSET;
+                size = len;
+            }else
+                size -= offset;
+        }
+
+        if(!r)
+            return S_OK;
+
+        if(!(view = heap_alloc_zero(sizeof(DataViewInstance))))
+            return E_OUTOFMEMORY;
+
+        hres = init_dispex_from_constr(&view->dispex, ctx, &DataViewInst_info, ctx->dataview_constr);
+        if(FAILED(hres)) {
+            heap_free(view);
+            return hres;
+        }
+
+        view->buffer = jsdisp_addref(&arraybuf->dispex);
+        view->offset = offset;
+        view->size = size;
+
+        *r = jsval_obj(&view->dispex);
+        break;
+    }
+    default:
+        FIXME("unimplemented flags: %x\n", flags);
+        return E_NOTIMPL;
+    }
+
+    return S_OK;
+}
+
+static const builtin_info_t DataViewConstr_info = {
+    JSCLASS_FUNCTION,
+    Function_value,
+    0,
+    NULL,
+    NULL,
+    NULL
+};
+
+static HRESULT clamped_u8(script_ctx_t *ctx, jsval_t v, UINT8 *ret)
+{
+    HRESULT hres;
+    double n;
+
+    hres = to_number(ctx, v, &n);
+    if(FAILED(hres))
+        return hres;
+
+    if(!isfinite(n))
+        *ret = (n == INFINITY ? 255 : 0);
+    else
+        *ret = (n >= 255.0 ? 255 : n <= 0 ? 0 : lround(n));
+    return S_OK;
+}
+
+#define TYPEDARRAY_LIST \
+X(Int8Array,            JSCLASS_INT8ARRAY,          INT8,   to_int32,   INT)    \
+X(Int16Array,           JSCLASS_INT16ARRAY,         INT16,  to_int32,   INT)    \
+X(Int32Array,           JSCLASS_INT32ARRAY,         INT32,  to_int32,   INT)    \
+X(Uint8Array,           JSCLASS_UINT8ARRAY,         UINT8,  to_int32,   INT)    \
+X(Uint8ClampedArray,    JSCLASS_UINT8CLAMPEDARRAY,  UINT8,  clamped_u8, UINT8)  \
+X(Uint16Array,          JSCLASS_UINT16ARRAY,        UINT16, to_int32,   INT)    \
+X(Uint32Array,          JSCLASS_UINT32ARRAY,        UINT32, to_int32,   INT)    \
+X(Float32Array,         JSCLASS_FLOAT32ARRAY,       float,  to_number,  double) \
+X(Float64Array,         JSCLASS_FLOAT64ARRAY,       double, to_number,  double)
+
+#define TYPEDARRAY_INDEX(JSCLASS) ((JSCLASS) - FIRST_TYPEDARRAY_JSCLASS)
+
+#define X(NAME, JSCLASS, TYPE, CONVERT, NUM_TYPE) [TYPEDARRAY_INDEX(JSCLASS)] = L"" #NAME,
+static const WCHAR *const TypedArray_name[] = { TYPEDARRAY_LIST };
+#undef X
+
+#define X(NAME, JSCLASS, TYPE, CONVERT, NUM_TYPE) [TYPEDARRAY_INDEX(JSCLASS)] = sizeof(TYPE),
+static const unsigned TypedArray_elem_size[] = { TYPEDARRAY_LIST };
+#undef X
+
+static inline TypedArrayInstance *typedarr_this(jsval_t vthis, jsclass_t jsclass)
+{
+    jsdisp_t *jsdisp = is_object_instance(vthis) ? to_jsdisp(get_object(vthis)) : NULL;
+    return (jsdisp && is_class(jsdisp, jsclass)) ? typedarr_from_jsdisp(jsdisp) : NULL;
+}
+
+static HRESULT create_typedarr(script_ctx_t*,jsclass_t,jsdisp_t*,DWORD,DWORD,jsdisp_t**);
+
+static HRESULT TypedArray_get_buffer(script_ctx_t *ctx, jsdisp_t *jsthis, jsval_t *r)
+{
+    TRACE("%p\n", jsthis);
+
+    *r = jsval_obj(jsdisp_addref(typedarr_from_jsdisp(jsthis)->buffer));
+    return S_OK;
+}
+
+static HRESULT TypedArray_get_byteLength(script_ctx_t *ctx, jsdisp_t *jsthis, jsval_t *r)
+{
+    TRACE("%p\n", jsthis);
+
+    *r = jsval_number(typedarr_from_jsdisp(jsthis)->length * TypedArray_elem_size[TYPEDARRAY_INDEX(jsthis->builtin_info->class)]);
+    return S_OK;
+}
+
+static HRESULT TypedArray_get_byteOffset(script_ctx_t *ctx, jsdisp_t *jsthis, jsval_t *r)
+{
+    TRACE("%p\n", jsthis);
+
+    *r = jsval_number(typedarr_from_jsdisp(jsthis)->offset);
+    return S_OK;
+}
+
+static HRESULT TypedArray_get_length(script_ctx_t *ctx, jsdisp_t *jsthis, jsval_t *r)
+{
+    TRACE("%p\n", jsthis);
+
+    *r = jsval_number(typedarr_from_jsdisp(jsthis)->length);
+    return S_OK;
+}
+
+static HRESULT fill_typedarr_data_from_object(script_ctx_t *ctx, BYTE *data, jsdisp_t *obj, DWORD length, jsclass_t jsclass)
+{
+    HRESULT hres = S_OK;
+    jsval_t val;
+    UINT32 i;
+
+    switch(jsclass) {
+#define X(NAME, JSCLASS, TYPE, CONVERT, NUM_TYPE)   \
+    case JSCLASS:                                   \
+        for(i = 0; i < length; i++) {               \
+            NUM_TYPE n;                             \
+                                                    \
+            hres = jsdisp_get_idx(obj, i, &val);    \
+            if(FAILED(hres)) {                      \
+                if(hres != DISP_E_UNKNOWNNAME)      \
+                    break;                          \
+                val = jsval_undefined();            \
+            }                                       \
+                                                    \
+            hres = CONVERT(ctx, val, &n);           \
+            jsval_release(val);                     \
+            if(FAILED(hres))                        \
+                break;                              \
+            *(TYPE*)&data[i * sizeof(TYPE)] = n;    \
+        }                                           \
+        break;
+        TYPEDARRAY_LIST
+    DEFAULT_UNREACHABLE;
+#undef X
+    }
+
+    return hres;
+}
+
+static HRESULT TypedArray_set(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv,
+        jsval_t *r, jsclass_t jsclass)
+{
+    const unsigned elem_size = TypedArray_elem_size[TYPEDARRAY_INDEX(jsclass)];
+    TypedArrayInstance *typedarr;
+    DWORD begin = 0, size;
+    BYTE *dest, *data;
+    IDispatch *disp;
+    jsdisp_t *obj;
+    HRESULT hres;
+    jsval_t val;
+    UINT32 len;
+    double n;
+
+    TRACE("\n");
+
+    if(!(typedarr = typedarr_this(vthis, jsclass)))
+        return JS_E_NOT_TYPEDARRAY;
+    if(!argc)
+        return JS_E_TYPEDARRAY_INVALID_SOURCE;
+
+    hres = to_object(ctx, argv[0], &disp);
+    if(FAILED(hres))
+        return JS_E_TYPEDARRAY_INVALID_SOURCE;
+
+    if(!(obj = to_jsdisp(disp))) {
+        FIXME("Non-JS array object\n");
+        hres = JS_E_TYPEDARRAY_INVALID_SOURCE;
+        goto done;
+    }
+
+    hres = jsdisp_propget_name(obj, L"length", &val);
+    if(FAILED(hres))
+        goto done;
+
+    hres = to_uint32(ctx, val, &len);
+    jsval_release(val);
+    if(FAILED(hres))
+        goto done;
+
+    if(argc > 1) {
+        hres = to_integer(ctx, argv[1], &n);
+        if(FAILED(hres))
+            goto done;
+        if(n < 0.0 || n > typedarr->length) {
+            hres = JS_E_TYPEDARRAY_INVALID_OFFSLEN;
+            goto done;
+        }
+        begin = n;
+    }
+
+    if(len > typedarr->length - begin) {
+        hres = JS_E_TYPEDARRAY_INVALID_OFFSLEN;
+        goto done;
+    }
+    size = len * elem_size;
+    dest = data = &arraybuf_from_jsdisp(typedarr->buffer)->buf[typedarr->offset + begin * elem_size];
+
+    /* If they overlap, make a temporary copy */
+    if(obj->builtin_info->class >= FIRST_TYPEDARRAY_JSCLASS && obj->builtin_info->class <= LAST_TYPEDARRAY_JSCLASS) {
+        TypedArrayInstance *src_arr = typedarr_from_jsdisp(obj);
+        const BYTE *src = arraybuf_from_jsdisp(src_arr->buffer)->buf + src_arr->offset;
+
+        if(dest < src + len * TypedArray_elem_size[TYPEDARRAY_INDEX(obj->builtin_info->class)] &&
+           dest + size > src) {
+            if(!(data = heap_alloc(size))) {
+                hres = E_OUTOFMEMORY;
+                goto done;
+            }
+        }
+    }
+
+    hres = fill_typedarr_data_from_object(ctx, data, obj, len, jsclass);
+    if(SUCCEEDED(hres) && dest != data) {
+        memcpy(dest, data, size);
+        heap_free(data);
+    }
+
+done:
+    IDispatch_Release(disp);
+    return hres;
+}
+
+static HRESULT TypedArray_subarray(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv,
+        jsval_t *r, jsclass_t jsclass)
+{
+    TypedArrayInstance *typedarr;
+    DWORD begin = 0, end;
+    jsdisp_t *obj;
+    HRESULT hres;
+    double n;
+
+    TRACE("\n");
+
+    if(!(typedarr = typedarr_this(vthis, jsclass)))
+        return JS_E_NOT_TYPEDARRAY;
+    if(!argc)
+        return JS_E_TYPEDARRAY_INVALID_SUBARRAY;
+    if(!r)
+        return S_OK;
+
+    hres = to_integer(ctx, argv[0], &n);
+    if(FAILED(hres))
+        return hres;
+    end = typedarr->length;
+    if(n < 0.0)
+        n += typedarr->length;
+    if(n >= 0.0)
+        begin = n < typedarr->length ? n : typedarr->length;
+
+    if(argc > 1 && !is_undefined(argv[1])) {
+        hres = to_integer(ctx, argv[1], &n);
+        if(FAILED(hres))
+            return hres;
+        if(n < 0.0)
+            n += typedarr->length;
+        if(n >= 0.0) {
+            end = n < typedarr->length ? n : typedarr->length;
+            end = end < begin ? begin : end;
+        }else
+            end = begin;
+    }
+
+    hres = create_typedarr(ctx, jsclass, typedarr->buffer,
+                           typedarr->offset + begin * TypedArray_elem_size[TYPEDARRAY_INDEX(jsclass)],
+                           end - begin, &obj);
+    if(FAILED(hres))
+        return hres;
+
+    *r = jsval_obj(obj);
+    return S_OK;
+}
+
+static unsigned TypedArray_idx_length(jsdisp_t *jsdisp)
+{
+    TypedArrayInstance *typedarr = typedarr_from_jsdisp(jsdisp);
+    return typedarr->length;
+}
+
+static void TypedArray_destructor(jsdisp_t *dispex)
+{
+    TypedArrayInstance *typedarr = typedarr_from_jsdisp(dispex);
+    if(typedarr->buffer)
+        jsdisp_release(typedarr->buffer);
+    heap_free(typedarr);
+}
+
+static HRESULT TypedArray_gc_traverse(jsdisp_t *dispex, void *arg)
+{
+    TypedArrayInstance *typedarr = typedarr_from_jsdisp(dispex);
+    return gc_process_linked_obj(dispex, typedarr->buffer, (void**)&typedarr->buffer, arg);
+}
+
+static const builtin_prop_t TypedArrayInst_props[] = {
+    {L"buffer",                NULL, 0,                    TypedArray_get_buffer},
+    {L"byteLength",            NULL, 0,                    TypedArray_get_byteLength},
+    {L"byteOffset",            NULL, 0,                    TypedArray_get_byteOffset},
+    {L"length",                NULL, 0,                    TypedArray_get_length},
+};
+
+#define X(NAME, JSCLASS, TYPE, CONVERT, NUM_TYPE) \
+static HRESULT NAME ##_idx_get(jsdisp_t *jsdisp, unsigned idx, jsval_t *r)              \
+{                                                                                       \
+    TypedArrayInstance *typedarr = typedarr_from_jsdisp(jsdisp);                        \
+                                                                                        \
+    TRACE("%p[%u]\n", typedarr, idx);                                                   \
+                                                                                        \
+    if(idx >= typedarr->length)                                                         \
+        *r = jsval_undefined();                                                         \
+    else                                                                                \
+        *r = jsval_number(*(TYPE*)&arraybuf_from_jsdisp(typedarr->buffer)->buf[typedarr->offset + idx * sizeof(TYPE)]); \
+    return S_OK;                                                                        \
+}                                                                                       \
+                                                                                        \
+static HRESULT NAME ##_idx_put(jsdisp_t *jsdisp, unsigned idx, jsval_t val)             \
+{                                                                                       \
+    TypedArrayInstance *typedarr = typedarr_from_jsdisp(jsdisp);                        \
+    HRESULT hres;                                                                       \
+    NUM_TYPE n;                                                                         \
+                                                                                        \
+    TRACE("%p[%u] = %s\n", typedarr, idx, debugstr_jsval(val));                         \
+                                                                                        \
+    if(idx >= typedarr->length)                                                         \
+        return S_OK;                                                                    \
+                                                                                        \
+    hres = CONVERT(jsdisp->ctx, val, &n);                                               \
+    if(SUCCEEDED(hres))                                                                 \
+        *(TYPE*)&arraybuf_from_jsdisp(typedarr->buffer)->buf[typedarr->offset + idx * sizeof(TYPE)] = n; \
+    return hres;                                                                        \
+}                                                                                       \
+                                                                                        \
+static HRESULT NAME ##_set(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv, \
+        jsval_t *r)                                                                     \
+{                                                                                       \
+    return TypedArray_set(ctx, vthis, flags, argc, argv, r, JSCLASS);                   \
+}                                                                                       \
+                                                                                        \
+static HRESULT NAME ##_subarray(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv, \
+        jsval_t *r)                                                                     \
+{                                                                                       \
+    return TypedArray_subarray(ctx, vthis, flags, argc, argv, r, JSCLASS);              \
+}                                                                                       \
+                                                                                        \
+static const builtin_prop_t NAME ##_props[] = {                                         \
+    {L"buffer",                NULL, 0,                    TypedArray_get_buffer},      \
+    {L"byteLength",            NULL, 0,                    TypedArray_get_byteLength},  \
+    {L"byteOffset",            NULL, 0,                    TypedArray_get_byteOffset},  \
+    {L"length",                NULL, 0,                    TypedArray_get_length},      \
+    {L"set",                   NAME ##_set,                PROPF_METHOD|2},             \
+    {L"subarray",              NAME ##_subarray,           PROPF_METHOD|2},             \
+};
+TYPEDARRAY_LIST
+#undef X
+
+#define X(NAME, JSCLASS, TYPE, CONVERT, NUM_TYPE) \
+[TYPEDARRAY_INDEX(JSCLASS)] =           \
+{                                       \
+    JSCLASS,                            \
+    NULL,                               \
+    ARRAY_SIZE(NAME ##_props),          \
+    NAME ##_props,                      \
+    TypedArray_destructor,              \
+    NULL,                               \
+    TypedArray_idx_length,              \
+    NAME ##_idx_get,                    \
+    NAME ##_idx_put,                    \
+    TypedArray_gc_traverse              \
+},
+static const builtin_info_t TypedArray_info[] = { TYPEDARRAY_LIST };
+#undef X
+
+#define X(NAME, JSCLASS, TYPE, CONVERT, NUM_TYPE) \
+[TYPEDARRAY_INDEX(JSCLASS)] =           \
+{                                       \
+    JSCLASS,                            \
+    NULL,                               \
+    ARRAY_SIZE(TypedArrayInst_props),   \
+    TypedArrayInst_props,               \
+    TypedArray_destructor,              \
+    NULL,                               \
+    TypedArray_idx_length,              \
+    NAME ##_idx_get,                    \
+    NAME ##_idx_put,                    \
+    TypedArray_gc_traverse              \
+},
+static const builtin_info_t TypedArrayInst_info[] = { TYPEDARRAY_LIST };
+#undef X
+
+static HRESULT create_typedarr(script_ctx_t *ctx, jsclass_t jsclass, jsdisp_t *buffer, DWORD offset, DWORD length,
+        jsdisp_t **ret)
+{
+    TypedArrayInstance *typedarr;
+    HRESULT hres;
+
+    if(!(typedarr = heap_alloc_zero(sizeof(TypedArrayInstance))))
+        return E_OUTOFMEMORY;
+
+    hres = init_dispex_from_constr(&typedarr->dispex, ctx, &TypedArrayInst_info[TYPEDARRAY_INDEX(jsclass)],
+                                   ctx->typedarr_constr[TYPEDARRAY_INDEX(jsclass)]);
+    if(FAILED(hres)) {
+        heap_free(typedarr);
+        return hres;
+    }
+
+    typedarr->buffer = jsdisp_addref(buffer);
+    typedarr->offset = offset;
+    typedarr->length = length;
+
+    *ret = &typedarr->dispex;
+    return S_OK;
+}
+
+static HRESULT TypedArrayConstr_value(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv,
+        jsval_t *r, jsclass_t jsclass)
+{
+    const unsigned typedarr_idx = TYPEDARRAY_INDEX(jsclass);
+    unsigned elem_size = TypedArray_elem_size[typedarr_idx];
+    jsdisp_t *typedarr, *buffer = NULL;
+    DWORD offset = 0, length = 0;
+    HRESULT hres;
+    double n;
+
+    TRACE("\n");
+
+    switch(flags) {
+    case DISPATCH_METHOD:
+    case DISPATCH_CONSTRUCT: {
+        if(argc) {
+            if(is_object_instance(argv[0])) {
+                jsdisp_t *obj = to_jsdisp(get_object(argv[0]));
+
+                if(!obj)
+                    return JS_E_TYPEDARRAY_BAD_CTOR_ARG;
+
+                if(obj->builtin_info->class == JSCLASS_ARRAYBUFFER) {
+                    ArrayBufferInstance *arraybuf = arraybuf_from_jsdisp(obj);
+
+                    if(argc > 1) {
+                        hres = to_integer(ctx, argv[1], &n);
+                        if(FAILED(hres))
+                            return hres;
+                        if(n < 0.0 || n > arraybuf->size)
+                            return JS_E_TYPEDARRAY_INVALID_OFFSLEN;
+                        offset = n;
+                        if(offset % elem_size)
+                            return JS_E_TYPEDARRAY_INVALID_OFFSLEN;
+                    }
+                    if(argc > 2 && !is_undefined(argv[2])) {
+                        hres = to_integer(ctx, argv[2], &n);
+                        if(FAILED(hres))
+                            return hres;
+                        if(n < 0.0 || n > UINT_MAX)
+                            return JS_E_TYPEDARRAY_INVALID_OFFSLEN;
+                        length = n;
+                        if(offset + length * elem_size > arraybuf->size)
+                            return JS_E_TYPEDARRAY_INVALID_OFFSLEN;
+                    }else {
+                        length = arraybuf->size - offset;
+                        if(length % elem_size)
+                            return JS_E_TYPEDARRAY_INVALID_OFFSLEN;
+                        length /= elem_size;
+                    }
+                    buffer = jsdisp_addref(&arraybuf->dispex);
+                }else {
+                    jsval_t val;
+                    UINT32 len;
+                    DWORD size;
+
+                    hres = jsdisp_propget_name(obj, L"length", &val);
+                    if(FAILED(hres))
+                        return hres;
+                    if(is_undefined(val))
+                        return JS_E_TYPEDARRAY_BAD_CTOR_ARG;
+
+                    hres = to_uint32(ctx, val, &len);
+                    jsval_release(val);
+                    if(FAILED(hres))
+                        return hres;
+
+                    length = len;
+                    size = length * elem_size;
+                    if(size < length || size > (UINT_MAX - FIELD_OFFSET(ArrayBufferInstance, buf[0])))
+                        return E_OUTOFMEMORY;
+
+                    hres = create_arraybuf(ctx, size, &buffer);
+                    if(FAILED(hres))
+                        return hres;
+
+                    hres = fill_typedarr_data_from_object(ctx, arraybuf_from_jsdisp(buffer)->buf,
+                                                          obj, length, jsclass);
+                    if(FAILED(hres)) {
+                        jsdisp_release(buffer);
+                        return hres;
+                    }
+                }
+            }else if(is_number(argv[0])) {
+                hres = to_integer(ctx, argv[0], &n);
+                if(FAILED(hres))
+                    return hres;
+                if(n < 0.0)
+                    return JS_E_TYPEDARRAY_INVALID_OFFSLEN;
+                if(n * elem_size > (UINT_MAX - FIELD_OFFSET(ArrayBufferInstance, buf[0])))
+                    return E_OUTOFMEMORY;
+                length = n;
+            }else
+                return JS_E_TYPEDARRAY_BAD_CTOR_ARG;
+        }
+
+        if(!r)
+            return S_OK;
+
+        if(!buffer) {
+            hres = create_arraybuf(ctx, length * elem_size, &buffer);
+            if(FAILED(hres))
+                return hres;
+        }
+
+        hres = create_typedarr(ctx, jsclass, buffer, offset, length, &typedarr);
+        jsdisp_release(buffer);
+        if(FAILED(hres))
+            return hres;
+
+        *r = jsval_obj(typedarr);
+        break;
+    }
+    default:
+        FIXME("unimplemented flags: %x\n", flags);
+        return E_NOTIMPL;
+    }
+
+    return S_OK;
+}
+
+#define X(NAME, JSCLASS, TYPE, CONVERT, NUM_TYPE) \
+static HRESULT NAME ## Constr_value(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv, jsval_t *r) \
+{ \
+    return TypedArrayConstr_value(ctx, vthis, flags, argc, argv, r, JSCLASS); \
+}
+TYPEDARRAY_LIST
+#undef X
+
+#define X(NAME, JSCLASS, TYPE, CONVERT, NUM_TYPE) [TYPEDARRAY_INDEX(JSCLASS)] = NAME ## Constr_value,
+static const builtin_invoke_t TypedArray_constr[] = { TYPEDARRAY_LIST };
+#undef X
+
+static const builtin_info_t TypedArrayConstr_info = {
+    JSCLASS_FUNCTION,
+    Function_value,
+    0,
+    NULL,
+    NULL,
+    NULL
+};
+
+HRESULT WINAPI WineDispatchProxyCbPrivate_GetRandomValues(IDispatch *disp)
+{
+    jsdisp_t *obj = to_jsdisp(disp);
+    TypedArrayInstance *typedarr;
+    DWORD size;
+
+    if(!obj || obj->builtin_info->class < FIRST_TYPEDARRAY_JSCLASS || obj->builtin_info->class > LAST_TYPEDARRAY_JSCLASS)
+        return E_INVALIDARG;
+
+    if(obj->builtin_info->class == JSCLASS_FLOAT32ARRAY || obj->builtin_info->class == JSCLASS_FLOAT64ARRAY) {
+        /* FIXME: Return TypeMismatchError */
+        return E_FAIL;
+    }
+
+    typedarr = typedarr_from_jsdisp(obj);
+    size = typedarr->length * TypedArray_elem_size[TYPEDARRAY_INDEX(obj->builtin_info->class)];
+    if(size > 65536) {
+        /* FIXME: Return QuotaExceededError */
+        return E_FAIL;
+    }
+
+    if(!RtlGenRandom(&arraybuf_from_jsdisp(typedarr->buffer)->buf[typedarr->offset], size))
+        return HRESULT_FROM_WIN32(GetLastError());
+
+    return S_OK;
+}
+
+HRESULT init_arraybuf_constructors(script_ctx_t *ctx)
+{
+    static const struct {
+        const WCHAR *name;
+        builtin_invoke_t get;
+    } DataView_getters[] = {
+        { L"buffer",        DataView_get_buffer },
+        { L"byteLength",    DataView_get_byteLength },
+        { L"byteOffset",    DataView_get_byteOffset },
+    };
+    ArrayBufferInstance *arraybuf;
+    TypedArrayInstance *typedarr;
+    DataViewInstance *view;
+    property_desc_t desc;
+    HRESULT hres;
+    unsigned i;
+
+    if(ctx->version < SCRIPTLANGUAGEVERSION_ES5)
+        return S_OK;
+
+    if(!(arraybuf = heap_alloc_zero(FIELD_OFFSET(ArrayBufferInstance, buf[0]))))
+        return E_OUTOFMEMORY;
+
+    hres = init_dispex(&arraybuf->dispex, ctx, &ArrayBuffer_info, ctx->object_prototype);
+    if(FAILED(hres)) {
+        heap_free(arraybuf);
+        return hres;
+    }
+
+    hres = create_builtin_constructor(ctx, ArrayBufferConstr_value, L"ArrayBuffer", &ArrayBufferConstr_info,
+                                      PROPF_CONSTR|1, &arraybuf->dispex, &ctx->arraybuf_constr);
+    jsdisp_release(&arraybuf->dispex);
+    if(FAILED(hres))
+        return hres;
+
+    hres = jsdisp_define_data_property(ctx->global, L"ArrayBuffer", PROPF_CONFIGURABLE | PROPF_WRITABLE,
+                                       jsval_obj(ctx->arraybuf_constr));
+    if(FAILED(hres))
+        return hres;
+
+    if(!(view = heap_alloc_zero(sizeof(DataViewInstance))))
+        return E_OUTOFMEMORY;
+
+    hres = create_arraybuf(ctx, 0, &view->buffer);
+    if(FAILED(hres)) {
+        heap_free(view);
+        return hres;
+    }
+
+    hres = init_dispex(&view->dispex, ctx, &DataView_info, ctx->object_prototype);
+    if(FAILED(hres)) {
+        jsdisp_release(view->buffer);
+        heap_free(view);
+        return hres;
+    }
+
+    desc.flags = PROPF_CONFIGURABLE;
+    desc.mask  = PROPF_CONFIGURABLE | PROPF_ENUMERABLE;
+    desc.explicit_getter = desc.explicit_setter = TRUE;
+    desc.explicit_value = FALSE;
+    desc.setter = NULL;
+
+    for(i = 0; i < ARRAY_SIZE(DataView_getters); i++) {
+        hres = create_builtin_function(ctx, DataView_getters[i].get, NULL, NULL, PROPF_METHOD, NULL, &desc.getter);
+        if(SUCCEEDED(hres)) {
+            hres = jsdisp_define_property(&view->dispex, DataView_getters[i].name, &desc);
+            jsdisp_release(desc.getter);
+        }
+        if(FAILED(hres)) {
+            jsdisp_release(&view->dispex);
+            return hres;
+        }
+    }
+
+    hres = create_builtin_constructor(ctx, DataViewConstr_value, L"DataView", &DataViewConstr_info,
+                                      PROPF_CONSTR|1, &view->dispex, &ctx->dataview_constr);
+    jsdisp_release(&view->dispex);
+    if(FAILED(hres))
+        return hres;
+
+    hres = jsdisp_define_data_property(ctx->global, L"DataView", PROPF_CONFIGURABLE | PROPF_WRITABLE,
+                                       jsval_obj(ctx->dataview_constr));
+    if(FAILED(hres))
+        return hres;
+
+    for(i = 0; i < ARRAY_SIZE(TypedArray_info); i++) {
+        if(!(typedarr = heap_alloc_zero(sizeof(TypedArrayInstance))))
+            return E_OUTOFMEMORY;
+
+        hres = create_arraybuf(ctx, 0, &typedarr->buffer);
+        if(FAILED(hres)) {
+            heap_free(typedarr);
+            return hres;
+        }
+
+        hres = init_dispex(&typedarr->dispex, ctx, &TypedArray_info[i], ctx->object_prototype);
+        if(FAILED(hres)) {
+            jsdisp_release(typedarr->buffer);
+            heap_free(typedarr);
+            return hres;
+        }
+
+        hres = create_builtin_constructor(ctx, TypedArray_constr[i], TypedArray_name[i], &TypedArrayConstr_info,
+                                          PROPF_CONSTR|1, &typedarr->dispex, &ctx->typedarr_constr[i]);
+        jsdisp_release(&typedarr->dispex);
+        if(FAILED(hres))
+            return hres;
+
+        hres = jsdisp_define_data_property(ctx->typedarr_constr[i], L"BYTES_PER_ELEMENT", 0,
+                                           jsval_number(TypedArray_elem_size[i]));
+        if(FAILED(hres))
+            return hres;
+
+        hres = jsdisp_define_data_property(ctx->global, TypedArray_name[i], PROPF_CONFIGURABLE | PROPF_WRITABLE,
+                                           jsval_obj(ctx->typedarr_constr[i]));
+        if(FAILED(hres))
+            return hres;
+    }
+
+    return hres;
+}
diff --git a/dlls/jscript/dispex.c b/dlls/jscript/dispex.c
index 468a0ddf557..79d66471675 100644
--- a/dlls/jscript/dispex.c
+++ b/dlls/jscript/dispex.c
@@ -17,6 +17,7 @@
  */
 
 #include <assert.h>
+#include <limits.h>
 
 #include "jscript.h"
 #include "engine.h"
@@ -35,6 +36,7 @@ typedef enum {
     PROP_BUILTIN,
     PROP_PROTREF,
     PROP_ACCESSOR,
+    PROP_PROXY,
     PROP_DELETED,
     PROP_IDX
 } prop_type_t;
@@ -54,6 +56,10 @@ struct _dispex_prop_t {
             jsdisp_t *getter;
             jsdisp_t *setter;
         } accessor;
+        struct {
+            DISPID id;
+            DWORD flags;
+        } proxy;
     } u;
 
     int bucket_head;
@@ -95,6 +101,13 @@ static inline dispex_prop_t *get_prop(jsdisp_t *This, DISPID id)
     return This->props[idx].type == PROP_DELETED ? NULL : &This->props[idx];
 }
 
+static inline BOOL is_accessor_prop(dispex_prop_t *prop)
+{
+    if(prop->type == PROP_PROXY)
+        return (prop->u.proxy.flags & PROPF_PROXY_ACCESSOR);
+    return prop->type == PROP_ACCESSOR;
+}
+
 static inline BOOL is_function_prop(dispex_prop_t *prop)
 {
     BOOL ret = FALSE;
@@ -109,6 +122,29 @@ static inline BOOL is_function_prop(dispex_prop_t *prop)
     return ret;
 }
 
+static inline BOOL override_idx(jsdisp_t *This, const WCHAR *name, unsigned *ret_idx)
+{
+    /* Typed Arrays override every positive index */
+    if(This->builtin_info->class >= FIRST_TYPEDARRAY_JSCLASS && This->builtin_info->class <= LAST_TYPEDARRAY_JSCLASS) {
+        const WCHAR *ptr;
+        unsigned idx = 0;
+
+        for(ptr = name; is_digit(*ptr) && idx <= (UINT_MAX-9 / 10); ptr++)
+            idx = idx*10 + (*ptr-'0');
+        if(!*ptr) {
+            *ret_idx = idx;
+            return TRUE;
+        }else {
+            while(is_digit(*ptr)) ptr++;
+            if(!*ptr) {
+                *ret_idx = UINT_MAX;
+                return TRUE;
+            }
+        }
+    }
+    return FALSE;
+}
+
 static DWORD get_flags(jsdisp_t *This, dispex_prop_t *prop)
 {
     if(prop->type == PROP_PROTREF) {
@@ -225,6 +261,26 @@ static inline dispex_prop_t* alloc_prop(jsdisp_t *This, const WCHAR *name, prop_
     return prop;
 }
 
+static inline dispex_prop_t *alloc_proxy_prop(jsdisp_t *This, dispex_prop_t *prop, const WCHAR *name, DISPID id)
+{
+    unsigned flags, prop_flags = This->proxy->lpVtbl->PropFlags(This->proxy, id);
+
+    flags = prop_flags & PROPF_ALL;
+
+    if(prop) {
+        prop->type = PROP_PROXY;
+        prop->flags = flags;
+    }else {
+        prop = alloc_prop(This, name, PROP_PROXY, flags);
+        if(!prop)
+            return NULL;
+    }
+
+    prop->u.proxy.id = id;
+    prop->u.proxy.flags = prop_flags;
+    return prop;
+}
+
 static dispex_prop_t *alloc_protref(jsdisp_t *This, const WCHAR *name, DWORD ref)
 {
     dispex_prop_t *ret;
@@ -237,11 +293,9 @@ static dispex_prop_t *alloc_protref(jsdisp_t *This, const WCHAR *name, DWORD ref
     return ret;
 }
 
-static HRESULT find_prop_name(jsdisp_t *This, unsigned hash, const WCHAR *name, dispex_prop_t **ret)
+static dispex_prop_t *find_prop_name_raw(jsdisp_t *This, unsigned hash, const WCHAR *name)
 {
-    const builtin_prop_t *builtin;
     unsigned bucket, pos, prev = ~0;
-    dispex_prop_t *prop;
 
     bucket = get_props_idx(This, hash);
     pos = This->props[bucket].bucket_head;
@@ -253,13 +307,46 @@ static HRESULT find_prop_name(jsdisp_t *This, unsigned hash, const WCHAR *name,
                 This->props[bucket].bucket_head = pos;
             }
 
-            *ret = &This->props[pos];
-            return S_OK;
+            return &This->props[pos];
         }
 
         prev = pos;
         pos = This->props[pos].bucket_next;
     }
+    return NULL;
+}
+
+static HRESULT find_prop_name(jsdisp_t *This, unsigned hash, const WCHAR *name, dispex_prop_t **ret)
+{
+    dispex_prop_t *prop = find_prop_name_raw(This, hash, name);
+    const builtin_prop_t *builtin;
+
+    if(prop) {
+        *ret = prop;
+        return S_OK;
+    }
+
+    if(This->proxy) {
+        HRESULT hres;
+        WCHAR *str;
+        DISPID id;
+
+        if(!(str = heap_strdupW(name)))
+            return E_OUTOFMEMORY;
+        hres = This->proxy->lpVtbl->PropGetID(This->proxy, str, &id);
+        heap_free(str);
+
+        if(hres != DISP_E_UNKNOWNNAME) {
+            if(FAILED(hres))
+                return hres;
+            prop = alloc_proxy_prop(This, NULL, name, id);
+            if(!prop)
+                return E_OUTOFMEMORY;
+
+            *ret = prop;
+            return S_OK;
+        }
+    }
 
     builtin = find_builtin_prop(This, name);
     if(builtin) {
@@ -419,6 +506,56 @@ static HRESULT convert_params(script_ctx_t *ctx, const DISPPARAMS *dp, jsval_t *
     return S_OK;
 }
 
+static HRESULT proxy_disp_call(jsdisp_t *This, IDispatch *jsthis, DISPID id, unsigned flags, unsigned argc,
+        jsval_t *argv, jsval_t *ret)
+{
+    DISPPARAMS dp = { NULL, NULL, argc, 0 };
+    EXCEPINFO ei = { 0 };
+    VARIANT buf[6], retv;
+    HRESULT hres;
+    unsigned i;
+
+    if(dp.cArgs <= ARRAY_SIZE(buf))
+        dp.rgvarg = buf;
+    else if(!(dp.rgvarg = heap_alloc(dp.cArgs * sizeof(*dp.rgvarg))))
+        return E_OUTOFMEMORY;
+
+    for(i = 0; i < dp.cArgs; i++) {
+        hres = jsval_to_variant(argv[i], &dp.rgvarg[dp.cArgs - i - 1]);
+        if(FAILED(hres))
+            goto cleanup;
+    }
+
+    if(!jsthis)
+        jsthis = (IDispatch*)This->proxy;
+    else {
+        jsdisp_t *jsdisp = to_jsdisp(jsthis);
+        if(jsdisp && jsdisp->proxy)
+            jsthis = (IDispatch*)jsdisp->proxy;
+    }
+
+    V_VT(&retv) = VT_EMPTY;
+    IDispatch_AddRef(jsthis);
+    flags &= ~DISPATCH_JSCRIPT_INTERNAL_MASK;
+    hres = This->proxy->lpVtbl->PropInvoke(This->proxy, jsthis, id, This->ctx->lcid, flags, &dp, ret ? &retv : NULL,
+                                           &ei, &This->ctx->jscaller->IServiceProvider_iface);
+    IDispatch_Release(jsthis);
+
+    if(hres == DISP_E_EXCEPTION)
+        disp_fill_exception(This->ctx, &ei);
+    else if(SUCCEEDED(hres) && ret) {
+        hres = variant_to_jsval(This->ctx, &retv, ret);
+        VariantClear(&retv);
+    }
+
+cleanup:
+    while(i--)
+        VariantClear(&dp.rgvarg[i]);
+    if(dp.rgvarg != buf)
+        heap_free(dp.rgvarg);
+    return hres;
+}
+
 static HRESULT prop_get(jsdisp_t *This, dispex_prop_t *prop,  jsval_t *r)
 {
     jsdisp_t *prop_obj = This;
@@ -461,6 +598,36 @@ static HRESULT prop_get(jsdisp_t *This, dispex_prop_t *prop,  jsval_t *r)
             hres = S_OK;
         }
         break;
+    case PROP_PROXY:
+        if(!(prop->u.proxy.flags & PROPF_METHOD)) {
+            DISPPARAMS dp = { 0 };
+            EXCEPINFO ei = { 0 };
+            VARIANT var;
+
+            V_VT(&var) = VT_EMPTY;
+            hres = prop_obj->proxy->lpVtbl->PropInvoke(prop_obj->proxy, This->proxy ? (IDispatch*)This->proxy : to_disp(This),
+                                                       prop->u.proxy.id, This->ctx->lcid, DISPATCH_PROPERTYGET, &dp, &var,
+                                                       &ei, &This->ctx->jscaller->IServiceProvider_iface);
+            if(hres == DISP_E_EXCEPTION)
+                disp_fill_exception(This->ctx, &ei);
+            else if(SUCCEEDED(hres)) {
+                hres = variant_to_jsval(This->ctx, &var, r);
+                VariantClear(&var);
+            }
+        }else {
+            jsdisp_t *obj;
+
+            hres = create_proxy_function(prop_obj, prop->u.proxy.id, prop->u.proxy.flags, &obj);
+            if(FAILED(hres))
+                break;
+
+            prop->type = PROP_JSVAL;
+            prop->u.val = jsval_obj(obj);
+
+            jsdisp_addref(obj);
+            *r = jsval_obj(obj);
+        }
+        break;
     case PROP_IDX:
         hres = prop_obj->builtin_info->idx_get(prop_obj, prop->u.idx, r);
         break;
@@ -468,6 +635,8 @@ static HRESULT prop_get(jsdisp_t *This, dispex_prop_t *prop,  jsval_t *r)
         ERR("type %d\n", prop->type);
         return E_FAIL;
     }
+    if(SUCCEEDED(hres))
+        hres = convert_to_proxy(This->ctx, r);
 
     if(FAILED(hres)) {
         TRACE("fail %08lx\n", hres);
@@ -480,6 +649,7 @@ static HRESULT prop_get(jsdisp_t *This, dispex_prop_t *prop,  jsval_t *r)
 
 static HRESULT prop_put(jsdisp_t *This, dispex_prop_t *prop, jsval_t val)
 {
+    jsdisp_t *prop_obj = This;
     HRESULT hres;
 
     if(prop->type == PROP_PROTREF) {
@@ -491,8 +661,10 @@ static HRESULT prop_put(jsdisp_t *This, dispex_prop_t *prop, jsval_t val)
             prop_iter = prototype_iter->props + prop_iter->u.ref;
         } while(prop_iter->type == PROP_PROTREF);
 
-        if(prop_iter->type == PROP_ACCESSOR)
+        if(is_accessor_prop(prop_iter)) {
+            prop_obj = prototype_iter;
             prop = prop_iter;
+        }
     }
 
     switch(prop->type) {
@@ -528,6 +700,26 @@ static HRESULT prop_put(jsdisp_t *This, dispex_prop_t *prop, jsval_t val)
             return S_OK;
         }
         return jsdisp_call_value(prop->u.accessor.setter, to_disp(This), DISPATCH_METHOD, 1, &val, NULL);
+    case PROP_PROXY: {
+        static DISPID propput_dispid = DISPID_PROPERTYPUT;
+        EXCEPINFO ei = { 0 };
+        VARIANT var;
+        DISPPARAMS dp = { &var, &propput_dispid, 1, 1 };
+
+        if(!is_accessor_prop(prop) && !(prop->flags & PROPF_WRITABLE))
+            return S_OK;
+        hres = jsval_to_variant(val, &var);
+        if(FAILED(hres))
+            return hres;
+
+        hres = prop_obj->proxy->lpVtbl->PropInvoke(prop_obj->proxy, This->proxy ? (IDispatch*)This->proxy : to_disp(This),
+                                                   prop->u.proxy.id, This->ctx->lcid, DISPATCH_PROPERTYPUT, &dp, NULL,
+                                                   &ei, &This->ctx->jscaller->IServiceProvider_iface);
+        VariantClear(&var);
+        if(hres == DISP_E_EXCEPTION)
+            disp_fill_exception(This->ctx, &ei);
+        return hres;
+    }
     case PROP_IDX:
         if(!This->builtin_info->idx_put) {
             TRACE("no put_idx\n");
@@ -574,7 +766,11 @@ static HRESULT invoke_prop_func(jsdisp_t *This, IDispatch *jsthis, dispex_prop_t
             vthis = jsval_disp(jsthis);
         else
             vthis = jsval_obj(This);
-        return prop->u.p->invoke(This->ctx, vthis, flags, argc, argv, r);
+        hres = prop->u.p->invoke(This->ctx, vthis, flags, argc, argv, r);
+
+        if(SUCCEEDED(hres))
+            hres = convert_to_proxy(This->ctx, r);
+        return hres;
     }
     case PROP_PROTREF:
         return invoke_prop_func(This->prototype, jsthis ? jsthis : (IDispatch *)&This->IDispatchEx_iface,
@@ -611,6 +807,8 @@ static HRESULT invoke_prop_func(jsdisp_t *This, IDispatch *jsthis, dispex_prop_t
         jsval_release(val);
         return hres;
     }
+    case PROP_PROXY:
+        return proxy_disp_call(This, jsthis, prop->u.proxy.id, flags, argc, argv, r);
     case PROP_DELETED:
         assert(0);
         break;
@@ -628,6 +826,7 @@ HRESULT builtin_set_const(script_ctx_t *ctx, jsdisp_t *jsthis, jsval_t value)
 static HRESULT fill_protrefs(jsdisp_t *This)
 {
     dispex_prop_t *iter, *prop;
+    unsigned idx;
     HRESULT hres;
 
     if(!This->prototype)
@@ -636,6 +835,8 @@ static HRESULT fill_protrefs(jsdisp_t *This)
     fill_protrefs(This->prototype);
 
     for(iter = This->prototype->props; iter < This->prototype->props+This->prototype->prop_cnt; iter++) {
+        if(override_idx(This, iter->name, &idx))
+            continue;
         hres = find_prop_name(This, iter->hash, iter->name, &prop);
         if(FAILED(hres))
             return hres;
@@ -655,6 +856,237 @@ static HRESULT fill_protrefs(jsdisp_t *This)
     return S_OK;
 }
 
+static void unlink_props(jsdisp_t *jsdisp)
+{
+    dispex_prop_t *prop = jsdisp->props, *end;
+
+    for(end = prop + jsdisp->prop_cnt; prop < end; prop++) {
+        switch(prop->type) {
+        case PROP_DELETED:
+        case PROP_PROTREF:
+            continue;
+        case PROP_JSVAL:
+            jsval_release(prop->u.val);
+            break;
+        case PROP_ACCESSOR:
+            if(prop->u.accessor.getter)
+                jsdisp_release(prop->u.accessor.getter);
+            if(prop->u.accessor.setter)
+                jsdisp_release(prop->u.accessor.setter);
+            break;
+        default:
+            break;
+        }
+        prop->type = PROP_JSVAL;
+        prop->flags &= PROPF_ALL;
+        prop->flags |= PROPF_CONFIGURABLE | PROPF_WRITABLE;
+        prop->u.val = jsval_undefined();
+    }
+}
+
+
+
+/*
+ * To deal with circular refcounts, a basic Garbage Collector is used with a variant of the
+ * mark-and-sweep algorithm that doesn't require knowing or traversing any specific "roots".
+ * This works based on the assumption that circular references can only happen when objects
+ * end up pointing to each other, and each other alone, without any external refs.
+ *
+ * An "external ref" is a ref to the object that's not from any other object. Example of such
+ * refs can be local variables, the script ctx (which keeps a ref to the global object), etc.
+ *
+ * Broadly, there are 3 passes done on the entire list of objects:
+ *
+ * 1. Speculatively decrease refcounts of each linked-to-object from each object. This ensures
+ *    that the only remaining refcount on each object is the number of "external refs" to it.
+ *    At the same time, mark all of the objects so that they can be potentially collected.
+ *
+ * 2. For each object with a non-zero "external refcount", clear the mark from step 1, and
+ *    recursively traverse all linked objects from it, clearing their marks as well (regardless
+ *    of their refcount), stopping a given path when the object is unmarked (and then going back
+ *    up the heap stack). This basically unmarks all of the objects with "external refcounts"
+ *    and those accessible from them, and only the leaked dangling objects will still be marked.
+ *
+ * 3. For each object that is marked, unlink all of the objects linked from it, because they
+ *    are dangling in a circular refcount and not accessible. This should release them.
+ *
+ * This collection process has to be done periodically, but can be pretty expensive so there
+ * has to be a balance between reclaiming dangling objects and performance.
+ */
+static void gc_run(script_ctx_t *ctx)
+{
+    /* Save original refcounts in a linked list of chunks,
+       so we don't bloat object size unnecessarily. */
+    struct chunk
+    {
+        struct chunk *next;
+        LONG ref[1020];
+    } *head, *chunk;
+    jsdisp_t *obj, *obj2, *link, *link2;
+    struct heap_stack heap_stack = { 0 };
+    dispex_prop_t *prop, *props_end;
+    unsigned chunk_idx = 0;
+    HRESULT hres;
+
+    if(!(head = heap_alloc(sizeof(*head))))
+        return;
+    head->next = NULL;
+    chunk = head;
+
+    /* 1. Save actual refcounts and decrease them speculatively as-if we unlinked the objects */
+    LIST_FOR_EACH_ENTRY(obj, &ctx->objects, jsdisp_t, entry) {
+        if(chunk_idx == ARRAY_SIZE(chunk->ref)) {
+            if(!(chunk->next = heap_alloc(sizeof(*chunk)))) {
+                do {
+                    chunk = head->next;
+                    free(head);
+                    head = chunk;
+                } while(head);
+                return;
+            }
+            chunk = chunk->next, chunk_idx = 0;
+            chunk->next = NULL;
+        }
+        chunk->ref[chunk_idx++] = obj->ref;
+    }
+    LIST_FOR_EACH_ENTRY(obj, &ctx->objects, jsdisp_t, entry) {
+        for(prop = obj->props, props_end = prop + obj->prop_cnt; prop < props_end; prop++) {
+            switch(prop->type) {
+            case PROP_JSVAL:
+                if(is_object_instance(prop->u.val) && (link = to_jsdisp(get_object(prop->u.val))) && link->ctx == ctx)
+                    link->ref--;
+                break;
+            case PROP_ACCESSOR:
+                if(prop->u.accessor.getter && prop->u.accessor.getter->ctx == ctx)
+                    prop->u.accessor.getter->ref--;
+                if(prop->u.accessor.setter && prop->u.accessor.setter->ctx == ctx)
+                    prop->u.accessor.setter->ref--;
+                break;
+            default:
+                break;
+            }
+        }
+
+        if(obj->prototype && obj->prototype->ctx == ctx)
+            obj->prototype->ref--;
+        if(obj->builtin_info->gc_traverse)
+            obj->builtin_info->gc_traverse(obj, GC_TRAVERSE_SPECULATIVELY);
+        obj->gc_marked = TRUE;
+    }
+
+    /* 2. Clear mark on objects with non-zero "external refcount" and all objects accessible from them */
+    chunk = head, chunk_idx = 0;
+    LIST_FOR_EACH_ENTRY(obj, &ctx->objects, jsdisp_t, entry) {
+        LONG external_ref = obj->ref;
+
+        obj->ref = chunk->ref[chunk_idx++];  /* restore */
+        if(chunk_idx == ARRAY_SIZE(chunk->ref)) {
+            struct chunk *next = chunk->next;
+            free(chunk);
+            chunk = next, chunk_idx = 0;
+        }
+        if(!obj->gc_marked || (!external_ref && (!obj->proxy || obj->proxy->lpVtbl->CanGC(obj->proxy))))
+            continue;
+
+        hres = heap_stack_push(&heap_stack, NULL);
+        if(FAILED(hres))
+            goto unwind;
+
+        obj2 = obj;
+        do
+        {
+            obj2->gc_marked = FALSE;
+
+            for(prop = obj2->props, props_end = prop + obj2->prop_cnt; prop < props_end; prop++) {
+                switch(prop->type) {
+                case PROP_JSVAL:
+                    if(!is_object_instance(prop->u.val))
+                        continue;
+                    link = to_jsdisp(get_object(prop->u.val));
+                    link2 = NULL;
+                    break;
+                case PROP_ACCESSOR:
+                    link = prop->u.accessor.getter;
+                    link2 = prop->u.accessor.setter;
+                    break;
+                default:
+                    continue;
+                }
+                if(link && link->gc_marked && link->ctx == ctx) {
+                    hres = heap_stack_push(&heap_stack, link);
+                    if(FAILED(hres))
+                        goto unwind2;
+                }
+                if(link2 && link2->gc_marked && link2->ctx == ctx) {
+                    hres = heap_stack_push(&heap_stack, link2);
+                    if(FAILED(hres))
+                        goto unwind2;
+                }
+            }
+
+            if(obj2->prototype && obj2->prototype->gc_marked && obj2->prototype->ctx == ctx) {
+                hres = heap_stack_push(&heap_stack, obj2->prototype);
+                if(FAILED(hres))
+                    goto unwind2;
+            }
+
+            if(obj2->builtin_info->gc_traverse) {
+                hres = obj2->builtin_info->gc_traverse(obj2, &heap_stack);
+                if(FAILED(hres))
+                    goto unwind2;
+            }
+
+            do obj2 = heap_stack_pop(&heap_stack); while(obj2 && !obj2->gc_marked);
+        } while(obj2);
+    }
+    heap_stack_free(&heap_stack);
+    free(chunk);
+
+    /* 3. Remove all the links from the marked objects, since they are dangling */
+    LIST_FOR_EACH_ENTRY_SAFE(obj, obj2, &ctx->objects, jsdisp_t, entry) {
+        if(!obj->gc_marked)
+            continue;
+
+        /* Grab it since it gets removed when unlinked */
+        jsdisp_addref(obj);
+        unlink_props(obj);
+
+        if(obj->prototype) {
+            jsdisp_release(obj->prototype);
+            obj->prototype = NULL;
+        }
+
+        if(obj->builtin_info->gc_traverse)
+            obj->builtin_info->gc_traverse(obj, GC_TRAVERSE_UNLINK);
+
+        /* Unlinking possibly removed the next object from the list, so grab it here */
+        obj2 = LIST_ENTRY(obj->entry.next, jsdisp_t, entry);
+        jsdisp_release(obj);
+    }
+
+    ctx->gc_last_tick = GetTickCount();
+    return;
+
+unwind2:
+    do obj2 = heap_stack_pop(&heap_stack); while(obj2);
+unwind:
+    heap_stack_free(&heap_stack);
+
+    while(&(obj = LIST_ENTRY(obj->entry.next, jsdisp_t, entry))->entry != &ctx->objects) {
+        obj->ref = chunk->ref[chunk_idx++];
+        if(chunk_idx == ARRAY_SIZE(chunk->ref)) {
+            struct chunk *next = chunk->next;
+            free(chunk);
+            chunk = next, chunk_idx = 0;
+        }
+    }
+    free(chunk);
+    LIST_FOR_EACH_ENTRY(obj, &ctx->objects, jsdisp_t, entry)
+        obj->gc_marked = FALSE;
+}
+
+
+
 struct typeinfo_func {
     dispex_prop_t *prop;
     function_code_t *code;
@@ -1666,7 +2098,7 @@ static HRESULT WINAPI DispatchEx_InvokeEx(IDispatchEx *iface, DISPID id, LCID lc
     return leave_script(This->ctx, hres);
 }
 
-static HRESULT delete_prop(dispex_prop_t *prop, BOOL *ret)
+static HRESULT delete_prop(jsdisp_t *prop_obj, dispex_prop_t *prop, BOOL *ret)
 {
     if(prop->type == PROP_PROTREF) {
         *ret = TRUE;
@@ -1680,6 +2112,13 @@ static HRESULT delete_prop(dispex_prop_t *prop, BOOL *ret)
 
     *ret = TRUE;
 
+    if(prop->type == PROP_PROXY) {
+        HRESULT hres = prop_obj->proxy->lpVtbl->PropDelete(prop_obj->proxy, prop->u.proxy.id);
+        if(FAILED(hres))
+            return hres;
+        prop->type = PROP_DELETED;
+        return S_OK;
+    }
     if(prop->type == PROP_JSVAL)
         jsval_release(prop->u.val);
     if(prop->type == PROP_ACCESSOR) {
@@ -1696,6 +2135,7 @@ static HRESULT WINAPI DispatchEx_DeleteMemberByName(IDispatchEx *iface, BSTR bst
 {
     jsdisp_t *This = impl_from_IDispatchEx(iface);
     dispex_prop_t *prop;
+    unsigned idx;
     BOOL b;
     HRESULT hres;
 
@@ -1704,6 +2144,9 @@ static HRESULT WINAPI DispatchEx_DeleteMemberByName(IDispatchEx *iface, BSTR bst
     if(grfdex & ~(fdexNameCaseSensitive|fdexNameEnsure|fdexNameImplicit|FDEX_VERSION_MASK))
         FIXME("Unsupported grfdex %lx\n", grfdex);
 
+    if(override_idx(This, bstrName, &idx))
+        return S_OK;
+
     hres = find_prop_name(This, string_hash(bstrName), bstrName, &prop);
     if(FAILED(hres))
         return hres;
@@ -1712,7 +2155,7 @@ static HRESULT WINAPI DispatchEx_DeleteMemberByName(IDispatchEx *iface, BSTR bst
         return S_OK;
     }
 
-    return delete_prop(prop, &b);
+    return delete_prop(This, prop, &b);
 }
 
 static HRESULT WINAPI DispatchEx_DeleteMemberByDispID(IDispatchEx *iface, DISPID id)
@@ -1729,7 +2172,7 @@ static HRESULT WINAPI DispatchEx_DeleteMemberByDispID(IDispatchEx *iface, DISPID
         return DISP_E_MEMBERNOTFOUND;
     }
 
-    return delete_prop(prop, &b);
+    return delete_prop(This, prop, &b);
 }
 
 static HRESULT WINAPI DispatchEx_GetMemberProperties(IDispatchEx *iface, DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
@@ -1778,7 +2221,327 @@ static HRESULT WINAPI DispatchEx_GetNameSpaceParent(IDispatchEx *iface, IUnknown
     return E_NOTIMPL;
 }
 
-static IDispatchExVtbl DispatchExVtbl = {
+/* ECMA-262 5.1 Edition    15.1 */
+static HRESULT set_js_globals(jsdisp_t *obj)
+{
+    jsdisp_t *js_global = obj->ctx->js_global;
+    const builtin_prop_t *bprop, *bend;
+    dispex_prop_t *prop, *end, *dst;
+    HRESULT hres;
+    BOOL b;
+
+    /* Reset builtins first */
+    obj->builtin_info = js_global->builtin_info;
+    for(bprop = obj->builtin_info->props, bend = bprop + obj->builtin_info->props_cnt; bprop != bend; bprop++) {
+        if(!(prop = find_prop_name_raw(obj, string_hash(bprop->name), bprop->name)) || prop->type == PROP_BUILTIN)
+            continue;
+        prop->flags |= PROPF_CONFIGURABLE;
+        delete_prop(obj, prop, &b);
+        prop->flags = PROPF_WRITABLE | PROPF_CONFIGURABLE;
+        prop->type = PROP_BUILTIN;
+        prop->u.p = bprop;
+    }
+
+    /* Copy the rest of the props */
+    for(prop = js_global->props, end = prop + js_global->prop_cnt; prop != end; prop++) {
+        if(prop->type != PROP_JSVAL && prop->type != PROP_ACCESSOR)
+            continue;
+
+        /* Alloc it ourselves so we don't look into proxy props when defining it */
+        if(!(dst = find_prop_name_raw(obj, prop->hash, prop->name))) {
+            if(!(dst = alloc_prop(obj, prop->name, PROP_DELETED, 0)))
+               return E_OUTOFMEMORY;
+        }else {
+            dst->flags |= PROPF_CONFIGURABLE;
+            delete_prop(obj, dst, &b);
+        }
+
+        dst->flags = prop->flags;
+        dst->type = prop->type;
+        if(prop->type == PROP_JSVAL) {
+            hres = jsval_copy(prop->u.val, &dst->u.val);
+            if(FAILED(hres))
+                return hres;
+        }else {
+            dst->u.accessor.getter = prop->u.accessor.getter ? jsdisp_addref(prop->u.accessor.getter) : NULL;
+            dst->u.accessor.setter = prop->u.accessor.setter ? jsdisp_addref(prop->u.accessor.setter) : NULL;
+        }
+    }
+
+    return S_OK;
+}
+
+static HRESULT get_proxy_default_prototype(script_ctx_t *ctx, IWineDispatchProxyPrivate *proxy, jsdisp_t **prot)
+{
+    IDispatch *disp = proxy->lpVtbl->GetDefaultPrototype(proxy, &ctx->proxy_prototypes);
+    HRESULT hres;
+
+    if(!disp)
+        return E_OUTOFMEMORY;
+
+    if(disp == WINE_DISP_PROXY_NULL_PROTOTYPE)
+        *prot = NULL;
+    else if(disp == WINE_DISP_PROXY_OBJECT_PROTOTYPE)
+        *prot = jsdisp_addref(ctx->object_prototype);
+    else {
+        jsval_t tmp = jsval_disp(disp);
+        hres = convert_to_proxy(ctx, &tmp);
+        if(FAILED(hres))
+            return hres;
+        *prot = as_jsdisp(get_object(tmp));
+    }
+    return S_OK;
+}
+
+static HRESULT get_proxy_default_constructor(script_ctx_t *ctx, jsdisp_t *prot, jsdisp_t **ctor)
+{
+    IDispatch *disp = prot->proxy->lpVtbl->GetDefaultConstructor(prot->proxy, ctx->proxy_prototypes);
+    HRESULT hres;
+    jsval_t tmp;
+
+    if(!disp)
+        return E_OUTOFMEMORY;
+
+    tmp = jsval_disp(disp);
+    hres = convert_to_proxy(ctx, &tmp);
+    if(FAILED(hres))
+        return hres;
+    *ctor = as_jsdisp(get_object(tmp));
+
+    hres = jsdisp_define_data_property(*ctor, L"prototype", 0, jsval_obj(prot));
+    if(FAILED(hres))
+        jsdisp_release(*ctor);
+    return hres;
+}
+
+static HRESULT maybe_init_global_proxy(jsdisp_t *jsdisp)
+{
+    script_ctx_t *ctx = jsdisp->ctx;
+    jsdisp_t *tmp = ctx->global;
+    HRESULT hres;
+
+    /* DefineConstructors may end up in CreateConstructor from GetDefaultConstructor via some
+       prototype's setup, which assumes the global to be the one required. Since we can have
+       window objects that are not the actual global (e.g. from iframe), set it temporarily. */
+    ctx->global = jsdisp;
+    hres = jsdisp->proxy->lpVtbl->DefineConstructors(jsdisp->proxy, &ctx->proxy_prototypes);
+    ctx->global = tmp;
+
+    if(hres == S_OK)
+        hres = set_js_globals(jsdisp);
+    return hres;
+}
+
+static inline jsdisp_t *impl_from_IWineDispatchProxyCbPrivate(IWineDispatchProxyCbPrivate *iface)
+{
+    return impl_from_IDispatchEx((IDispatchEx*)iface);
+}
+
+static void WINAPI WineDispatchProxyCbPrivate_Unlinked(IWineDispatchProxyCbPrivate *iface)
+{
+    jsdisp_t *This = impl_from_IWineDispatchProxyCbPrivate(iface);
+
+    if(This->ref)
+        iface->lpVtbl->Relinked(iface, NULL);
+    else {
+        This->proxy = NULL;
+        jsdisp_free(This);
+    }
+}
+
+static void WINAPI WineDispatchProxyCbPrivate_Relinked(IWineDispatchProxyCbPrivate *iface, IWineDispatchProxyPrivate *proxy)
+{
+    jsdisp_t *This = impl_from_IWineDispatchProxyCbPrivate(iface);
+
+    /* We hold a ref to the proxy only when we're not dangling */
+    if(This->ref && This->proxy)
+        IDispatchEx_Release((IDispatchEx*)This->proxy);
+
+    This->proxy = proxy;
+    if(!proxy)
+        unlink_props(This);
+    else {
+        if(This->ref)
+            IDispatchEx_AddRef((IDispatchEx*)proxy);
+        /* Defer repopulating the proxy props to HostUpdated since we can't query the props
+           while the mode is not known yet, which could cause premature document mode lock. */
+    }
+}
+
+static HRESULT WINAPI WineDispatchProxyCbPrivate_HostUpdated(IWineDispatchProxyCbPrivate *iface, IActiveScript *script)
+{
+    jsdisp_t *This = impl_from_IWineDispatchProxyCbPrivate(iface);
+    script_ctx_t *ctx = script ? get_script_ctx(script) : This->ctx;
+    dispex_prop_t *prop, *end;
+    jsdisp_t *prot;
+    HRESULT hres;
+    DISPID id;
+    BOOL b;
+
+    if(!ctx || !ctx->global)
+        return S_OK;
+
+    if(This->ctx != ctx) {
+        if(ctx->version < SCRIPTLANGUAGEVERSION_ES5) {
+            /* Incompatible compat mode, so unlink the proxy */
+            *This->proxy->lpVtbl->GetProxyFieldRef(This->proxy) = NULL;
+            iface->lpVtbl->Unlinked(iface);
+            return S_OK;
+        }
+
+        hres = get_proxy_default_prototype(ctx, This->proxy, &prot);
+        if(FAILED(hres))
+            return hres;
+
+        if(This->ref) {
+            list_remove(&This->entry);
+            list_add_tail(&ctx->objects, &This->entry);
+        }
+        script_release(This->ctx);
+        script_addref(ctx);
+        This->ctx = ctx;
+
+        hres = jsdisp_change_prototype(This, prot);
+        if(prot)
+            jsdisp_release(prot);
+        if(FAILED(hres))
+            return hres;
+    }
+
+    for(prop = This->props, end = prop + This->prop_cnt; prop < end; prop++) {
+        if(prop->type == PROP_PROXY)
+            prop->type = PROP_DELETED;
+        else {
+            prop->flags |= PROPF_CONFIGURABLE;
+            delete_prop(This, prop, &b);
+        }
+        hres = This->proxy->lpVtbl->PropGetID(This->proxy, prop->name, &id);
+        if(SUCCEEDED(hres))
+            alloc_proxy_prop(This, prop, prop->name, id);
+    }
+
+    return maybe_init_global_proxy(This);
+}
+
+static DISPID WINAPI WineDispatchProxyCbPrivate_GetUnderlyingDispID(IWineDispatchProxyCbPrivate *iface, DISPID id)
+{
+    jsdisp_t *prop_obj = impl_from_IWineDispatchProxyCbPrivate(iface);
+    dispex_prop_t *prop = get_prop(prop_obj, id);
+
+    if(prop) {
+        while(prop->type == PROP_PROTREF) {
+            prop_obj = prop_obj->prototype;
+            prop = prop_obj->props + prop->u.ref;
+        }
+        if(prop->type == PROP_PROXY)
+            return prop->u.proxy.id;
+    }
+    return DISPID_UNKNOWN;
+}
+
+static IDispatch* WINAPI WineDispatchProxyCbPrivate_CreateConstructor(IWineDispatchProxyCbPrivate *iface,
+        DISPID id, const WCHAR *name)
+{
+    jsdisp_t *This = impl_from_IWineDispatchProxyCbPrivate(iface);
+    jsdisp_t *ctor;
+    HRESULT hres;
+
+    hres = create_proxy_constructor(id, name, This, &ctor);
+    return SUCCEEDED(hres) ? (IDispatch*)&ctor->IDispatchEx_iface : NULL;
+}
+
+static HRESULT WINAPI WineDispatchProxyCbPrivate_DefineConstructor(IWineDispatchProxyCbPrivate *iface,
+        const WCHAR *name, IDispatch *prot_disp, DISPID id)
+{
+    jsdisp_t *This = impl_from_IWineDispatchProxyCbPrivate(iface);
+    jsval_t val = jsval_disp(prot_disp);
+    jsdisp_t *prot, *ctor;
+    dispex_prop_t *prop;
+    HRESULT hres;
+    BOOL b;
+
+    hres = convert_to_proxy(This->ctx, &val);
+    if(FAILED(hres))
+        return hres;
+    prot = as_jsdisp(get_object(val));
+
+    if(id == DISPID_UNKNOWN) {
+        /* The prototype's proxy should have already set up the constructor, so it can't fail */
+        val = jsval_disp(prot->proxy->lpVtbl->GetDefaultConstructor(prot->proxy, This->ctx->proxy_prototypes));
+        convert_to_proxy(This->ctx, &val);
+        ctor = as_jsdisp(get_object(val));
+    }else {
+        hres = create_proxy_constructor(id, name, prot, &ctor);
+    }
+    jsdisp_release(prot);
+    if(FAILED(hres))
+        return hres;
+
+    /* Remove the builtin proxy prop from the prototype, since it's part of the object itself */
+    if(find_prop_name(This->prototype, string_hash(name), name, &prop) == S_OK && prop && prop->type == PROP_PROXY)
+        delete_prop(This->prototype, prop, &b);
+
+    /* Define the constructor forcefully, so make sure to not look into the underlying proxy dispids,
+       otherwise it might pick up elements by this id. And if any found, force it to be configurable. */
+    prop = find_prop_name_raw(This, string_hash(name), name);
+    if(prop) {
+        if(prop->type == PROP_PROXY)
+            prop->type = PROP_DELETED;
+        else {
+            prop->flags |= PROPF_CONFIGURABLE;
+            delete_prop(This, prop, &b);
+        }
+    }else if(!(prop = alloc_prop(This, name, PROP_DELETED, 0))) {
+        hres = E_OUTOFMEMORY;
+        goto end;
+    }
+
+    hres = jsval_copy(jsval_obj(ctor), &prop->u.val);
+    if(FAILED(hres))
+        goto end;
+    prop->type = PROP_JSVAL;
+    prop->flags = PROPF_WRITABLE | PROPF_CONFIGURABLE;
+
+end:
+    jsdisp_release(ctor);
+    return hres;
+}
+
+static void WINAPI WineDispatchProxyCbPrivate_Traverse(IWineDispatchProxyCbPrivate *iface,
+        void (STDMETHODCALLTYPE *note_cc_edge)(IDispatch*,void*), void *cb)
+{
+    jsdisp_t *This = impl_from_IWineDispatchProxyCbPrivate(iface);
+    dispex_prop_t *prop, *end = This->props + This->prop_cnt;
+
+    for(prop = This->props; prop < end; prop++) {
+        switch(prop->type) {
+        case PROP_JSVAL:
+            switch(jsval_type(prop->u.val)) {
+            case JSV_OBJECT:
+                note_cc_edge(get_object(prop->u.val), cb);
+                break;
+            case JSV_VARIANT:
+                if(V_VT(get_variant(prop->u.val)) == VT_DISPATCH)
+                    note_cc_edge(V_DISPATCH(get_variant(prop->u.val)), cb);
+                break;
+            default:
+                break;
+            }
+            break;
+        case PROP_ACCESSOR:
+            if(prop->u.accessor.getter)
+                note_cc_edge(to_disp(prop->u.accessor.getter), cb);
+            if(prop->u.accessor.setter)
+                note_cc_edge(to_disp(prop->u.accessor.setter), cb);
+            break;
+        default:
+            break;
+        }
+    }
+}
+
+static IWineDispatchProxyCbPrivateVtbl WineDispatchProxyCbPrivateVtbl = {
+    {
     DispatchEx_QueryInterface,
     DispatchEx_AddRef,
     DispatchEx_Release,
@@ -1794,26 +2557,41 @@ static IDispatchExVtbl DispatchExVtbl = {
     DispatchEx_GetMemberName,
     DispatchEx_GetNextDispID,
     DispatchEx_GetNameSpaceParent
+    },
+
+    /* IWineDispatchProxyCbPrivate extension */
+    WineDispatchProxyCbPrivate_Unlinked,
+    WineDispatchProxyCbPrivate_Relinked,
+    WineDispatchProxyCbPrivate_HostUpdated,
+    WineDispatchProxyCbPrivate_GetUnderlyingDispID,
+    WineDispatchProxyCbPrivate_CreateConstructor,
+    WineDispatchProxyCbPrivate_DefineConstructor,
+    WineDispatchProxyCbPrivate_GetRandomValues,
+    WineDispatchProxyCbPrivate_Traverse
 };
 
 jsdisp_t *as_jsdisp(IDispatch *disp)
 {
-    assert(disp->lpVtbl == (IDispatchVtbl*)&DispatchExVtbl);
+    assert(disp->lpVtbl == (IDispatchVtbl*)&WineDispatchProxyCbPrivateVtbl);
     return impl_from_IDispatchEx((IDispatchEx*)disp);
 }
 
 jsdisp_t *to_jsdisp(IDispatch *disp)
 {
-    return disp->lpVtbl == (IDispatchVtbl*)&DispatchExVtbl ? impl_from_IDispatchEx((IDispatchEx*)disp) : NULL;
+    return disp->lpVtbl == (IDispatchVtbl*)&WineDispatchProxyCbPrivateVtbl ? impl_from_IDispatchEx((IDispatchEx*)disp) : NULL;
 }
 
 HRESULT init_dispex(jsdisp_t *dispex, script_ctx_t *ctx, const builtin_info_t *builtin_info, jsdisp_t *prototype)
 {
     unsigned i;
 
+    /* FIXME: Use better heuristics to decide when to run the GC */
+    if(GetTickCount() - ctx->gc_last_tick > 30000)
+        gc_run(ctx);
+
     TRACE("%p (%p)\n", dispex, prototype);
 
-    dispex->IDispatchEx_iface.lpVtbl = &DispatchExVtbl;
+    dispex->IDispatchEx_iface.lpVtbl = (const IDispatchExVtbl*)&WineDispatchProxyCbPrivateVtbl;
     dispex->ref = 1;
     dispex->builtin_info = builtin_info;
     dispex->extensible = TRUE;
@@ -1835,6 +2613,7 @@ HRESULT init_dispex(jsdisp_t *dispex, script_ctx_t *ctx, const builtin_info_t *b
     script_addref(ctx);
     dispex->ctx = ctx;
 
+    list_add_tail(&ctx->objects, &dispex->entry);
     return S_OK;
 }
 
@@ -1865,10 +2644,99 @@ HRESULT create_dispex(script_ctx_t *ctx, const builtin_info_t *builtin_info, jsd
     return S_OK;
 }
 
+static const builtin_info_t proxy_dispex_info = {
+    JSCLASS_OBJECT,
+    NULL,
+    0, NULL,
+    NULL,
+    NULL
+};
+
+HRESULT convert_to_proxy(script_ctx_t *ctx, jsval_t *val)
+{
+    IWineDispatchProxyCbPrivate **proxy_ref;
+    IWineDispatchProxyPrivate *proxy;
+    jsdisp_t *jsdisp, *prot;
+    IDispatch *obj;
+    HRESULT hres;
+
+    if(ctx->version < SCRIPTLANGUAGEVERSION_ES5 || !val || !is_object_instance(*val))
+        return S_OK;
+    obj = get_object(*val);
+    if(to_jsdisp(obj))
+        return S_OK;
+
+    if(FAILED(IDispatch_QueryInterface(obj, &IID_IWineDispatchProxyPrivate, (void**)&proxy)) || !proxy)
+        return S_OK;
+    IDispatch_Release(obj);
+
+    proxy_ref = proxy->lpVtbl->GetProxyFieldRef(proxy);
+    if(*proxy_ref) {
+        /* Re-acquire the proxy if it's an old dangling proxy */
+        jsdisp = impl_from_IWineDispatchProxyCbPrivate(*proxy_ref);
+        if(!jsdisp->ref++)
+            list_add_tail(&ctx->objects, &jsdisp->entry);
+        else if(jsdisp->proxy)
+            IDispatchEx_Release((IDispatchEx*)jsdisp->proxy);
+        jsdisp->proxy = proxy;
+
+        TRACE("re-acquired %p\n", jsdisp);
+        *val = jsval_obj(jsdisp);
+        return S_OK;
+    }
+
+    hres = get_proxy_default_prototype(ctx, proxy, &prot);
+    if(FAILED(hres))
+        goto fail;
+
+    hres = create_dispex(ctx, &proxy_dispex_info, prot, &jsdisp);
+    if(prot)
+        jsdisp_release(prot);
+    if(FAILED(hres))
+        goto fail;
+
+    *proxy_ref = (IWineDispatchProxyCbPrivate*)&jsdisp->IDispatchEx_iface;
+    jsdisp->proxy = proxy;
+    if(proxy->lpVtbl->IsPrototype(proxy)) {
+        jsdisp_t *ctor;
+        hres = get_proxy_default_constructor(ctx, jsdisp, &ctor);
+        if(SUCCEEDED(hres)) {
+            hres = jsdisp_define_data_property(jsdisp, L"constructor", PROPF_WRITABLE | PROPF_CONFIGURABLE, jsval_obj(ctor));
+            jsdisp_release(ctor);
+        }
+    }else {
+        hres = maybe_init_global_proxy(jsdisp);
+    }
+    if(FAILED(hres)) {
+        *proxy_ref = NULL;
+        jsdisp->proxy = NULL;
+        jsdisp_release(jsdisp);
+        goto fail;
+    }
+
+    *val = jsval_obj(jsdisp);
+    return S_OK;
+
+fail:
+    IDispatchEx_Release((IDispatchEx*)proxy);
+    return hres;
+}
+
 void jsdisp_free(jsdisp_t *obj)
 {
     dispex_prop_t *prop;
 
+    list_remove(&obj->entry);
+
+    /* If it's a proxy, stay alive and keep it associated with the disp, since
+       we can be re-acquired at some later point. When the underlying disp is
+       actually destroyed, it should unlink us and then we free it for real. */
+    if(obj->proxy) {
+        list_init(&obj->entry);
+        IDispatchEx_Release((IDispatchEx*)obj->proxy);
+        return;
+    }
+
     TRACE("(%p)\n", obj);
 
     for(prop = obj->props; prop < obj->props+obj->prop_cnt; prop++) {
@@ -1898,12 +2766,21 @@ void jsdisp_free(jsdisp_t *obj)
         heap_free(obj);
 }
 
+void jsdisp_reacquire(jsdisp_t *jsdisp)
+{
+    list_add_tail(&jsdisp->ctx->objects, &jsdisp->entry);
+    if(jsdisp->proxy)
+        IDispatchEx_AddRef((IDispatchEx*)jsdisp->proxy);
+}
+
 #ifdef TRACE_REFCNT
 
 jsdisp_t *jsdisp_addref(jsdisp_t *jsdisp)
 {
     ULONG ref = ++jsdisp->ref;
     TRACE("(%p) ref=%d\n", jsdisp, ref);
+    if(ref == 1)
+        jsdisp_reacquire(jsdisp);
     return jsdisp;
 }
 
@@ -1952,7 +2829,7 @@ HRESULT init_dispex_from_constr(jsdisp_t *dispex, script_ctx_t *ctx, const built
 
 jsdisp_t *iface_to_jsdisp(IDispatch *iface)
 {
-    return iface->lpVtbl == (const IDispatchVtbl*)&DispatchExVtbl
+    return iface->lpVtbl == (const IDispatchVtbl*)&WineDispatchProxyCbPrivateVtbl
         ? jsdisp_addref( impl_from_IDispatchEx((IDispatchEx*)iface))
         : NULL;
 }
@@ -1960,9 +2837,17 @@ jsdisp_t *iface_to_jsdisp(IDispatch *iface)
 HRESULT jsdisp_get_id(jsdisp_t *jsdisp, const WCHAR *name, DWORD flags, DISPID *id)
 {
     dispex_prop_t *prop;
+    unsigned idx;
     HRESULT hres;
 
-    if(jsdisp->extensible && (flags & fdexNameEnsure))
+    if(override_idx(jsdisp, name, &idx)) {
+        if(idx >= jsdisp->builtin_info->idx_length(jsdisp)) {
+            *id = DISPID_UNKNOWN;
+            return DISP_E_UNKNOWNNAME;
+        }
+        hres = find_prop_name(jsdisp, string_hash(name), name, &prop);
+    }
+    else if(jsdisp->extensible && (flags & fdexNameEnsure))
         hres = ensure_prop_name(jsdisp, name, PROPF_ENUMERABLE | PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                 &prop);
     else
@@ -1988,6 +2873,10 @@ HRESULT jsdisp_call_value(jsdisp_t *jsfunc, IDispatch *jsthis, WORD flags, unsig
 
     if(is_class(jsfunc, JSCLASS_FUNCTION)) {
         hres = Function_invoke(jsfunc, jsthis, flags, argc, argv, r);
+    }else if(jsfunc->proxy) {
+        /* We have to distinguish default value of prototypes from a builtin with DISPID_VALUE */
+        DISPID id = jsfunc->proxy->lpVtbl->IsPrototype(jsfunc->proxy) ? DISPID_UNKNOWN : DISPID_VALUE;
+        hres = proxy_disp_call(jsfunc, jsthis, id, flags, argc, argv, r);
     }else {
         if(!jsfunc->builtin_info->call) {
             WARN("Not a function\n");
@@ -1997,6 +2886,8 @@ HRESULT jsdisp_call_value(jsdisp_t *jsfunc, IDispatch *jsthis, WORD flags, unsig
         flags &= ~DISPATCH_JSCRIPT_INTERNAL_MASK;
         hres = jsfunc->builtin_info->call(jsfunc->ctx, jsthis ? jsval_disp(jsthis) : jsval_null(), flags, argc, argv, r);
     }
+    if(SUCCEEDED(hres))
+        hres = convert_to_proxy(jsfunc->ctx, r);
     return hres;
 }
 
@@ -2056,22 +2947,28 @@ static HRESULT disp_invoke(script_ctx_t *ctx, IDispatch *disp, DISPID id, WORD f
         hres = IDispatch_Invoke(disp, id, &IID_NULL, ctx->lcid, flags, params, r, &ei, &err);
     }
 
-    if(hres == DISP_E_EXCEPTION) {
-        TRACE("DISP_E_EXCEPTION: %08lx %s %s\n", ei.scode, debugstr_w(ei.bstrSource), debugstr_w(ei.bstrDescription));
-        reset_ei(ctx->ei);
-        ctx->ei->error = (SUCCEEDED(ei.scode) || ei.scode == DISP_E_EXCEPTION) ? E_FAIL : ei.scode;
-        if(ei.bstrSource)
-            ctx->ei->source = jsstr_alloc_len(ei.bstrSource, SysStringLen(ei.bstrSource));
-        if(ei.bstrDescription)
-            ctx->ei->message = jsstr_alloc_len(ei.bstrDescription, SysStringLen(ei.bstrDescription));
-        SysFreeString(ei.bstrSource);
-        SysFreeString(ei.bstrDescription);
-        SysFreeString(ei.bstrHelpFile);
-    }
+    if(hres == DISP_E_EXCEPTION)
+        disp_fill_exception(ctx, &ei);
 
     return hres;
 }
 
+void disp_fill_exception(script_ctx_t *ctx, EXCEPINFO *ei)
+{
+    TRACE("DISP_E_EXCEPTION: %08lx %s %s\n", ei->scode, debugstr_w(ei->bstrSource), debugstr_w(ei->bstrDescription));
+    reset_ei(ctx->ei);
+    if(ei->pfnDeferredFillIn)
+        ei->pfnDeferredFillIn(ei);
+    ctx->ei->error = (SUCCEEDED(ei->scode) || ei->scode == DISP_E_EXCEPTION) ? E_FAIL : ei->scode;
+    if(ei->bstrSource)
+        ctx->ei->source = jsstr_alloc_len(ei->bstrSource, SysStringLen(ei->bstrSource));
+    if(ei->bstrDescription)
+        ctx->ei->message = jsstr_alloc_len(ei->bstrDescription, SysStringLen(ei->bstrDescription));
+    SysFreeString(ei->bstrSource);
+    SysFreeString(ei->bstrDescription);
+    SysFreeString(ei->bstrHelpFile);
+}
+
 HRESULT disp_call(script_ctx_t *ctx, IDispatch *disp, DISPID id, WORD flags, unsigned argc, jsval_t *argv, jsval_t *ret)
 {
     VARIANT buf[6], retv;
@@ -2244,8 +3141,12 @@ HRESULT disp_call_value(script_ctx_t *ctx, IDispatch *disp, IDispatch *jsthis, W
 HRESULT jsdisp_propput(jsdisp_t *obj, const WCHAR *name, DWORD flags, BOOL throw, jsval_t val)
 {
     dispex_prop_t *prop;
+    unsigned idx;
     HRESULT hres;
 
+    if(override_idx(obj, name, &idx))
+        return obj->builtin_info->idx_put(obj, idx, val);
+
     if(obj->extensible)
         hres = ensure_prop_name(obj, name, flags, &prop);
     else
@@ -2348,8 +3249,12 @@ HRESULT disp_propput_name(script_ctx_t *ctx, IDispatch *disp, const WCHAR *name,
 HRESULT jsdisp_propget_name(jsdisp_t *obj, const WCHAR *name, jsval_t *val)
 {
     dispex_prop_t *prop;
+    unsigned idx;
     HRESULT hres;
 
+    if(override_idx(obj, name, &idx))
+        return obj->builtin_info->idx_get(obj, idx, val);
+
     hres = find_prop_name_prot(obj, string_hash(name), name, &prop);
     if(FAILED(hres))
         return hres;
@@ -2368,6 +3273,9 @@ HRESULT jsdisp_get_idx(jsdisp_t *obj, DWORD idx, jsval_t *r)
     dispex_prop_t *prop;
     HRESULT hres;
 
+    if(obj->builtin_info->class >= FIRST_TYPEDARRAY_JSCLASS && obj->builtin_info->class <= LAST_TYPEDARRAY_JSCLASS)
+        return obj->builtin_info->idx_get(obj, idx, r);
+
     swprintf(name, ARRAY_SIZE(name), L"%d", idx);
 
     hres = find_prop_name_prot(obj, string_hash(name), name, &prop);
@@ -2425,13 +3333,16 @@ HRESULT jsdisp_delete_idx(jsdisp_t *obj, DWORD idx)
     BOOL b;
     HRESULT hres;
 
+    if(obj->builtin_info->class >= FIRST_TYPEDARRAY_JSCLASS && obj->builtin_info->class <= LAST_TYPEDARRAY_JSCLASS)
+        return S_OK;
+
     swprintf(buf, ARRAY_SIZE(buf), L"%d", idx);
 
     hres = find_prop_name(obj, string_hash(buf), buf, &prop);
     if(FAILED(hres) || !prop)
         return hres;
 
-    hres = delete_prop(prop, &b);
+    hres = delete_prop(obj, prop, &b);
     if(FAILED(hres))
         return hres;
     return b ? S_OK : JS_E_INVALID_ACTION;
@@ -2449,7 +3360,7 @@ HRESULT disp_delete(IDispatch *disp, DISPID id, BOOL *ret)
 
         prop = get_prop(jsdisp, id);
         if(prop)
-            hres = delete_prop(prop, ret);
+            hres = delete_prop(jsdisp, prop, ret);
         else
             hres = DISP_E_MEMBERNOTFOUND;
 
@@ -2527,6 +3438,7 @@ HRESULT disp_delete_name(script_ctx_t *ctx, IDispatch *disp, jsstr_t *name, BOOL
     if(jsdisp) {
         dispex_prop_t *prop;
         const WCHAR *ptr;
+        unsigned idx;
 
         ptr = jsstr_flatten(name);
         if(!ptr) {
@@ -2534,12 +3446,17 @@ HRESULT disp_delete_name(script_ctx_t *ctx, IDispatch *disp, jsstr_t *name, BOOL
             return E_OUTOFMEMORY;
         }
 
-        hres = find_prop_name(jsdisp, string_hash(ptr), ptr, &prop);
-        if(prop) {
-            hres = delete_prop(prop, ret);
-        }else {
-            *ret = TRUE;
+        if(override_idx(jsdisp, ptr, &idx)) {
+            *ret = FALSE;
             hres = S_OK;
+        }else {
+            hres = find_prop_name(jsdisp, string_hash(ptr), ptr, &prop);
+            if(prop) {
+                hres = delete_prop(jsdisp, prop, ret);
+            }else {
+                *ret = TRUE;
+                hres = S_OK;
+            }
         }
 
         jsdisp_release(jsdisp);
@@ -2579,8 +3496,25 @@ HRESULT jsdisp_get_own_property(jsdisp_t *obj, const WCHAR *name, BOOL flags_onl
                                 property_desc_t *desc)
 {
     dispex_prop_t *prop;
+    unsigned idx;
     HRESULT hres;
 
+    if(override_idx(obj, name, &idx)) {
+        if(idx >= obj->builtin_info->idx_length(obj))
+            return DISP_E_UNKNOWNNAME;
+
+        memset(desc, 0, sizeof(*desc));
+        if(!flags_only) {
+            hres = obj->builtin_info->idx_get(obj, idx, &desc->value);
+            if(FAILED(hres))
+                return hres;
+        }
+        desc->flags = PROPF_ENUMERABLE | PROPF_WRITABLE;
+        desc->mask  = PROPF_ENUMERABLE | PROPF_WRITABLE | PROPF_CONFIGURABLE;
+        desc->explicit_value = TRUE;
+        return S_OK;
+    }
+
     hres = find_prop_name(obj, string_hash(name), name, &prop);
     if(FAILED(hres))
         return hres;
@@ -2594,6 +3528,19 @@ HRESULT jsdisp_get_own_property(jsdisp_t *obj, const WCHAR *name, BOOL flags_onl
     case PROP_BUILTIN:
     case PROP_JSVAL:
     case PROP_IDX:
+    case PROP_PROXY:
+        if(is_accessor_prop(prop)) {
+            desc->explicit_getter = desc->explicit_setter = TRUE;
+            if(!flags_only) {
+                hres = create_proxy_accessor(obj, prop->u.proxy.id, desc);
+                if(FAILED(hres))
+                    return hres;
+                prop->type = PROP_ACCESSOR;
+                prop->u.accessor.getter = desc->getter ? jsdisp_addref(desc->getter) : NULL;
+                prop->u.accessor.setter = desc->setter ? jsdisp_addref(desc->setter) : NULL;
+            }
+            break;
+        }
         desc->mask |= PROPF_WRITABLE;
         desc->explicit_value = TRUE;
         if(!flags_only) {
@@ -2623,8 +3570,19 @@ HRESULT jsdisp_get_own_property(jsdisp_t *obj, const WCHAR *name, BOOL flags_onl
 HRESULT jsdisp_define_property(jsdisp_t *obj, const WCHAR *name, property_desc_t *desc)
 {
     dispex_prop_t *prop;
+    unsigned idx;
     HRESULT hres;
 
+    if(override_idx(obj, name, &idx)) {
+        if((desc->flags & desc->mask) != (desc->mask & (PROPF_WRITABLE | PROPF_ENUMERABLE)))
+            return throw_error(obj->ctx, JS_E_NONCONFIGURABLE_REDEFINED, name);
+        if(desc->explicit_value)
+            return obj->builtin_info->idx_put(obj, idx, desc->value);
+        if(desc->explicit_getter || desc->explicit_setter)
+            return throw_error(obj->ctx, JS_E_NONCONFIGURABLE_REDEFINED, name);
+        return obj->builtin_info->idx_put(obj, idx, jsval_undefined());
+    }
+
     hres = find_prop_name(obj, string_hash(name), name, &prop);
     if(FAILED(hres))
         return hres;
@@ -2668,13 +3626,15 @@ HRESULT jsdisp_define_property(jsdisp_t *obj, const WCHAR *name, property_desc_t
     }
 
     if(desc->explicit_value || (desc->mask & PROPF_WRITABLE)) {
-        if(prop->type == PROP_ACCESSOR) {
+        if(is_accessor_prop(prop)) {
             if(!(prop->flags & PROPF_CONFIGURABLE))
                 return throw_error(obj->ctx, JS_E_NONCONFIGURABLE_REDEFINED, name);
-            if(prop->u.accessor.getter)
-                jsdisp_release(prop->u.accessor.getter);
-            if(prop->u.accessor.setter)
-                jsdisp_release(prop->u.accessor.setter);
+            if(prop->type == PROP_ACCESSOR) {
+                if(prop->u.accessor.getter)
+                    jsdisp_release(prop->u.accessor.getter);
+                if(prop->u.accessor.setter)
+                    jsdisp_release(prop->u.accessor.setter);
+            }
 
             prop->type = PROP_JSVAL;
             hres = jsval_copy(desc->value, &prop->u.val);
@@ -2712,18 +3672,21 @@ HRESULT jsdisp_define_property(jsdisp_t *obj, const WCHAR *name, property_desc_t
             }
         }
     }else if(desc->explicit_getter || desc->explicit_setter) {
-        if(prop->type != PROP_ACCESSOR) {
+        if(!is_accessor_prop(prop)) {
             if(!(prop->flags & PROPF_CONFIGURABLE))
                 return throw_error(obj->ctx, JS_E_NONCONFIGURABLE_REDEFINED, name);
             if(prop->type == PROP_JSVAL)
                 jsval_release(prop->u.val);
-            prop->type = PROP_ACCESSOR;
-            prop->u.accessor.getter = prop->u.accessor.setter = NULL;
         }else if(!(prop->flags & PROPF_CONFIGURABLE)) {
-            if((desc->explicit_getter && desc->getter != prop->u.accessor.getter)
+            if(prop->type != PROP_ACCESSOR
+               || (desc->explicit_getter && desc->getter != prop->u.accessor.getter)
                || (desc->explicit_setter && desc->setter != prop->u.accessor.setter))
                 return throw_error(obj->ctx, JS_E_NONCONFIGURABLE_REDEFINED, name);
         }
+        if(prop->type != PROP_ACCESSOR) {
+            prop->type = PROP_ACCESSOR;
+            prop->u.accessor.getter = prop->u.accessor.setter = NULL;
+        }
 
         if(desc->explicit_getter) {
             if(prop->u.accessor.getter) {
@@ -2802,11 +3765,12 @@ BOOL jsdisp_is_frozen(jsdisp_t *obj, BOOL sealed)
         return FALSE;
 
     for(i = 0; i < obj->prop_cnt; i++) {
-        if(obj->props[i].type == PROP_JSVAL) {
+        if(!is_accessor_prop(&obj->props[i])) {
+            if(obj->props[i].type != PROP_JSVAL && obj->props[i].type != PROP_PROXY)
+                continue;
             if(!sealed && (obj->props[i].flags & PROPF_WRITABLE))
                 return FALSE;
-        }else if(obj->props[i].type != PROP_ACCESSOR)
-            continue;
+        }
         if(obj->props[i].flags & PROPF_CONFIGURABLE)
             return FALSE;
     }
diff --git a/dlls/jscript/engine.c b/dlls/jscript/engine.c
index 7dce4fe5d79..4900634a808 100644
--- a/dlls/jscript/engine.c
+++ b/dlls/jscript/engine.c
@@ -507,15 +507,24 @@ static HRESULT disp_cmp(IDispatch *disp1, IDispatch *disp2, BOOL *ret)
 {
     IObjectIdentity *identity;
     IUnknown *unk1, *unk2;
+    jsdisp_t *jsdisp;
     HRESULT hres;
 
-    if(disp1 == disp2) {
-        *ret = TRUE;
+    if(!disp1 || !disp2) {
+        *ret = (disp1 == disp2);
         return S_OK;
     }
 
-    if(!disp1 || !disp2) {
-        *ret = FALSE;
+    jsdisp = to_jsdisp(disp1);
+    if(jsdisp && jsdisp->proxy)
+        disp1 = (IDispatch*)jsdisp->proxy;
+
+    jsdisp = to_jsdisp(disp2);
+    if(jsdisp && jsdisp->proxy)
+        disp2 = (IDispatch*)jsdisp->proxy;
+
+    if(disp1 == disp2) {
+        *ret = TRUE;
         return S_OK;
     }
 
@@ -666,7 +675,7 @@ static BOOL lookup_global_members(script_ctx_t *ctx, BSTR identifier, exprval_t
     HRESULT hres;
 
     LIST_FOR_EACH_ENTRY(item, &ctx->named_items, named_item_t, entry) {
-        if(item->flags & SCRIPTITEM_GLOBALMEMBERS) {
+        if((item->flags & SCRIPTITEM_GLOBALMEMBERS) && item->disp != (IDispatch*)&ctx->global->IDispatchEx_iface) {
             hres = disp_get_id(ctx, item->disp, identifier, identifier, 0, &id);
             if(SUCCEEDED(hres)) {
                 if(ret)
@@ -1832,7 +1841,7 @@ static HRESULT interp_instanceof(script_ctx_t *ctx)
         return E_FAIL;
     }
 
-    if(is_class(obj, JSCLASS_FUNCTION)) {
+    if(is_class(obj, JSCLASS_FUNCTION) || (obj->proxy && obj->proxy->lpVtbl->IsConstructor(obj->proxy))) {
         hres = jsdisp_propget_name(obj, L"prototype", &prot);
     }else {
         hres = JS_E_FUNCTION_EXPECTED;
diff --git a/dlls/jscript/enumerator.c b/dlls/jscript/enumerator.c
index f82263eaf26..56c5ffbd0bb 100644
--- a/dlls/jscript/enumerator.c
+++ b/dlls/jscript/enumerator.c
@@ -88,6 +88,11 @@ static void Enumerator_destructor(jsdisp_t *dispex)
     heap_free(dispex);
 }
 
+static HRESULT Enumerator_gc_traverse(jsdisp_t *dispex, void *arg)
+{
+    return gc_process_linked_val(dispex, &enumerator_from_jsdisp(dispex)->item, arg);
+}
+
 static HRESULT Enumerator_atEnd(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv,
         jsval_t *r)
 {
@@ -189,7 +194,11 @@ static const builtin_info_t EnumeratorInst_info = {
     0,
     NULL,
     Enumerator_destructor,
-    NULL
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    Enumerator_gc_traverse
 };
 
 static HRESULT alloc_enumerator(script_ctx_t *ctx, jsdisp_t *object_prototype, EnumeratorInstance **ret)
@@ -240,11 +249,11 @@ static HRESULT create_enumerator(script_ctx_t *ctx, jsval_t *argv, jsdisp_t **re
         /* Try to get a IEnumVARIANT by _NewEnum */
         VariantInit(&varresult);
         hres = IDispatch_Invoke(obj, DISPID_NEWENUM, &IID_NULL, LOCALE_NEUTRAL,
-                DISPATCH_METHOD, &dispparams, &varresult, NULL, NULL);
+                DISPATCH_PROPERTYGET, &dispparams, &varresult, NULL, NULL);
         if (FAILED(hres))
         {
             WARN("Enumerator: no DISPID_NEWENUM.\n");
-            return E_INVALIDARG;
+            return JS_E_OBJECT_NOT_COLLECTION;
         }
 
         if ((V_VT(&varresult) == VT_DISPATCH) || (V_VT(&varresult) == VT_UNKNOWN))
@@ -255,7 +264,7 @@ static HRESULT create_enumerator(script_ctx_t *ctx, jsval_t *argv, jsdisp_t **re
         else
         {
             FIXME("Enumerator: NewEnum unexpected type of varresult (%d).\n", V_VT(&varresult));
-            hres = E_INVALIDARG;
+            hres = JS_E_OBJECT_NOT_COLLECTION;
         }
         VariantClear(&varresult);
         if (FAILED(hres))
diff --git a/dlls/jscript/error.c b/dlls/jscript/error.c
index d309d4207d3..6883e897c77 100644
--- a/dlls/jscript/error.c
+++ b/dlls/jscript/error.c
@@ -465,7 +465,9 @@ jsdisp_t *create_builtin_error(script_ctx_t *ctx)
         case JS_E_INVALID_PROPERTY:
         case JS_E_INVALID_ACTION:
         case JS_E_MISSING_ARG:
+        case JS_E_OBJECT_NOT_COLLECTION:
         case JS_E_FUNCTION_EXPECTED:
+        case JS_E_STRING_EXPECTED:
         case JS_E_DATE_EXPECTED:
         case JS_E_NUMBER_EXPECTED:
         case JS_E_OBJECT_EXPECTED:
@@ -476,12 +478,19 @@ jsdisp_t *create_builtin_error(script_ctx_t *ctx)
         case JS_E_JSCRIPT_EXPECTED:
         case JS_E_ENUMERATOR_EXPECTED:
         case JS_E_REGEXP_EXPECTED:
+        case JS_E_ARRAY_OR_ARGS_EXPECTED:
         case JS_E_ARRAY_EXPECTED:
         case JS_E_CYCLIC_PROTO_VALUE:
         case JS_E_CANNOT_CREATE_FOR_NONEXTENSIBLE:
         case JS_E_OBJECT_NONEXTENSIBLE:
         case JS_E_NONCONFIGURABLE_REDEFINED:
         case JS_E_NONWRITABLE_MODIFIED:
+        case JS_E_TYPEDARRAY_BAD_CTOR_ARG:
+        case JS_E_NOT_TYPEDARRAY:
+        case JS_E_TYPEDARRAY_INVALID_SOURCE:
+        case JS_E_NOT_DATAVIEW:
+        case JS_E_DATAVIEW_NO_ARGUMENT:
+        case JS_E_ARRAYBUFFER_EXPECTED:
         case JS_E_PROP_DESC_MISMATCH:
         case JS_E_INVALID_WRITABLE_PROP_DESC:
             constr = ctx->type_error_constr;
@@ -491,6 +500,10 @@ jsdisp_t *create_builtin_error(script_ctx_t *ctx)
         case JS_E_FRACTION_DIGITS_OUT_OF_RANGE:
         case JS_E_PRECISION_OUT_OF_RANGE:
         case JS_E_INVALID_LENGTH:
+        case JS_E_TYPEDARRAY_INVALID_OFFSLEN:
+        case JS_E_TYPEDARRAY_INVALID_SUBARRAY:
+        case JS_E_DATAVIEW_INVALID_ACCESS:
+        case JS_E_DATAVIEW_INVALID_OFFSET:
             constr = ctx->range_error_constr;
             break;
 
diff --git a/dlls/jscript/function.c b/dlls/jscript/function.c
index 638d176cf2c..f5a81519cda 100644
--- a/dlls/jscript/function.c
+++ b/dlls/jscript/function.c
@@ -17,6 +17,7 @@
  */
 
 #include <assert.h>
+#include <mshtmdid.h>
 
 #include "jscript.h"
 #include "engine.h"
@@ -39,6 +40,7 @@ struct _function_vtbl_t {
     HRESULT (*toString)(FunctionInstance*,jsstr_t**);
     function_code_t* (*get_code)(FunctionInstance*);
     void (*destructor)(FunctionInstance*);
+    HRESULT (*gc_traverse)(FunctionInstance*,void*);
 };
 
 typedef struct {
@@ -54,6 +56,17 @@ typedef struct {
     const WCHAR *name;
 } NativeFunction;
 
+typedef struct {
+    FunctionInstance function;
+    struct proxy_func_invoker func;
+} ProxyFunction;
+
+typedef struct {
+    FunctionInstance function;
+    IDispatch *disp;
+    const WCHAR *name;
+} ProxyConstructor;
+
 typedef struct {
     FunctionInstance function;
     FunctionInstance *target;
@@ -70,8 +83,15 @@ typedef struct {
     unsigned argc;
 } ArgumentsInstance;
 
+static const WCHAR ProxyConstructor_createW[] = L"create";
+
 static HRESULT create_bind_function(script_ctx_t*,FunctionInstance*,IDispatch*,unsigned,jsval_t*,jsdisp_t**r);
 
+static HRESULT no_gc_traverse(FunctionInstance *function, void *arg)
+{
+    return S_OK;
+}
+
 static inline FunctionInstance *function_from_jsdisp(jsdisp_t *jsdisp)
 {
     return CONTAINING_RECORD(jsdisp, FunctionInstance, dispex);
@@ -108,7 +128,8 @@ static void Arguments_destructor(jsdisp_t *jsdisp)
         heap_free(arguments->buf);
     }
 
-    jsdisp_release(&arguments->function->function.dispex);
+    if(arguments->function)
+        jsdisp_release(&arguments->function->function.dispex);
     heap_free(arguments);
 }
 
@@ -166,6 +187,23 @@ static HRESULT Arguments_idx_put(jsdisp_t *jsdisp, unsigned idx, jsval_t val)
                                arguments->function->func_code->params[idx], val);
 }
 
+static HRESULT Arguments_gc_traverse(jsdisp_t *jsdisp, void *arg)
+{
+    ArgumentsInstance *arguments = arguments_from_jsdisp(jsdisp);
+    HRESULT hres;
+    unsigned i;
+
+    if(arguments->buf) {
+        for(i = 0; i < arguments->argc; i++) {
+            hres = gc_process_linked_val(jsdisp, &arguments->buf[i], arg);
+            if(FAILED(hres))
+                return hres;
+        }
+    }
+
+    return gc_process_linked_obj(jsdisp, &arguments->function->function.dispex, (void**)&arguments->function, arg);
+}
+
 static const builtin_info_t Arguments_info = {
     JSCLASS_ARGUMENTS,
     Arguments_value,
@@ -174,7 +212,8 @@ static const builtin_info_t Arguments_info = {
     NULL,
     Arguments_idx_length,
     Arguments_idx_get,
-    Arguments_idx_put
+    Arguments_idx_put,
+    Arguments_gc_traverse
 };
 
 HRESULT setup_arguments_object(script_ctx_t *ctx, call_frame_t *frame)
@@ -331,6 +370,109 @@ static HRESULT array_to_args(script_ctx_t *ctx, jsdisp_t *arg_array, unsigned *a
     return S_OK;
 }
 
+static HRESULT disp_to_args(script_ctx_t *ctx, IDispatch *disp, unsigned *argc, jsval_t **ret)
+{
+    IDispatchEx *dispex;
+    DWORD length, i;
+    jsval_t *argv;
+    DISPID dispid;
+    EXCEPINFO ei;
+    UINT err = 0;
+    HRESULT hres;
+    VARIANT var;
+    BSTR name;
+
+    if(!(name = SysAllocString(L"length")))
+        return E_OUTOFMEMORY;
+    hres = IDispatch_QueryInterface(disp, &IID_IDispatchEx, (void**)&dispex);
+    if(SUCCEEDED(hres) && dispex)
+        hres = IDispatchEx_GetDispID(dispex, name, fdexNameCaseSensitive, &dispid);
+    else {
+        hres = IDispatch_GetIDsOfNames(disp, &IID_NULL, &name, 1, 0, &dispid);
+        dispex = NULL;
+    }
+    SysFreeString(name);
+    if(SUCCEEDED(hres) && dispid == DISPID_UNKNOWN)
+        hres = DISP_E_UNKNOWNNAME;
+    if(FAILED(hres)) {
+        if(hres == DISP_E_UNKNOWNNAME)
+            hres = JS_E_ARRAY_OR_ARGS_EXPECTED;
+        goto fail;
+    }
+
+    if(dispex)
+        hres = IDispatchEx_InvokeEx(dispex, dispid, ctx->lcid, DISPATCH_PROPERTYGET, NULL,
+                                    &var, &ei, &ctx->jscaller->IServiceProvider_iface);
+    else
+        hres = IDispatch_Invoke(disp, dispid, &IID_NULL, ctx->lcid, DISPATCH_PROPERTYGET, NULL, &var, &ei, &err);
+    if(FAILED(hres)) {
+        if(hres == DISP_E_EXCEPTION)
+            disp_fill_exception(ctx, &ei);
+        if(hres == DISP_E_MEMBERNOTFOUND)
+            hres = JS_E_ARRAY_OR_ARGS_EXPECTED;
+        goto fail;
+    }
+
+    if(FAILED(VariantChangeType(&var, &var, 0, VT_UI4))) {
+        VariantClear(&var);
+        hres = JS_E_ARRAY_OR_ARGS_EXPECTED;
+        goto fail;
+    }
+    length = V_UI4(&var);
+
+    argv = heap_alloc(length * sizeof(*argv));
+    if(!argv) {
+        hres = E_OUTOFMEMORY;
+        goto fail;
+    }
+
+    for(i = 0; i < length; i++) {
+        WCHAR buf[12];
+
+        swprintf(buf, ARRAY_SIZE(buf), L"%u", i);
+        if(!(name = SysAllocString(buf)))
+            hres = E_OUTOFMEMORY;
+        else {
+            if(dispex)
+                hres = IDispatchEx_GetDispID(dispex, name, fdexNameCaseSensitive, &dispid);
+            else
+                hres = IDispatch_GetIDsOfNames(disp, &IID_NULL, &name, 1, 0, &dispid);
+            SysFreeString(name);
+        }
+        if(SUCCEEDED(hres)) {
+            if(dispex)
+                hres = IDispatchEx_InvokeEx(dispex, dispid, ctx->lcid, DISPATCH_PROPERTYGET, NULL,
+                                            &var, &ei, &ctx->jscaller->IServiceProvider_iface);
+            else
+                hres = IDispatch_Invoke(disp, dispid, &IID_NULL, ctx->lcid, DISPATCH_PROPERTYGET, NULL, &var, &ei, &err);
+            if(SUCCEEDED(hres)) {
+                hres = variant_to_jsval(ctx, &var, &argv[i]);
+                VariantClear(&var);
+            }else if(hres == DISP_E_EXCEPTION) {
+                disp_fill_exception(ctx, &ei);
+            }
+        }
+        if(FAILED(hres)) {
+            if(hres == DISP_E_UNKNOWNNAME || hres == DISP_E_MEMBERNOTFOUND) {
+                argv[i] = jsval_undefined();
+                continue;
+            }
+            while(i--)
+                jsval_release(argv[i]);
+            heap_free(argv);
+            goto fail;
+        }
+    }
+
+    *argc = length;
+    *ret = argv;
+    hres = S_OK;
+fail:
+    if(dispex)
+        IDispatchEx_Release(dispex);
+    return hres;
+}
+
 static HRESULT Function_apply(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv, jsval_t *r)
 {
     jsval_t this_val = jsval_undefined();
@@ -362,22 +504,31 @@ static HRESULT Function_apply(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsi
 
     if(argc >= 2) {
         jsdisp_t *arg_array = NULL;
+        IDispatch *obj = NULL;
 
         if(is_object_instance(argv[1])) {
-            arg_array = iface_to_jsdisp(get_object(argv[1]));
-            if(arg_array &&
-               (!is_class(arg_array, JSCLASS_ARRAY) && !is_class(arg_array, JSCLASS_ARGUMENTS) )) {
-                jsdisp_release(arg_array);
-                arg_array = NULL;
+            obj = get_object(argv[1]);
+            arg_array = iface_to_jsdisp(obj);
+
+            if(ctx->version < SCRIPTLANGUAGEVERSION_ES5) {
+                if(!arg_array) {
+                    if(!ctx->html_mode)
+                        obj = NULL;
+                }else if(!is_class(arg_array, JSCLASS_ARRAY) && !is_class(arg_array, JSCLASS_ARGUMENTS)) {
+                    jsdisp_release(arg_array);
+                    arg_array = NULL;
+                    obj = NULL;
+                }
             }
         }
 
         if(arg_array) {
             hres = array_to_args(ctx, arg_array, &cnt, &args);
             jsdisp_release(arg_array);
+        }else if(obj) {
+            hres = disp_to_args(ctx, obj, &cnt, &args);
         }else {
-            FIXME("throw TypeError\n");
-            hres = E_FAIL;
+            hres = ctx->html_mode ? JS_E_ARRAY_OR_ARGS_EXPECTED : JS_E_JSCRIPT_EXPECTED;
         }
     }
 
@@ -548,6 +699,12 @@ static void Function_destructor(jsdisp_t *dispex)
     heap_free(function);
 }
 
+static HRESULT Function_gc_traverse(jsdisp_t *dispex, void *arg)
+{
+    FunctionInstance *function = function_from_jsdisp(dispex);
+    return function->vtbl->gc_traverse(function, arg);
+}
+
 static const builtin_prop_t Function_props[] = {
     {L"apply",               Function_apply,                 PROPF_METHOD|2},
     {L"arguments",           NULL, 0,                        Function_get_arguments},
@@ -563,7 +720,11 @@ static const builtin_info_t Function_info = {
     ARRAY_SIZE(Function_props),
     Function_props,
     Function_destructor,
-    NULL
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    Function_gc_traverse
 };
 
 static const builtin_prop_t FunctionInst_props[] = {
@@ -577,7 +738,11 @@ static const builtin_info_t FunctionInst_info = {
     ARRAY_SIZE(FunctionInst_props),
     FunctionInst_props,
     Function_destructor,
-    NULL
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    Function_gc_traverse
 };
 
 static HRESULT create_function(script_ctx_t *ctx, const builtin_info_t *builtin_info, const function_vtbl_t *vtbl, size_t size,
@@ -617,9 +782,8 @@ static HRESULT NativeFunction_call(script_ctx_t *ctx, FunctionInstance *func, js
     return function->proc(ctx, vthis, flags & ~DISPATCH_JSCRIPT_INTERNAL_MASK, argc, argv, r);
 }
 
-static HRESULT NativeFunction_toString(FunctionInstance *func, jsstr_t **ret)
+static HRESULT native_code_toString(const WCHAR *name, jsstr_t **ret)
 {
-    NativeFunction *function = (NativeFunction*)func;
     DWORD name_len;
     jsstr_t *str;
     WCHAR *ptr;
@@ -627,14 +791,14 @@ static HRESULT NativeFunction_toString(FunctionInstance *func, jsstr_t **ret)
     static const WCHAR native_prefixW[] = L"\nfunction ";
     static const WCHAR native_suffixW[] = L"() {\n    [native code]\n}\n";
 
-    name_len = function->name ? lstrlenW(function->name) : 0;
+    name_len = name ? lstrlenW(name) : 0;
     str = jsstr_alloc_buf(ARRAY_SIZE(native_prefixW) + ARRAY_SIZE(native_suffixW) + name_len - 2, &ptr);
     if(!str)
         return E_OUTOFMEMORY;
 
     memcpy(ptr, native_prefixW, sizeof(native_prefixW));
     ptr += ARRAY_SIZE(native_prefixW) - 1;
-    memcpy(ptr, function->name, name_len*sizeof(WCHAR));
+    memcpy(ptr, name, name_len*sizeof(WCHAR));
     ptr += name_len;
     memcpy(ptr, native_suffixW, sizeof(native_suffixW));
 
@@ -642,6 +806,12 @@ static HRESULT NativeFunction_toString(FunctionInstance *func, jsstr_t **ret)
     return S_OK;
 }
 
+static HRESULT NativeFunction_toString(FunctionInstance *func, jsstr_t **ret)
+{
+    NativeFunction *function = (NativeFunction*)func;
+    return native_code_toString(function->name, ret);
+}
+
 static function_code_t *NativeFunction_get_code(FunctionInstance *function)
 {
     return NULL;
@@ -655,7 +825,8 @@ static const function_vtbl_t NativeFunctionVtbl = {
     NativeFunction_call,
     NativeFunction_toString,
     NativeFunction_get_code,
-    NativeFunction_destructor
+    NativeFunction_destructor,
+    no_gc_traverse
 };
 
 HRESULT create_builtin_function(script_ctx_t *ctx, builtin_invoke_t value_proc, const WCHAR *name,
@@ -711,6 +882,305 @@ HRESULT create_builtin_constructor(script_ctx_t *ctx, builtin_invoke_t value_pro
     return S_OK;
 }
 
+static HRESULT ProxyFunction_call(script_ctx_t *ctx, FunctionInstance *func, jsval_t vthis, unsigned flags,
+        unsigned argc, jsval_t *argv, jsval_t *r)
+{
+    ProxyFunction *function = (ProxyFunction*)func;
+    IDispatch *this_obj, *converted = NULL;
+    DISPPARAMS dp = { 0 };
+    EXCEPINFO ei = { 0 };
+    VARIANT buf[6], ret;
+    jsdisp_t *jsdisp;
+    HRESULT hres;
+    unsigned i;
+
+    if(flags & DISPATCH_CONSTRUCT)
+        return E_UNEXPECTED;
+
+    if(argc > function->function.length)
+        argc = function->function.length;
+    dp.cArgs = argc;
+
+    if(argc <= ARRAY_SIZE(buf))
+        dp.rgvarg = buf;
+    else if(!(dp.rgvarg = heap_alloc(argc * sizeof(*dp.rgvarg))))
+        return E_OUTOFMEMORY;
+
+    for(i = 0; i < argc; i++) {
+        hres = jsval_to_variant(argv[i], &dp.rgvarg[argc - i - 1]);
+        if(FAILED(hres))
+            goto cleanup;
+    }
+
+    if(is_undefined(vthis) || is_null(vthis))
+        this_obj = lookup_global_host(ctx);
+    else {
+        hres = to_object(ctx, vthis, &converted);
+        if(FAILED(hres))
+            goto cleanup;
+        this_obj = converted;
+    }
+
+    jsdisp = to_jsdisp(this_obj);
+    if(jsdisp && jsdisp->proxy)
+        this_obj = (IDispatch*)jsdisp->proxy;
+
+    V_VT(&ret) = VT_EMPTY;
+    hres = function->func.invoke(this_obj, function->func.context, &dp, r ? &ret : NULL, &ei, &ctx->jscaller->IServiceProvider_iface);
+    if(converted)
+        IDispatch_Release(converted);
+
+    if(hres == DISP_E_EXCEPTION)
+        disp_fill_exception(ctx, &ei);
+    else if(SUCCEEDED(hres) && r) {
+        hres = variant_to_jsval(ctx, &ret, r);
+        VariantClear(&ret);
+    }
+
+cleanup:
+    while(i)
+        VariantClear(&dp.rgvarg[argc - i--]);
+    if(dp.rgvarg != buf)
+        heap_free(dp.rgvarg);
+    return hres;
+}
+
+static HRESULT ProxyFunction_toString(FunctionInstance *func, jsstr_t **ret)
+{
+    ProxyFunction *function = (ProxyFunction*)func;
+    return native_code_toString(function->func.name, ret);
+}
+
+static function_code_t *ProxyFunction_get_code(FunctionInstance *func)
+{
+    return NULL;
+}
+
+static void ProxyFunction_destructor(FunctionInstance *func)
+{
+}
+
+static const function_vtbl_t ProxyFunctionVtbl = {
+    ProxyFunction_call,
+    ProxyFunction_toString,
+    ProxyFunction_get_code,
+    ProxyFunction_destructor,
+    no_gc_traverse
+};
+
+HRESULT create_proxy_function(jsdisp_t *jsdisp, DISPID id, DWORD flags, jsdisp_t **ret)
+{
+    struct proxy_func_invoker func;
+    ProxyFunction *function;
+    HRESULT hres;
+
+    hres = jsdisp->proxy->lpVtbl->FuncInfo(jsdisp->proxy, id, &func);
+    if(FAILED(hres))
+        return hres;
+
+    hres = create_function(jsdisp->ctx, NULL, &ProxyFunctionVtbl, sizeof(ProxyFunction), flags, FALSE, NULL, (void**)&function);
+    if(FAILED(hres))
+        return hres;
+
+    function->func = func;
+    *ret = &function->function.dispex;
+    return S_OK;
+}
+
+HRESULT create_proxy_accessor(jsdisp_t *jsdisp, DISPID id, property_desc_t *desc)
+{
+    struct proxy_func_invoker func[2];
+    ProxyFunction *function;
+    HRESULT hres;
+
+    hres = jsdisp->proxy->lpVtbl->AccessorInfo(jsdisp->proxy, id, &func[0]);
+    if(FAILED(hres))
+        return hres;
+    desc->getter = desc->setter = NULL;
+
+    if(func[0].invoke) {
+        hres = create_function(jsdisp->ctx, NULL, &ProxyFunctionVtbl, sizeof(ProxyFunction), PROPF_METHOD, FALSE, NULL, (void**)&function);
+        if(FAILED(hres))
+            return hres;
+        function->func = func[0];
+        desc->getter = &function->function.dispex;
+    }
+
+    if(func[1].invoke) {
+        hres = create_function(jsdisp->ctx, NULL, &ProxyFunctionVtbl, sizeof(ProxyFunction), PROPF_METHOD|1, FALSE, NULL, (void**)&function);
+        if(FAILED(hres)) {
+            if(desc->getter)
+                jsdisp_release(desc->getter);
+            return hres;
+        }
+        function->func = func[1];
+        desc->setter = &function->function.dispex;
+    }
+
+    return S_OK;
+}
+
+static HRESULT ProxyConstructor_call(script_ctx_t *ctx, FunctionInstance *func, jsval_t vthis, unsigned flags,
+        unsigned argc, jsval_t *argv, jsval_t *r)
+{
+    ProxyConstructor *constructor = (ProxyConstructor*)func;
+
+    if(constructor->name == ProxyConstructor_createW) {
+        /* only allow calls since it's a method */
+        if(!(flags & DISPATCH_METHOD))
+            return E_UNEXPECTED;
+    }
+
+    return disp_call_value(ctx, constructor->disp, NULL, flags & ~DISPATCH_JSCRIPT_INTERNAL_MASK, argc, argv, r);
+}
+
+static HRESULT ProxyConstructor_toString(FunctionInstance *func, jsstr_t **ret)
+{
+    ProxyConstructor *constructor = (ProxyConstructor*)func;
+    return native_code_toString(constructor->name, ret);
+}
+
+static function_code_t *ProxyConstructor_get_code(FunctionInstance *func)
+{
+    return NULL;
+}
+
+static void ProxyConstructor_destructor(FunctionInstance *func)
+{
+    ProxyConstructor *constructor = (ProxyConstructor*)func;
+    IDispatch_Release(constructor->disp);
+}
+
+static const function_vtbl_t ProxyConstructorVtbl = {
+    ProxyConstructor_call,
+    ProxyConstructor_toString,
+    ProxyConstructor_get_code,
+    ProxyConstructor_destructor,
+    no_gc_traverse
+};
+
+static const builtin_prop_t ProxyConstructor_props[] = {
+    {L"arguments",           NULL, 0,                        Function_get_arguments}
+};
+
+static const builtin_info_t ProxyConstructor_info = {
+    JSCLASS_FUNCTION,
+    Function_value,
+    ARRAY_SIZE(ProxyConstructor_props),
+    ProxyConstructor_props,
+    Function_destructor,
+    NULL
+};
+
+HRESULT create_proxy_constructor(DISPID id, const WCHAR *name, jsdisp_t *prototype, jsdisp_t **ret)
+{
+    IWineDispatchProxyPrivate *proxy = prototype->ctx->global->prototype->proxy;
+    script_ctx_t *ctx = prototype->ctx;
+    ProxyConstructor *constructor;
+    DISPPARAMS dp = { 0 };
+    EXCEPINFO ei = { 0 };
+    HRESULT hres;
+    VARIANT var;
+
+    hres = proxy->lpVtbl->PropInvoke(proxy, (IDispatch*)ctx->global->proxy, id, ctx->lcid, DISPATCH_PROPERTYGET,
+                                     &dp, &var, &ei, &ctx->jscaller->IServiceProvider_iface);
+    if(hres == DISP_E_EXCEPTION)
+        disp_fill_exception(ctx, &ei);
+    if(FAILED(hres))
+        return hres;
+    if(V_VT(&var) != VT_DISPATCH) {
+        VariantClear(&var);
+        return E_UNEXPECTED;
+    }
+
+    /* create wrapper constructor function over the disp's value */
+    hres = create_function(ctx, &ProxyConstructor_info, &ProxyConstructorVtbl, sizeof(ProxyConstructor),
+                           PROPF_CONSTR, FALSE, NULL, (void**)&constructor);
+    if(FAILED(hres)) {
+        IDispatch_Release(V_DISPATCH(&var));
+        return hres;
+    }
+
+    constructor->disp = V_DISPATCH(&var);
+    constructor->name = name;
+
+    hres = jsdisp_define_data_property(&constructor->function.dispex, L"prototype", 0, jsval_obj(prototype));
+
+    if(SUCCEEDED(hres) && id == DISPID_IHTMLWINDOW5_XMLHTTPREQUEST) {
+        ProxyConstructor *create;
+
+        hres = create_function(ctx, &ProxyConstructor_info, &ProxyConstructorVtbl, sizeof(ProxyConstructor),
+                               PROPF_METHOD, FALSE, NULL, (void**)&create);
+        if(SUCCEEDED(hres)) {
+            IDispatch_AddRef(V_DISPATCH(&var));
+            create->disp = V_DISPATCH(&var);
+            create->name = ProxyConstructor_createW;
+
+            hres = jsdisp_define_data_property(&create->function.dispex, L"prototype", 0, jsval_null());
+            if(SUCCEEDED(hres))
+                hres = jsdisp_define_data_property(&constructor->function.dispex, ProxyConstructor_createW,
+                                                   0, jsval_obj(&create->function.dispex));
+            jsdisp_release(&create->function.dispex);
+        }
+    }
+    if(FAILED(hres)) {
+        jsdisp_release(&constructor->function.dispex);
+        return hres;
+    }
+
+    *ret = &constructor->function.dispex;
+    return S_OK;
+}
+
+/*
+ * Create the actual prototype on demand, since it is a circular ref, which prevents the vast
+ * majority of functions from being released quickly, leading to unnecessary scope detach.
+ */
+static HRESULT InterpretedFunction_get_prototype(script_ctx_t *ctx, jsdisp_t *jsthis, jsval_t *r)
+{
+    jsdisp_t *prototype;
+    HRESULT hres;
+
+    hres = create_object(ctx, NULL, &prototype);
+    if(FAILED(hres))
+        return hres;
+
+    hres = jsdisp_define_data_property(jsthis, L"prototype", PROPF_WRITABLE, jsval_obj(prototype));
+    if(SUCCEEDED(hres))
+        hres = set_constructor_prop(ctx, jsthis, prototype);
+    if(FAILED(hres)) {
+        jsdisp_release(prototype);
+        return hres;
+    }
+
+    *r = jsval_obj(prototype);
+    return S_OK;
+}
+
+static HRESULT InterpretedFunction_set_prototype(script_ctx_t *ctx, jsdisp_t *jsthis, jsval_t value)
+{
+    return jsdisp_define_data_property(jsthis, L"prototype", PROPF_WRITABLE, value);
+}
+
+static const builtin_prop_t InterpretedFunction_props[] = {
+    {L"arguments",           NULL, 0,                        Function_get_arguments},
+    {L"length",              NULL, 0,                        Function_get_length},
+    {L"prototype",           NULL, 0,                        InterpretedFunction_get_prototype, InterpretedFunction_set_prototype}
+};
+
+static const builtin_info_t InterpretedFunction_info = {
+    JSCLASS_FUNCTION,
+    Function_value,
+    ARRAY_SIZE(InterpretedFunction_props),
+    InterpretedFunction_props,
+    Function_destructor,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    Function_gc_traverse
+};
+
 static HRESULT InterpretedFunction_call(script_ctx_t *ctx, FunctionInstance *func, jsval_t vthis, unsigned flags,
          unsigned argc, jsval_t *argv, jsval_t *r)
 {
@@ -733,8 +1203,11 @@ static HRESULT InterpretedFunction_call(script_ctx_t *ctx, FunctionInstance *fun
             return hres;
         this_obj = to_disp(new_obj);
     }else if(is_object_instance(vthis)) {
+        IDispatch_AddRef(get_object(vthis));
+        hres = convert_to_proxy(ctx, &vthis);
+        if(FAILED(hres))
+            return hres;
         this_obj = get_object(vthis);
-        IDispatch_AddRef(this_obj);
     }else if(ctx->version >= SCRIPTLANGUAGEVERSION_ES5 && !is_undefined(vthis) && !is_null(vthis)) {
         hres = to_object(ctx, vthis, &this_obj);
         if(FAILED(hres))
@@ -771,40 +1244,50 @@ static void InterpretedFunction_destructor(FunctionInstance *func)
 {
     InterpretedFunction *function = (InterpretedFunction*)func;
 
-    release_bytecode(function->code);
+    if(function->code)
+        release_bytecode(function->code);
     if(function->scope_chain)
         scope_release(function->scope_chain);
 }
 
+static HRESULT InterpretedFunction_gc_traverse(FunctionInstance *func, void *arg)
+{
+    InterpretedFunction *function = (InterpretedFunction*)func;
+
+    /* Make sure to unlink everything during unlink, including deeper scopes, so
+       that releasing the function itself won't release any additional objects. */
+    if(arg == GC_TRAVERSE_UNLINK) {
+        release_bytecode(function->code);
+        function->code = NULL;
+        if(function->scope_chain) {
+            scope_release(function->scope_chain);
+            function->scope_chain = NULL;
+        }
+        return S_OK;
+    }
+
+    /* FIXME: Process the code->named_item->script_obj and scope_chain->obj somehow. The issue
+       is that the function keeps a ref to the bytecode or scope itself, not the actual obj...
+       For now, this will possibly leak. */
+    return S_OK;
+}
+
 static const function_vtbl_t InterpretedFunctionVtbl = {
     InterpretedFunction_call,
     InterpretedFunction_toString,
     InterpretedFunction_get_code,
-    InterpretedFunction_destructor
+    InterpretedFunction_destructor,
+    InterpretedFunction_gc_traverse
 };
 
 HRESULT create_source_function(script_ctx_t *ctx, bytecode_t *code, function_code_t *func_code,
         scope_chain_t *scope_chain, jsdisp_t **ret)
 {
     InterpretedFunction *function;
-    jsdisp_t *prototype;
     HRESULT hres;
 
-    hres = create_object(ctx, NULL, &prototype);
-    if(FAILED(hres))
-        return hres;
-
-    hres = create_function(ctx, NULL, &InterpretedFunctionVtbl, sizeof(InterpretedFunction), PROPF_CONSTR,
-                           FALSE, NULL, (void**)&function);
-    if(SUCCEEDED(hres)) {
-        hres = jsdisp_define_data_property(&function->function.dispex, L"prototype", PROPF_WRITABLE,
-                                           jsval_obj(prototype));
-        if(SUCCEEDED(hres))
-            hres = set_constructor_prop(ctx, &function->function.dispex, prototype);
-        if(FAILED(hres))
-            jsdisp_release(&function->function.dispex);
-    }
-    jsdisp_release(prototype);
+    hres = create_function(ctx, &InterpretedFunction_info, &InterpretedFunctionVtbl, sizeof(InterpretedFunction),
+                           PROPF_CONSTR, FALSE, NULL, (void**)&function);
     if(FAILED(hres))
         return hres;
 
@@ -871,16 +1354,37 @@ static void BindFunction_destructor(FunctionInstance *func)
 
     for(i = 0; i < function->argc; i++)
         jsval_release(function->args[i]);
-    jsdisp_release(&function->target->dispex);
+    if(function->target)
+        jsdisp_release(&function->target->dispex);
     if(function->this)
         IDispatch_Release(function->this);
 }
 
+static HRESULT BindFunction_gc_traverse(FunctionInstance *func, void *arg)
+{
+    BindFunction *function = (BindFunction*)func;
+    HRESULT hres;
+    unsigned i;
+
+    for(i = 0; i < function->argc; i++) {
+        hres = gc_process_linked_val(&function->function.dispex, &function->args[i], arg);
+        if(FAILED(hres))
+            return hres;
+    }
+
+    hres = gc_process_linked_obj(&function->function.dispex, &function->target->dispex, (void**)&function->target, arg);
+    if(FAILED(hres))
+        return hres;
+
+    return function->this ? gc_process_linked_disp(&function->function.dispex, &function->this, arg) : S_OK;
+}
+
 static const function_vtbl_t BindFunctionVtbl = {
     BindFunction_call,
     BindFunction_toString,
     BindFunction_get_code,
-    BindFunction_destructor
+    BindFunction_destructor,
+    BindFunction_gc_traverse
 };
 
 static HRESULT create_bind_function(script_ctx_t *ctx, FunctionInstance *target, IDispatch *bound_this, unsigned argc,
diff --git a/dlls/jscript/global.c b/dlls/jscript/global.c
index c0ed954230b..47bd40c4490 100644
--- a/dlls/jscript/global.c
+++ b/dlls/jscript/global.c
@@ -944,7 +944,7 @@ static HRESULT init_constructors(script_ctx_t *ctx, jsdisp_t *object_prototype)
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"Function", PROPF_WRITABLE,
+    hres = jsdisp_define_data_property(ctx->global, L"Function", PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                        jsval_obj(ctx->function_constr));
     if(FAILED(hres))
         return hres;
@@ -953,7 +953,7 @@ static HRESULT init_constructors(script_ctx_t *ctx, jsdisp_t *object_prototype)
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"Object", PROPF_WRITABLE,
+    hres = jsdisp_define_data_property(ctx->global, L"Object", PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                        jsval_obj(ctx->object_constr));
     if(FAILED(hres))
         return hres;
@@ -962,7 +962,7 @@ static HRESULT init_constructors(script_ctx_t *ctx, jsdisp_t *object_prototype)
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"Array", PROPF_WRITABLE,
+    hres = jsdisp_define_data_property(ctx->global, L"Array", PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                        jsval_obj(ctx->array_constr));
     if(FAILED(hres))
         return hres;
@@ -971,7 +971,7 @@ static HRESULT init_constructors(script_ctx_t *ctx, jsdisp_t *object_prototype)
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"Boolean", PROPF_WRITABLE,
+    hres = jsdisp_define_data_property(ctx->global, L"Boolean", PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                        jsval_obj(ctx->bool_constr));
     if(FAILED(hres))
         return hres;
@@ -980,7 +980,7 @@ static HRESULT init_constructors(script_ctx_t *ctx, jsdisp_t *object_prototype)
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"Date", PROPF_WRITABLE,
+    hres = jsdisp_define_data_property(ctx->global, L"Date", PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                        jsval_obj(ctx->date_constr));
     if(FAILED(hres))
         return hres;
@@ -989,7 +989,7 @@ static HRESULT init_constructors(script_ctx_t *ctx, jsdisp_t *object_prototype)
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"Enumerator", PROPF_WRITABLE,
+    hres = jsdisp_define_data_property(ctx->global, L"Enumerator", PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                        jsval_obj(ctx->enumerator_constr));
     if(FAILED(hres))
         return hres;
@@ -998,42 +998,42 @@ static HRESULT init_constructors(script_ctx_t *ctx, jsdisp_t *object_prototype)
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"Error", PROPF_WRITABLE,
+    hres = jsdisp_define_data_property(ctx->global, L"Error", PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                        jsval_obj(ctx->error_constr));
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"EvalError", PROPF_WRITABLE,
+    hres = jsdisp_define_data_property(ctx->global, L"EvalError", PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                        jsval_obj(ctx->eval_error_constr));
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"RangeError", PROPF_WRITABLE,
+    hres = jsdisp_define_data_property(ctx->global, L"RangeError", PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                        jsval_obj(ctx->range_error_constr));
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"ReferenceError", PROPF_WRITABLE,
+    hres = jsdisp_define_data_property(ctx->global, L"ReferenceError", PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                        jsval_obj(ctx->reference_error_constr));
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"RegExpError", PROPF_WRITABLE,
+    hres = jsdisp_define_data_property(ctx->global, L"RegExpError", PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                        jsval_obj(ctx->regexp_error_constr));
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"SyntaxError", PROPF_WRITABLE,
+    hres = jsdisp_define_data_property(ctx->global, L"SyntaxError", PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                        jsval_obj(ctx->syntax_error_constr));
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"TypeError", PROPF_WRITABLE,
+    hres = jsdisp_define_data_property(ctx->global, L"TypeError", PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                        jsval_obj(ctx->type_error_constr));
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"URIError", PROPF_WRITABLE,
+    hres = jsdisp_define_data_property(ctx->global, L"URIError", PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                        jsval_obj(ctx->uri_error_constr));
     if(FAILED(hres))
         return hres;
@@ -1042,7 +1042,7 @@ static HRESULT init_constructors(script_ctx_t *ctx, jsdisp_t *object_prototype)
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"Number", PROPF_WRITABLE,
+    hres = jsdisp_define_data_property(ctx->global, L"Number", PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                        jsval_obj(ctx->number_constr));
     if(FAILED(hres))
         return hres;
@@ -1051,7 +1051,7 @@ static HRESULT init_constructors(script_ctx_t *ctx, jsdisp_t *object_prototype)
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"RegExp", PROPF_WRITABLE,
+    hres = jsdisp_define_data_property(ctx->global, L"RegExp", PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                        jsval_obj(ctx->regexp_constr));
     if(FAILED(hres))
         return hres;
@@ -1060,7 +1060,7 @@ static HRESULT init_constructors(script_ctx_t *ctx, jsdisp_t *object_prototype)
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"String", PROPF_WRITABLE,
+    hres = jsdisp_define_data_property(ctx->global, L"String", PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                        jsval_obj(ctx->string_constr));
     if(FAILED(hres))
         return hres;
@@ -1069,7 +1069,7 @@ static HRESULT init_constructors(script_ctx_t *ctx, jsdisp_t *object_prototype)
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"VBArray", PROPF_WRITABLE,
+    hres = jsdisp_define_data_property(ctx->global, L"VBArray", PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                        jsval_obj(ctx->vbarray_constr));
     if(FAILED(hres))
         return hres;
@@ -1106,7 +1106,7 @@ HRESULT init_global(script_ctx_t *ctx)
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"Math", PROPF_WRITABLE, jsval_obj(math));
+    hres = jsdisp_define_data_property(ctx->global, L"Math", PROPF_CONFIGURABLE | PROPF_WRITABLE, jsval_obj(math));
     jsdisp_release(math);
     if(FAILED(hres))
         return hres;
@@ -1118,7 +1118,7 @@ HRESULT init_global(script_ctx_t *ctx)
         if(FAILED(hres))
             return hres;
 
-        hres = jsdisp_define_data_property(ctx->global, L"JSON", PROPF_WRITABLE, jsval_obj(json));
+        hres = jsdisp_define_data_property(ctx->global, L"JSON", PROPF_CONFIGURABLE | PROPF_WRITABLE, jsval_obj(json));
         jsdisp_release(json);
         if(FAILED(hres))
             return hres;
@@ -1128,7 +1128,7 @@ HRESULT init_global(script_ctx_t *ctx)
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"ActiveXObject", PROPF_WRITABLE,
+    hres = jsdisp_define_data_property(ctx->global, L"ActiveXObject", PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                        jsval_obj(constr));
     jsdisp_release(constr);
     if(FAILED(hres))
@@ -1146,5 +1146,15 @@ HRESULT init_global(script_ctx_t *ctx)
     if(FAILED(hres))
         return hres;
 
-    return init_set_constructor(ctx);
+    hres = init_arraybuf_constructors(ctx);
+    if(FAILED(hres))
+        return hres;
+
+    hres = init_set_constructor(ctx);
+    if(FAILED(hres))
+        return hres;
+
+    if(ctx->js_global) jsdisp_release(ctx->js_global);
+    ctx->js_global = jsdisp_addref(ctx->global);
+    return hres;
 }
diff --git a/dlls/jscript/jscript.c b/dlls/jscript/jscript.c
index 8cf141d3990..8fc70a53344 100644
--- a/dlls/jscript/jscript.c
+++ b/dlls/jscript/jscript.c
@@ -129,9 +129,11 @@ static void release_named_item_script_obj(named_item_t *item)
     item->script_obj = NULL;
 }
 
-static HRESULT retrieve_named_item_disp(IActiveScriptSite *site, named_item_t *item)
+static HRESULT retrieve_named_item_disp(script_ctx_t *ctx, IActiveScriptSite *site, named_item_t *item)
 {
+    IDispatch *disp;
     IUnknown *unk;
+    jsval_t val;
     HRESULT hr;
 
     if(!site)
@@ -143,13 +145,19 @@ static HRESULT retrieve_named_item_disp(IActiveScriptSite *site, named_item_t *i
         return hr;
     }
 
-    hr = IUnknown_QueryInterface(unk, &IID_IDispatch, (void**)&item->disp);
+    hr = IUnknown_QueryInterface(unk, &IID_IDispatch, (void**)&disp);
     IUnknown_Release(unk);
     if(FAILED(hr)) {
         WARN("object does not implement IDispatch\n");
         return hr;
     }
 
+    val = jsval_disp(disp);
+    hr = convert_to_proxy(ctx, &val);
+    if(FAILED(hr))
+        return hr;
+    item->disp = get_object(val);
+
     return S_OK;
 }
 
@@ -166,7 +174,7 @@ named_item_t *lookup_named_item(script_ctx_t *ctx, const WCHAR *item_name, unsig
             }
 
             if(!item->disp && (flags || !(item->flags & SCRIPTITEM_CODEONLY))) {
-                hr = retrieve_named_item_disp(ctx->site, item);
+                hr = retrieve_named_item_disp(ctx, ctx->site, item);
                 if(FAILED(hr)) continue;
             }
 
@@ -437,6 +445,7 @@ static void exec_queued_code(JScript *This)
 static void decrease_state(JScript *This, SCRIPTSTATE state)
 {
     named_item_t *item, *item_next;
+    unsigned int i;
 
     if(This->ctx) {
         switch(This->ctx->state) {
@@ -473,6 +482,18 @@ static void decrease_state(JScript *This, SCRIPTSTATE state)
                 }
             }
 
+            if(This->ctx->proxy_prototypes) {
+                for(i = 0; i < This->ctx->proxy_prototypes->num; i++) {
+                    if(This->ctx->proxy_prototypes->disp[i].prototype)
+                        IDispatch_Release(This->ctx->proxy_prototypes->disp[i].prototype);
+                    if(This->ctx->proxy_prototypes->disp[i].ctor)
+                        IDispatch_Release(This->ctx->proxy_prototypes->disp[i].ctor);
+                }
+
+                heap_free(This->ctx->proxy_prototypes);
+                This->ctx->proxy_prototypes = NULL;
+            }
+
             if(This->ctx->secmgr) {
                 IInternetHostSecurityManager_Release(This->ctx->secmgr);
                 This->ctx->secmgr = NULL;
@@ -502,6 +523,11 @@ static void decrease_state(JScript *This, SCRIPTSTATE state)
                 jsdisp_release(This->ctx->global);
                 This->ctx->global = NULL;
             }
+
+            if(This->ctx->js_global) {
+                jsdisp_release(This->ctx->js_global);
+                This->ctx->js_global = NULL;
+            }
             /* FALLTHROUGH */
         case SCRIPTSTATE_UNINITIALIZED:
             change_state(This, state);
@@ -741,6 +767,7 @@ static HRESULT WINAPI JScript_SetScriptSite(IActiveScript *iface,
         ctx->html_mode = This->html_mode;
         ctx->acc = jsval_undefined();
         list_init(&ctx->named_items);
+        list_init(&ctx->objects);
         heap_pool_init(&ctx->tmp_heap);
 
         hres = create_jscaller(ctx);
@@ -763,7 +790,7 @@ static HRESULT WINAPI JScript_SetScriptSite(IActiveScript *iface,
     {
         if(!item->disp)
         {
-            hres = retrieve_named_item_disp(pass, item);
+            hres = retrieve_named_item_disp(This->ctx, pass, item);
             if(FAILED(hres)) return hres;
         }
 
@@ -886,7 +913,9 @@ static HRESULT WINAPI JScript_AddNamedItem(IActiveScript *iface,
         return E_UNEXPECTED;
 
     if(dwFlags & SCRIPTITEM_GLOBALMEMBERS) {
+        jsdisp_t *jsdisp;
         IUnknown *unk;
+        jsval_t val;
 
         hres = IActiveScriptSite_GetItemInfo(This->site, pstrName, SCRIPTINFO_IUNKNOWN, &unk, NULL);
         if(FAILED(hres)) {
@@ -900,6 +929,17 @@ static HRESULT WINAPI JScript_AddNamedItem(IActiveScript *iface,
             WARN("object does not implement IDispatch\n");
             return hres;
         }
+
+        val = jsval_disp(disp);
+        hres = convert_to_proxy(This->ctx, &val);
+        if(FAILED(hres))
+            return hres;
+        disp = get_object(val);
+
+        if((jsdisp = to_jsdisp(disp)) && jsdisp->proxy) {
+            jsdisp_release(This->ctx->global);
+            This->ctx->global = jsdisp_addref(jsdisp);
+        }
     }
 
     item = heap_alloc(sizeof(*item));
@@ -956,7 +996,7 @@ static HRESULT WINAPI JScript_GetScriptDispatch(IActiveScript *iface, LPCOLESTR
         if(item->script_obj) script_obj = item->script_obj;
     }
 
-    *ppdisp = to_disp(script_obj);
+    *ppdisp = script_obj->proxy ? (IDispatch*)script_obj->proxy : to_disp(script_obj);
     IDispatch_AddRef(*ppdisp);
     return S_OK;
 }
@@ -1440,3 +1480,8 @@ HRESULT create_jscript_object(BOOL is_encode, REFIID riid, void **ppv)
     IActiveScript_Release(&ret->IActiveScript_iface);
     return hres;
 }
+
+script_ctx_t *get_script_ctx(IActiveScript *script)
+{
+    return (script->lpVtbl == &JScriptVtbl) ? impl_from_IActiveScript(script)->ctx : NULL;
+}
diff --git a/dlls/jscript/jscript.h b/dlls/jscript/jscript.h
index 000bcc287f4..7721e29aed1 100644
--- a/dlls/jscript/jscript.h
+++ b/dlls/jscript/jscript.h
@@ -47,6 +47,77 @@
 #define SCRIPTLANGUAGEVERSION_ES5  0x102
 #define SCRIPTLANGUAGEVERSION_ES6  0x103
 
+/*
+ * These are Wine jscript extensions, used for mshtml objects so they act like JS objects.
+ * Both extend IDispatchEx. IWineDispatchProxyCbPrivate is always available on jscript side.
+ *
+ * NOTE: Keep in sync with mshtml_private.h in mshtml.dll
+ */
+DEFINE_GUID(IID_IWineDispatchProxyPrivate, 0xd359f2fe,0x5531,0x741b,0xa4,0x1a,0x5c,0xf9,0x2e,0xdc,0x97,0x1b);
+typedef struct _IWineDispatchProxyPrivate IWineDispatchProxyPrivate;
+typedef struct _IWineDispatchProxyCbPrivate IWineDispatchProxyCbPrivate;
+
+struct proxy_prototypes
+{
+    unsigned int num;
+    struct {
+        IDispatch *prototype;
+        IDispatch *ctor;
+    } disp[];
+};
+
+struct proxy_func_invoker
+{
+    HRESULT (STDMETHODCALLTYPE *invoke)(IDispatch*,void*,DISPPARAMS*,VARIANT*,EXCEPINFO*,IServiceProvider*);
+    void *context;
+    const WCHAR *name;
+};
+
+typedef struct {
+    IDispatchExVtbl dispex;
+    IWineDispatchProxyCbPrivate** (STDMETHODCALLTYPE *GetProxyFieldRef)(IWineDispatchProxyPrivate *This);
+    IDispatch* (STDMETHODCALLTYPE *GetDefaultPrototype)(IWineDispatchProxyPrivate *This, struct proxy_prototypes **prots_ref);
+    IDispatch* (STDMETHODCALLTYPE *GetDefaultConstructor)(IWineDispatchProxyPrivate *This, struct proxy_prototypes *prots);
+    HRESULT (STDMETHODCALLTYPE *DefineConstructors)(IWineDispatchProxyPrivate *This, struct proxy_prototypes **prots_ref);
+    BOOL (STDMETHODCALLTYPE *IsPrototype)(IWineDispatchProxyPrivate *This);
+    BOOL (STDMETHODCALLTYPE *IsConstructor)(IWineDispatchProxyPrivate *This);
+    DWORD (STDMETHODCALLTYPE *PropFlags)(IWineDispatchProxyPrivate *This, DISPID id);
+    HRESULT (STDMETHODCALLTYPE *PropGetID)(IWineDispatchProxyPrivate *This, WCHAR *name, DISPID *id);
+    HRESULT (STDMETHODCALLTYPE *PropInvoke)(IWineDispatchProxyPrivate *This, IDispatch *this_obj, DISPID id, LCID lcid,
+                                            DWORD flags, DISPPARAMS *dp, VARIANT *ret, EXCEPINFO *ei, IServiceProvider *caller);
+    HRESULT (STDMETHODCALLTYPE *PropDelete)(IWineDispatchProxyPrivate *This, DISPID id);
+    HRESULT (STDMETHODCALLTYPE *FuncInfo)(IWineDispatchProxyPrivate *This, DISPID id, struct proxy_func_invoker *ret);
+    HRESULT (STDMETHODCALLTYPE *AccessorInfo)(IWineDispatchProxyPrivate *This, DISPID id, struct proxy_func_invoker *ret);
+    HRESULT (STDMETHODCALLTYPE *ToString)(IWineDispatchProxyPrivate *This, BSTR *string);
+    BOOL (STDMETHODCALLTYPE *CanGC)(IWineDispatchProxyPrivate *This);
+} IWineDispatchProxyPrivateVtbl;
+
+typedef struct {
+    IDispatchExVtbl dispex;
+    void (STDMETHODCALLTYPE *Unlinked)(IWineDispatchProxyCbPrivate *This);
+    void (STDMETHODCALLTYPE *Relinked)(IWineDispatchProxyCbPrivate *This, IWineDispatchProxyPrivate *proxy);
+    HRESULT (STDMETHODCALLTYPE *HostUpdated)(IWineDispatchProxyCbPrivate *This, IActiveScript *script);
+    DISPID (STDMETHODCALLTYPE *GetUnderlyingDispID)(IWineDispatchProxyCbPrivate *This, DISPID id);
+    IDispatch* (STDMETHODCALLTYPE *CreateConstructor)(IWineDispatchProxyCbPrivate *This, DISPID id, const WCHAR *name);
+    HRESULT (STDMETHODCALLTYPE *DefineConstructor)(IWineDispatchProxyCbPrivate *This, const WCHAR *name, IDispatch *prot, DISPID);
+    HRESULT (STDMETHODCALLTYPE *GetRandomValues)(IDispatch *typedarr);
+    void (STDMETHODCALLTYPE *Traverse)(IWineDispatchProxyCbPrivate *This,
+                                       void (STDMETHODCALLTYPE *note_cc_edge)(IDispatch*,void*), void *cb);
+} IWineDispatchProxyCbPrivateVtbl;
+
+struct _IWineDispatchProxyPrivate {
+    const IWineDispatchProxyPrivateVtbl *lpVtbl;
+};
+
+struct _IWineDispatchProxyCbPrivate {
+    const IWineDispatchProxyCbPrivateVtbl *lpVtbl;
+};
+
+#define WINE_DISP_PROXY_NULL_PROTOTYPE ((IDispatch*)(INT_PTR)-2)
+#define WINE_DISP_PROXY_OBJECT_PROTOTYPE ((IDispatch*)(INT_PTR)-1)
+
+
+
 typedef struct _jsval_t jsval_t;
 typedef struct _jsstr_t jsstr_t;
 typedef struct _jsexcept_t jsexcept_t;
@@ -70,6 +141,22 @@ void heap_pool_clear(heap_pool_t*) DECLSPEC_HIDDEN;
 void heap_pool_free(heap_pool_t*) DECLSPEC_HIDDEN;
 heap_pool_t *heap_pool_mark(heap_pool_t*) DECLSPEC_HIDDEN;
 
+/* Initialize to zero before use */
+struct heap_stack {
+    void **chunk;
+    void **next;
+    unsigned idx;
+};
+
+HRESULT heap_stack_push(struct heap_stack*,void*) DECLSPEC_HIDDEN;
+void *heap_stack_pop(struct heap_stack*) DECLSPEC_HIDDEN;
+
+/* Make sure the stack is completely popped before calling this */
+static inline void heap_stack_free(struct heap_stack *heap_stack)
+{
+    free(heap_stack->next);
+}
+
 static inline LPWSTR heap_strdupW(LPCWSTR str)
 {
     LPWSTR ret = NULL;
@@ -91,6 +178,7 @@ typedef struct jsdisp_t jsdisp_t;
 extern HINSTANCE jscript_hinstance DECLSPEC_HIDDEN;
 HRESULT get_dispatch_typeinfo(ITypeInfo**) DECLSPEC_HIDDEN;
 
+/* NOTE: Keep in sync with mshtml_private.h in mshtml.dll */
 #define PROPF_ARGMASK       0x00ff
 #define PROPF_METHOD        0x0100
 #define PROPF_CONSTR        0x0200
@@ -100,6 +188,8 @@ HRESULT get_dispatch_typeinfo(ITypeInfo**) DECLSPEC_HIDDEN;
 #define PROPF_CONFIGURABLE  0x1000
 #define PROPF_ALL           (PROPF_ENUMERABLE | PROPF_WRITABLE | PROPF_CONFIGURABLE)
 
+#define PROPF_PROXY_ACCESSOR 0x8000
+
 #define PROPF_VERSION_MASK  0x01ff0000
 #define PROPF_VERSION_SHIFT 16
 #define PROPF_HTML          (SCRIPTLANGUAGEVERSION_HTML << PROPF_VERSION_SHIFT)
@@ -132,8 +222,24 @@ typedef enum {
     JSCLASS_ARGUMENTS,
     JSCLASS_VBARRAY,
     JSCLASS_JSON,
+    JSCLASS_ARRAYBUFFER,
+    JSCLASS_DATAVIEW,
+    JSCLASS_INT8ARRAY,
+    JSCLASS_INT16ARRAY,
+    JSCLASS_INT32ARRAY,
+    JSCLASS_UINT8ARRAY,
+    JSCLASS_UINT8CLAMPEDARRAY,
+    JSCLASS_UINT16ARRAY,
+    JSCLASS_UINT32ARRAY,
+    JSCLASS_FLOAT32ARRAY,
+    JSCLASS_FLOAT64ARRAY,
     JSCLASS_MAP,
     JSCLASS_SET,
+
+    FIRST_TYPEDARRAY_JSCLASS = JSCLASS_INT8ARRAY,
+    LAST_TYPEDARRAY_JSCLASS  = JSCLASS_FLOAT64ARRAY,
+    FIRST_VIEW_JSCLASS = JSCLASS_DATAVIEW,
+    LAST_VIEW_JSCLASS = JSCLASS_FLOAT64ARRAY,
 } jsclass_t;
 
 jsdisp_t *iface_to_jsdisp(IDispatch*) DECLSPEC_HIDDEN;
@@ -176,6 +282,7 @@ typedef struct {
     unsigned (*idx_length)(jsdisp_t*);
     HRESULT (*idx_get)(jsdisp_t*,unsigned,jsval_t*);
     HRESULT (*idx_put)(jsdisp_t*,unsigned,jsval_t);
+    HRESULT (*gc_traverse)(jsdisp_t*,void*);
 } builtin_info_t;
 
 struct jsdisp_t {
@@ -183,15 +290,19 @@ struct jsdisp_t {
 
     LONG ref;
 
+    BOOLEAN extensible;
+    BOOLEAN gc_marked;
+
     DWORD buf_size;
     DWORD prop_cnt;
     dispex_prop_t *props;
     script_ctx_t *ctx;
-    BOOL extensible;
 
     jsdisp_t *prototype;
+    IWineDispatchProxyPrivate *proxy;
 
     const builtin_info_t *builtin_info;
+    struct list entry;
 };
 
 static inline IDispatch *to_disp(jsdisp_t *jsdisp)
@@ -201,6 +312,7 @@ static inline IDispatch *to_disp(jsdisp_t *jsdisp)
 
 jsdisp_t *as_jsdisp(IDispatch*) DECLSPEC_HIDDEN;
 jsdisp_t *to_jsdisp(IDispatch*) DECLSPEC_HIDDEN;
+void jsdisp_reacquire(jsdisp_t*) DECLSPEC_HIDDEN;
 void jsdisp_free(jsdisp_t*) DECLSPEC_HIDDEN;
 
 #ifndef TRACE_REFCNT
@@ -213,7 +325,8 @@ void jsdisp_free(jsdisp_t*) DECLSPEC_HIDDEN;
  */
 static inline jsdisp_t *jsdisp_addref(jsdisp_t *jsdisp)
 {
-    jsdisp->ref++;
+    if(!jsdisp->ref++)
+        jsdisp_reacquire(jsdisp);
     return jsdisp;
 }
 
@@ -239,7 +352,9 @@ enum jsdisp_enum_type {
 HRESULT create_dispex(script_ctx_t*,const builtin_info_t*,jsdisp_t*,jsdisp_t**) DECLSPEC_HIDDEN;
 HRESULT init_dispex(jsdisp_t*,script_ctx_t*,const builtin_info_t*,jsdisp_t*) DECLSPEC_HIDDEN;
 HRESULT init_dispex_from_constr(jsdisp_t*,script_ctx_t*,const builtin_info_t*,jsdisp_t*) DECLSPEC_HIDDEN;
+HRESULT convert_to_proxy(script_ctx_t*,jsval_t*) DECLSPEC_HIDDEN;
 
+void disp_fill_exception(script_ctx_t*,EXCEPINFO*) DECLSPEC_HIDDEN;
 HRESULT disp_call(script_ctx_t*,IDispatch*,DISPID,WORD,unsigned,jsval_t*,jsval_t*) DECLSPEC_HIDDEN;
 HRESULT disp_call_name(script_ctx_t*,IDispatch*,const WCHAR*,WORD,unsigned,jsval_t*,jsval_t*) DECLSPEC_HIDDEN;
 HRESULT disp_call_value(script_ctx_t*,IDispatch*,IDispatch*,WORD,unsigned,jsval_t*,jsval_t*) DECLSPEC_HIDDEN;
@@ -272,6 +387,9 @@ HRESULT create_builtin_function(script_ctx_t*,builtin_invoke_t,const WCHAR*,cons
         jsdisp_t*,jsdisp_t**) DECLSPEC_HIDDEN;
 HRESULT create_builtin_constructor(script_ctx_t*,builtin_invoke_t,const WCHAR*,const builtin_info_t*,DWORD,
         jsdisp_t*,jsdisp_t**) DECLSPEC_HIDDEN;
+HRESULT create_proxy_function(jsdisp_t*,DISPID,DWORD,jsdisp_t**) DECLSPEC_HIDDEN;
+HRESULT create_proxy_accessor(jsdisp_t*,DISPID,property_desc_t*) DECLSPEC_HIDDEN;
+HRESULT create_proxy_constructor(DISPID,const WCHAR*,jsdisp_t*,jsdisp_t**) DECLSPEC_HIDDEN;
 HRESULT Function_invoke(jsdisp_t*,IDispatch*,WORD,unsigned,jsval_t*,jsval_t*) DECLSPEC_HIDDEN;
 
 HRESULT Function_value(script_ctx_t*,jsval_t,WORD,unsigned,jsval_t*,jsval_t*) DECLSPEC_HIDDEN;
@@ -318,6 +436,7 @@ HRESULT variant_date_to_string(script_ctx_t*,double,jsstr_t**) DECLSPEC_HIDDEN;
 HRESULT decode_source(WCHAR*) DECLSPEC_HIDDEN;
 
 HRESULT double_to_string(double,jsstr_t**) DECLSPEC_HIDDEN;
+WCHAR *idx_to_str(DWORD,WCHAR*) DECLSPEC_HIDDEN;
 
 static inline BOOL is_digit(WCHAR c)
 {
@@ -366,6 +485,7 @@ struct _script_ctx_t {
 
     struct _call_frame_t *call_ctx;
     struct list named_items;
+    struct list objects;
     IActiveScriptSite *site;
     IInternetHostSecurityManager *secmgr;
     DWORD safeopt;
@@ -380,6 +500,7 @@ struct _script_ctx_t {
 
     jsval_t *stack;
     unsigned stack_top;
+    DWORD gc_last_tick;
     jsval_t acc;
 
     jsstr_t *last_match;
@@ -388,6 +509,7 @@ struct _script_ctx_t {
     DWORD last_match_length;
 
     jsdisp_t *global;
+    jsdisp_t *js_global;
     jsdisp_t *function_constr;
     jsdisp_t *array_constr;
     jsdisp_t *bool_constr;
@@ -407,8 +529,13 @@ struct _script_ctx_t {
     jsdisp_t *regexp_constr;
     jsdisp_t *string_constr;
     jsdisp_t *vbarray_constr;
+    jsdisp_t *arraybuf_constr;
+    jsdisp_t *dataview_constr;
+    jsdisp_t *typedarr_constr[LAST_TYPEDARRAY_JSCLASS - FIRST_TYPEDARRAY_JSCLASS + 1];
     jsdisp_t *map_prototype;
     jsdisp_t *set_prototype;
+
+    struct proxy_prototypes *proxy_prototypes;
 };
 
 void script_release(script_ctx_t*) DECLSPEC_HIDDEN;
@@ -422,6 +549,7 @@ HRESULT init_global(script_ctx_t*) DECLSPEC_HIDDEN;
 HRESULT init_function_constr(script_ctx_t*,jsdisp_t*) DECLSPEC_HIDDEN;
 HRESULT create_object_prototype(script_ctx_t*,jsdisp_t**) DECLSPEC_HIDDEN;
 HRESULT init_set_constructor(script_ctx_t*) DECLSPEC_HIDDEN;
+HRESULT init_arraybuf_constructors(script_ctx_t*) DECLSPEC_HIDDEN;
 
 HRESULT create_activex_constr(script_ctx_t*,jsdisp_t**) DECLSPEC_HIDDEN;
 HRESULT create_array_constr(script_ctx_t*,jsdisp_t*,jsdisp_t**) DECLSPEC_HIDDEN;
@@ -453,6 +581,7 @@ unsigned array_get_length(jsdisp_t*) DECLSPEC_HIDDEN;
 HRESULT localize_number(script_ctx_t*,DOUBLE,BOOL,jsstr_t**) DECLSPEC_HIDDEN;
 
 HRESULT JSGlobal_eval(script_ctx_t*,jsval_t,WORD,unsigned,jsval_t*,jsval_t*) DECLSPEC_HIDDEN;
+HRESULT Object_toString(script_ctx_t*,jsval_t,WORD,unsigned,jsval_t*,jsval_t*) DECLSPEC_HIDDEN;
 HRESULT Object_get_proto_(script_ctx_t*,jsval_t,WORD,unsigned,jsval_t*,jsval_t*) DECLSPEC_HIDDEN;
 HRESULT Object_set_proto_(script_ctx_t*,jsval_t,WORD,unsigned,jsval_t*,jsval_t*) DECLSPEC_HIDDEN;
 
@@ -471,6 +600,66 @@ static inline DWORD make_grfdex(script_ctx_t *ctx, DWORD flags)
     return ((ctx->version & 0xff) << 28) | flags;
 }
 
+#define GC_TRAVERSE_SPECULATIVELY NULL
+#define GC_TRAVERSE_UNLINK ((void*)(INT_PTR)-1)
+
+/*
+ * During unlinking (GC_TRAVERSE_UNLINK), it is important that we unlink *all* linked objects from the
+ * object, to be certain that releasing the object later will not release any other objects. Otherwise
+ * calculating the "next" object in the list becomes impossible and can lead to already freed objects.
+ */
+static inline HRESULT gc_process_linked_obj(jsdisp_t *obj, jsdisp_t *link, void **unlink_ref, void *arg)
+{
+    if(arg == GC_TRAVERSE_UNLINK) {
+        *unlink_ref = NULL;
+        jsdisp_release(link);
+        return S_OK;
+    }
+
+    if(link->ctx != obj->ctx)
+        return S_OK;
+    if(arg == GC_TRAVERSE_SPECULATIVELY)
+        link->ref--;
+    else if(link->gc_marked)
+        return heap_stack_push(arg, link);
+    return S_OK;
+}
+
+static inline HRESULT gc_process_linked_val(jsdisp_t *obj, jsval_t *link, void *arg)
+{
+    jsdisp_t *jsdisp;
+
+    if(arg == GC_TRAVERSE_UNLINK) {
+        jsval_t val = *link;
+        *link = jsval_undefined();
+        jsval_release(val);
+        return S_OK;
+    }
+
+    if(!is_object_instance(*link) || !(jsdisp = to_jsdisp(get_object(*link))) || jsdisp->ctx != obj->ctx)
+        return S_OK;
+    if(arg == GC_TRAVERSE_SPECULATIVELY)
+        jsdisp->ref--;
+    else if(jsdisp->gc_marked)
+        return heap_stack_push(arg, jsdisp);
+    return S_OK;
+}
+
+static inline HRESULT gc_process_linked_disp(jsdisp_t *obj, IDispatch **link, void *arg)
+{
+    jsdisp_t *jsdisp;
+
+    if(arg == GC_TRAVERSE_UNLINK) {
+        IDispatch *disp = *link;
+        *link = NULL;
+        IDispatch_Release(disp);
+        return S_OK;
+    }
+
+    jsdisp = to_jsdisp(*link);
+    return jsdisp ? gc_process_linked_obj(obj, jsdisp, (void**)link, arg) : S_OK;
+}
+
 #define FACILITY_JSCRIPT 10
 
 #define MAKE_JSERROR(code) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_JSCRIPT, code)
@@ -484,6 +673,7 @@ static inline DWORD make_grfdex(script_ctx_t *ctx, DWORD flags)
 #define JS_E_INVALID_PROPERTY        MAKE_JSERROR(IDS_NO_PROPERTY)
 #define JS_E_INVALID_ACTION          MAKE_JSERROR(IDS_UNSUPPORTED_ACTION)
 #define JS_E_MISSING_ARG             MAKE_JSERROR(IDS_ARG_NOT_OPT)
+#define JS_E_OBJECT_NOT_COLLECTION   MAKE_JSERROR(IDS_OBJECT_NOT_COLLECTION)
 #define JS_E_SYNTAX                  MAKE_JSERROR(IDS_SYNTAX_ERROR)
 #define JS_E_MISSING_SEMICOLON       MAKE_JSERROR(IDS_SEMICOLON)
 #define JS_E_MISSING_LBRACKET        MAKE_JSERROR(IDS_LBRACKET)
@@ -501,6 +691,7 @@ static inline DWORD make_grfdex(script_ctx_t *ctx, DWORD flags)
 #define JS_E_DISABLED_CC             MAKE_JSERROR(IDS_DISABLED_CC)
 #define JS_E_EXPECTED_AT             MAKE_JSERROR(IDS_EXPECTED_AT)
 #define JS_E_FUNCTION_EXPECTED       MAKE_JSERROR(IDS_NOT_FUNC)
+#define JS_E_STRING_EXPECTED         MAKE_JSERROR(IDS_NOT_STRING)
 #define JS_E_DATE_EXPECTED           MAKE_JSERROR(IDS_NOT_DATE)
 #define JS_E_NUMBER_EXPECTED         MAKE_JSERROR(IDS_NOT_NUM)
 #define JS_E_OBJECT_EXPECTED         MAKE_JSERROR(IDS_OBJECT_EXPECTED)
@@ -518,6 +709,7 @@ static inline DWORD make_grfdex(script_ctx_t *ctx, DWORD flags)
 #define JS_E_INVALID_URI_CHAR        MAKE_JSERROR(IDS_URI_INVALID_CHAR)
 #define JS_E_FRACTION_DIGITS_OUT_OF_RANGE MAKE_JSERROR(IDS_FRACTION_DIGITS_OUT_OF_RANGE)
 #define JS_E_PRECISION_OUT_OF_RANGE  MAKE_JSERROR(IDS_PRECISION_OUT_OF_RANGE)
+#define JS_E_ARRAY_OR_ARGS_EXPECTED  MAKE_JSERROR(IDS_ARRAY_OR_ARGS_EXPECTED)
 #define JS_E_INVALID_LENGTH          MAKE_JSERROR(IDS_INVALID_LENGTH)
 #define JS_E_ARRAY_EXPECTED          MAKE_JSERROR(IDS_ARRAY_EXPECTED)
 #define JS_E_CYCLIC_PROTO_VALUE      MAKE_JSERROR(IDS_CYCLIC_PROTO_VALUE)
@@ -525,7 +717,17 @@ static inline DWORD make_grfdex(script_ctx_t *ctx, DWORD flags)
 #define JS_E_OBJECT_NONEXTENSIBLE    MAKE_JSERROR(IDS_OBJECT_NONEXTENSIBLE)
 #define JS_E_NONCONFIGURABLE_REDEFINED MAKE_JSERROR(IDS_NONCONFIGURABLE_REDEFINED)
 #define JS_E_NONWRITABLE_MODIFIED    MAKE_JSERROR(IDS_NONWRITABLE_MODIFIED)
+#define JS_E_TYPEDARRAY_BAD_CTOR_ARG MAKE_JSERROR(IDS_TYPEDARRAY_BAD_CTOR_ARG)
+#define JS_E_NOT_TYPEDARRAY          MAKE_JSERROR(IDS_NOT_TYPEDARRAY)
+#define JS_E_TYPEDARRAY_INVALID_OFFSLEN MAKE_JSERROR(IDS_TYPEDARRAY_INVALID_OFFSLEN)
+#define JS_E_TYPEDARRAY_INVALID_SUBARRAY MAKE_JSERROR(IDS_TYPEDARRAY_INVALID_SUBARRAY)
+#define JS_E_TYPEDARRAY_INVALID_SOURCE MAKE_JSERROR(IDS_TYPEDARRAY_INVALID_SOURCE)
+#define JS_E_NOT_DATAVIEW            MAKE_JSERROR(IDS_NOT_DATAVIEW)
+#define JS_E_DATAVIEW_NO_ARGUMENT    MAKE_JSERROR(IDS_DATAVIEW_NO_ARGUMENT)
+#define JS_E_DATAVIEW_INVALID_ACCESS MAKE_JSERROR(IDS_DATAVIEW_INVALID_ACCESS)
+#define JS_E_DATAVIEW_INVALID_OFFSET MAKE_JSERROR(IDS_DATAVIEW_INVALID_OFFSET)
 #define JS_E_WRONG_THIS              MAKE_JSERROR(IDS_WRONG_THIS)
+#define JS_E_ARRAYBUFFER_EXPECTED    MAKE_JSERROR(IDS_ARRAYBUFFER_EXPECTED)
 #define JS_E_PROP_DESC_MISMATCH      MAKE_JSERROR(IDS_PROP_DESC_MISMATCH)
 #define JS_E_INVALID_WRITABLE_PROP_DESC MAKE_JSERROR(IDS_INVALID_WRITABLE_PROP_DESC)
 
@@ -537,6 +739,7 @@ static inline BOOL is_jscript_error(HRESULT hres)
 const char *debugstr_jsval(const jsval_t) DECLSPEC_HIDDEN;
 
 HRESULT create_jscript_object(BOOL,REFIID,void**) DECLSPEC_HIDDEN;
+script_ctx_t *get_script_ctx(IActiveScript*) DECLSPEC_HIDDEN;
 
 extern LONG module_ref DECLSPEC_HIDDEN;
 
@@ -549,3 +752,5 @@ static inline void unlock_module(void)
 {
     InterlockedDecrement(&module_ref);
 }
+
+HRESULT WINAPI WineDispatchProxyCbPrivate_GetRandomValues(IDispatch*) DECLSPEC_HIDDEN;
diff --git a/dlls/jscript/jscript.rc b/dlls/jscript/jscript.rc
index de21a4aba0b..7e4927eba0c 100644
--- a/dlls/jscript/jscript.rc
+++ b/dlls/jscript/jscript.rc
@@ -33,6 +33,7 @@ STRINGTABLE
     IDS_NO_PROPERTY         "Object doesn't support this property or method"
     IDS_UNSUPPORTED_ACTION  "Object doesn't support this action"
     IDS_ARG_NOT_OPT         "Argument not optional"
+    IDS_OBJECT_NOT_COLLECTION "Object not a collection"
     IDS_SYNTAX_ERROR        "Syntax error"
     IDS_SEMICOLON           "Expected ';'"
     IDS_LBRACKET            "Expected '('"
@@ -50,6 +51,7 @@ STRINGTABLE
     IDS_DISABLED_CC         "Conditional compilation is turned off"
     IDS_EXPECTED_AT         "Expected '@'"
     IDS_NOT_FUNC            "Function expected"
+    IDS_NOT_STRING          "'[object]' is not a string object"
     IDS_NOT_DATE            "'[object]' is not a date object"
     IDS_NOT_NUM             "Number expected"
     IDS_OBJECT_EXPECTED     "Object expected"
@@ -67,6 +69,7 @@ STRINGTABLE
     IDS_URI_INVALID_CHAR    "URI to be encoded contains invalid characters"
     IDS_FRACTION_DIGITS_OUT_OF_RANGE "Number of fraction digits is out of range"
     IDS_PRECISION_OUT_OF_RANGE "Precision is out of range"
+    IDS_ARRAY_OR_ARGS_EXPECTED "Array or arguments object expected"
     IDS_INVALID_LENGTH      "Array length must be a finite positive integer"
     IDS_ARRAY_EXPECTED      "Array object expected"
     IDS_INVALID_WRITABLE_PROP_DESC "'writable' attribute on the property descriptor cannot be set to 'true' on this object"
@@ -75,7 +78,17 @@ STRINGTABLE
     IDS_OBJECT_NONEXTENSIBLE       "Cannot define property '|': object is not extensible"
     IDS_NONCONFIGURABLE_REDEFINED  "Cannot redefine non-configurable property '|'"
     IDS_NONWRITABLE_MODIFIED       "Cannot modify non-writable property '|'"
+    IDS_NOT_TYPEDARRAY             "'this' is not a typed array object"
+    IDS_TYPEDARRAY_BAD_CTOR_ARG    "Typed array constructor argument is invalid"
+    IDS_TYPEDARRAY_INVALID_OFFSLEN "Invalid offset/length when creating typed array"
+    IDS_TYPEDARRAY_INVALID_SUBARRAY "Invalid begin/end value in typed array subarray method"
+    IDS_TYPEDARRAY_INVALID_SOURCE  "Invalid source in typed array set"
+    IDS_NOT_DATAVIEW               "'this' is not a DataView object"
+    IDS_DATAVIEW_NO_ARGUMENT       "Required argument offset or value in DataView method is not specified"
+    IDS_DATAVIEW_INVALID_ACCESS    "DataView operation access beyond specified buffer length"
+    IDS_DATAVIEW_INVALID_OFFSET    "DataView constructor argument offset is invalid"
     IDS_WRONG_THIS                 "'this' is not a | object"
+    IDS_ARRAYBUFFER_EXPECTED       "ArrayBuffer object expected"
     IDS_PROP_DESC_MISMATCH         "Property cannot have both accessors and a value"
 
     IDS_COMPILATION_ERROR   "Microsoft JScript compilation error"
diff --git a/dlls/jscript/json.c b/dlls/jscript/json.c
index dfcc39daa2a..95a6ff16bc2 100644
--- a/dlls/jscript/json.c
+++ b/dlls/jscript/json.c
@@ -267,20 +267,107 @@ static HRESULT parse_json_value(json_parse_ctx_t *ctx, jsval_t *r)
     return E_FAIL;
 }
 
+struct transform_json_object_ctx
+{
+    script_ctx_t *ctx;
+    IDispatch *reviver;
+    HRESULT hres;
+};
+
+static jsval_t transform_json_object(struct transform_json_object_ctx *proc_ctx, jsdisp_t *holder, jsstr_t *name)
+{
+    jsval_t res, args[2];
+    const WCHAR *str;
+    HRESULT hres;
+
+    if(!(str = jsstr_flatten(name)))
+        hres = E_OUTOFMEMORY;
+    else
+        hres = jsdisp_propget_name(holder, str, &args[1]);
+    if(FAILED(hres)) {
+        proc_ctx->hres = hres;
+        return jsval_undefined();
+    }
+
+    if(is_object_instance(args[1])) {
+        jsdisp_t *obj = as_jsdisp(get_object(args[1]));
+        jsstr_t *jsstr;
+        DISPID id;
+        BOOL b;
+
+        if(is_class(obj, JSCLASS_ARRAY)) {
+            unsigned i, length = array_get_length(obj);
+            WCHAR buf[14], *buf_end;
+
+            buf_end = buf + ARRAY_SIZE(buf) - 1;
+            *buf_end-- = 0;
+            for(i = 0; i < length; i++) {
+                str = idx_to_str(i, buf_end);
+                if(!(jsstr = jsstr_alloc(str))) {
+                    hres = E_OUTOFMEMORY;
+                    break;
+                }
+                res = transform_json_object(proc_ctx, obj, jsstr);
+                jsstr_release(jsstr);
+                if(is_undefined(res)) {
+                    if(proc_ctx->hres != S_OK)
+                        return res;
+                    hres = jsdisp_get_id(obj, str, 0, &id);
+                    if(FAILED(hres))
+                        continue;
+                    hres = disp_delete((IDispatch*)&obj->IDispatchEx_iface, id, &b);
+                }else {
+                    hres = jsdisp_define_data_property(obj, str, PROPF_WRITABLE | PROPF_ENUMERABLE | PROPF_CONFIGURABLE, res);
+                    jsval_release(res);
+                }
+                if(FAILED(hres))
+                    break;
+            }
+        }else {
+            id = DISPID_STARTENUM;
+            do {
+                hres = jsdisp_next_prop(obj, id, JSDISP_ENUM_OWN_ENUMERABLE, &id);
+                if(hres != S_OK || FAILED(hres = jsdisp_get_prop_name(obj, id, &jsstr)))
+                    break;
+                res = transform_json_object(proc_ctx, obj, jsstr);
+                if(is_undefined(res))
+                    hres = (proc_ctx->hres != S_OK) ? proc_ctx->hres : disp_delete((IDispatch*)&obj->IDispatchEx_iface, id, &b);
+                else {
+                    if(!(str = jsstr_flatten(jsstr)))
+                        hres = E_OUTOFMEMORY;
+                    else
+                        hres = jsdisp_define_data_property(obj, str, PROPF_WRITABLE | PROPF_ENUMERABLE | PROPF_CONFIGURABLE, res);
+                    jsval_release(res);
+                }
+                jsstr_release(jsstr);
+            } while(SUCCEEDED(hres));
+        }
+        if(FAILED(hres)) {
+            proc_ctx->hres = hres;
+            return jsval_undefined();
+        }
+    }
+
+    args[0] = jsval_string(name);
+    hres = disp_call_value(proc_ctx->ctx, proc_ctx->reviver, (IDispatch*)&holder->IDispatchEx_iface,
+                           DISPATCH_METHOD, ARRAY_SIZE(args), args, &res);
+    if(FAILED(hres)) {
+        proc_ctx->hres = hres;
+        return jsval_undefined();
+    }
+    return res;
+}
+
 /* ECMA-262 5.1 Edition    15.12.2 */
 static HRESULT JSON_parse(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv, jsval_t *r)
 {
     json_parse_ctx_t parse_ctx;
     const WCHAR *buf;
+    jsdisp_t *root;
     jsstr_t *str;
     jsval_t ret;
     HRESULT hres;
 
-    if(argc != 1) {
-        FIXME("Unsupported args\n");
-        return E_INVALIDARG;
-    }
-
     hres = to_flat_string(ctx, argv[0], &str, &buf);
     if(FAILED(hres))
         return hres;
@@ -296,8 +383,35 @@ static HRESULT JSON_parse(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned
         hres = E_FAIL;
     }
     jsstr_release(str);
-    if(FAILED(hres))
+    if(FAILED(hres)) {
+        jsval_release(ret);
         return hres;
+    }
+
+    /* FIXME: check IsCallable */
+    if(argc > 1 && is_object_instance(argv[1])) {
+        hres = create_object(ctx, NULL, &root);
+        if(FAILED(hres)) {
+            jsval_release(ret);
+            return hres;
+        }
+        hres = jsdisp_define_data_property(root, L"", PROPF_WRITABLE | PROPF_ENUMERABLE | PROPF_CONFIGURABLE, ret);
+        jsval_release(ret);
+
+        if(SUCCEEDED(hres)) {
+            struct transform_json_object_ctx proc_ctx = { ctx, get_object(argv[1]), S_OK };
+            if(!(str = jsstr_alloc(L"")))
+                hres = E_OUTOFMEMORY;
+            else {
+                ret = transform_json_object(&proc_ctx, root, str);
+                jsstr_release(str);
+                hres = proc_ctx.hres;
+            }
+        }
+        jsdisp_release(root);
+        if(FAILED(hres))
+            return hres;
+    }
 
     if(r)
         *r = ret;
diff --git a/dlls/jscript/jsregexp.c b/dlls/jscript/jsregexp.c
index 15ebb113d30..bfcbd6c70ae 100644
--- a/dlls/jscript/jsregexp.c
+++ b/dlls/jscript/jsregexp.c
@@ -548,6 +548,11 @@ static void RegExp_destructor(jsdisp_t *dispex)
     heap_free(This);
 }
 
+static HRESULT RegExp_gc_traverse(jsdisp_t *dispex, void *arg)
+{
+    return gc_process_linked_val(dispex, &regexp_from_jsdisp(dispex)->last_index_val, arg);
+}
+
 static const builtin_prop_t RegExp_props[] = {
     {L"exec",                RegExp_exec,                  PROPF_METHOD|1},
     {L"global",              NULL,0,                       RegExp_get_global},
@@ -565,7 +570,11 @@ static const builtin_info_t RegExp_info = {
     ARRAY_SIZE(RegExp_props),
     RegExp_props,
     RegExp_destructor,
-    NULL
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    RegExp_gc_traverse
 };
 
 static const builtin_prop_t RegExpInst_props[] = {
@@ -582,7 +591,11 @@ static const builtin_info_t RegExpInst_info = {
     ARRAY_SIZE(RegExpInst_props),
     RegExpInst_props,
     RegExp_destructor,
-    NULL
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    RegExp_gc_traverse
 };
 
 static HRESULT alloc_regexp(script_ctx_t *ctx, jsdisp_t *object_prototype, RegExpInstance **ret)
diff --git a/dlls/jscript/jsutils.c b/dlls/jscript/jsutils.c
index 3251abfddbf..d8ba8ad5680 100644
--- a/dlls/jscript/jsutils.c
+++ b/dlls/jscript/jsutils.c
@@ -179,6 +179,41 @@ heap_pool_t *heap_pool_mark(heap_pool_t *heap)
     return heap;
 }
 
+enum { HEAP_STACK_CHUNK_SIZE = 1020 };
+
+HRESULT heap_stack_push(struct heap_stack *heap_stack, void *value)
+{
+    if(!heap_stack->idx) {
+        if(heap_stack->next)
+            heap_stack->chunk = heap_stack->next;
+        else {
+            void **prev, **tmp = heap_alloc((HEAP_STACK_CHUNK_SIZE + 1) * sizeof(void*));
+            if(!tmp)
+                return E_OUTOFMEMORY;
+            prev = heap_stack->chunk;
+            heap_stack->chunk = tmp;
+            heap_stack->chunk[HEAP_STACK_CHUNK_SIZE] = prev;
+        }
+        heap_stack->idx = HEAP_STACK_CHUNK_SIZE;
+        heap_stack->next = NULL;
+    }
+    heap_stack->chunk[--heap_stack->idx] = value;
+    return S_OK;
+}
+
+void *heap_stack_pop(struct heap_stack *heap_stack)
+{
+    void *ret = heap_stack->chunk[heap_stack->idx];
+
+    if(++heap_stack->idx == HEAP_STACK_CHUNK_SIZE) {
+        free(heap_stack->next);
+        heap_stack->next = heap_stack->chunk;
+        heap_stack->chunk = heap_stack->chunk[HEAP_STACK_CHUNK_SIZE];
+        heap_stack->idx = 0;
+    }
+    return ret;
+}
+
 void jsval_release(jsval_t val)
 {
     switch(jsval_type(val)) {
@@ -286,7 +321,7 @@ HRESULT variant_to_jsval(script_ctx_t *ctx, VARIANT *var, jsval_t *r)
         }
         IDispatch_AddRef(V_DISPATCH(var));
         *r = jsval_disp(V_DISPATCH(var));
-        return S_OK;
+        return convert_to_proxy(ctx, r);
     }
     case VT_I1:
         *r = jsval_number(V_I1(var));
@@ -330,7 +365,7 @@ HRESULT variant_to_jsval(script_ctx_t *ctx, VARIANT *var, jsval_t *r)
             hres = IUnknown_QueryInterface(V_UNKNOWN(var), &IID_IDispatch, (void**)&disp);
             if(SUCCEEDED(hres)) {
                 *r = jsval_disp(disp);
-                return S_OK;
+                return convert_to_proxy(ctx, r);
             }
         }else {
             *r = ctx->html_mode ? jsval_null() : jsval_null_disp();
@@ -344,6 +379,9 @@ HRESULT variant_to_jsval(script_ctx_t *ctx, VARIANT *var, jsval_t *r)
 
 HRESULT jsval_to_variant(jsval_t val, VARIANT *retv)
 {
+    jsdisp_t *jsdisp;
+    IDispatch *disp;
+
     switch(jsval_type(val)) {
     case JSV_UNDEFINED:
         V_VT(retv) = VT_EMPTY;
@@ -357,9 +395,14 @@ HRESULT jsval_to_variant(jsval_t val, VARIANT *retv)
         V_VT(retv) = VT_NULL;
         return S_OK;
     case JSV_OBJECT:
+        disp = get_object(val);
+        jsdisp = to_jsdisp(disp);
+        if(jsdisp && jsdisp->proxy)
+            disp = (IDispatch*)jsdisp->proxy;
+
+        IDispatch_AddRef(disp);
         V_VT(retv) = VT_DISPATCH;
-        V_DISPATCH(retv) = get_object(val);
-        IDispatch_AddRef(get_object(val));
+        V_DISPATCH(retv) = disp;
         return S_OK;
     case JSV_STRING:
         V_VT(retv) = VT_BSTR;
@@ -390,6 +433,24 @@ HRESULT jsval_to_variant(jsval_t val, VARIANT *retv)
     return E_FAIL;
 }
 
+static HRESULT proxy_tostring(jsdisp_t *jsdisp, jsval_t *ret)
+{
+    jsstr_t *str;
+    HRESULT hres;
+    BSTR bstr;
+
+    /* Proxy prototype with custom toString fails when called on itself */
+    hres = jsdisp->proxy->lpVtbl->ToString(jsdisp->proxy, &bstr);
+    if(FAILED(hres))
+        return hres;
+    str = jsstr_alloc(bstr);
+    SysFreeString(bstr);
+    if(!str)
+        return E_OUTOFMEMORY;
+    *ret = jsval_string(str);
+    return S_OK;
+}
+
 /* ECMA-262 3rd Edition    9.1 */
 HRESULT to_primitive(script_ctx_t *ctx, jsval_t val, jsval_t *ret, hint_t hint)
 {
@@ -412,8 +473,11 @@ HRESULT to_primitive(script_ctx_t *ctx, jsval_t val, jsval_t *ret, hint_t hint)
         if(SUCCEEDED(hres)) {
             hres = jsdisp_call(jsdisp, id, DISPATCH_METHOD, 0, NULL, &prim);
             if(FAILED(hres)) {
-                WARN("call error - forwarding exception\n");
+                if(hres == E_UNEXPECTED && jsdisp->proxy)
+                    hres = proxy_tostring(jsdisp, ret);
                 jsdisp_release(jsdisp);
+                if(FAILED(hres))
+                    WARN("call error - forwarding exception\n");
                 return hres;
             }else if(!is_object_instance(prim)) {
                 jsdisp_release(jsdisp);
@@ -428,8 +492,11 @@ HRESULT to_primitive(script_ctx_t *ctx, jsval_t val, jsval_t *ret, hint_t hint)
         if(SUCCEEDED(hres)) {
             hres = jsdisp_call(jsdisp, id, DISPATCH_METHOD, 0, NULL, &prim);
             if(FAILED(hres)) {
-                WARN("call error - forwarding exception\n");
+                if(hres == E_UNEXPECTED && jsdisp->proxy)
+                    hres = proxy_tostring(jsdisp, ret);
                 jsdisp_release(jsdisp);
+                if(FAILED(hres))
+                    WARN("call error - forwarding exception\n");
                 return hres;
             }else if(!is_object_instance(prim)) {
                 jsdisp_release(jsdisp);
@@ -949,6 +1016,14 @@ HRESULT variant_change_type(script_ctx_t *ctx, VARIANT *dst, VARIANT *src, VARTY
     case VT_NULL:
         hres = V_VT(src) == VT_NULL ? S_OK : E_NOTIMPL;
         break;
+    case VT_UNKNOWN:
+    case VT_DISPATCH:
+        if(V_VT(src) == VT_EMPTY || V_VT(src) == VT_NULL) {
+            V_UNKNOWN(dst) = NULL;
+            hres = S_OK;
+            break;
+        }
+        /* fall through */
     default:
         FIXME("vt %d not implemented\n", vt);
         hres = E_NOTIMPL;
diff --git a/dlls/jscript/object.c b/dlls/jscript/object.c
index a675e45c4a0..f659c10ab5c 100644
--- a/dlls/jscript/object.c
+++ b/dlls/jscript/object.c
@@ -24,12 +24,14 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(jscript);
 
-static HRESULT Object_toString(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv,
+HRESULT Object_toString(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv,
         jsval_t *r)
 {
     jsdisp_t *jsdisp;
     const WCHAR *str;
+    BSTR bstr = NULL;
     IDispatch *disp;
+    jsstr_t *ret;
     HRESULT hres;
 
     /* Keep in sync with jsclass_t enum */
@@ -50,17 +52,31 @@ static HRESULT Object_toString(script_ctx_t *ctx, jsval_t vthis, WORD flags, uns
         L"[object Object]",
         L"[object Object]",
         L"[object Object]",
+        L"[object ArrayBuffer]",
+        L"[object Object]",
+        L"[object Int8Array]",
+        L"[object Int16Array]",
+        L"[object Int32Array]",
+        L"[object Uint8Array]",
+        L"[object Uint8ClampedArray]",
+        L"[object Uint16Array]",
+        L"[object Uint32Array]",
+        L"[object Float32Array]",
+        L"[object Float64Array]",
         L"[object Object]",
         L"[object Object]"
     };
 
     TRACE("\n");
 
+    if(!r)
+        return S_OK;
+
     if(is_undefined(vthis) || is_null(vthis)) {
         if(ctx->version < SCRIPTLANGUAGEVERSION_ES5)
             str = L"[object Object]";
         else
-            str = is_null(vthis) ? L"[object Null]" : L"[object Undefined]";
+            str = is_null(vthis) ? L"[object Null]" : L"[object Object]";
         goto set_output;
     }
 
@@ -71,6 +87,9 @@ static HRESULT Object_toString(script_ctx_t *ctx, jsval_t vthis, WORD flags, uns
     jsdisp = to_jsdisp(disp);
     if(!jsdisp) {
         str = L"[object Object]";
+    }else if(jsdisp->proxy) {
+        hres = jsdisp->proxy->lpVtbl->ToString(jsdisp->proxy, &bstr);
+        str = bstr;
     }else if(names[jsdisp->builtin_info->class]) {
         str = names[jsdisp->builtin_info->class];
     }else {
@@ -83,13 +102,11 @@ static HRESULT Object_toString(script_ctx_t *ctx, jsval_t vthis, WORD flags, uns
         return hres;
 
 set_output:
-    if(r) {
-        jsstr_t *ret;
-        ret = jsstr_alloc(str);
-        if(!ret)
-            return E_OUTOFMEMORY;
-        *r = jsval_string(ret);
-    }
+    ret = jsstr_alloc(str);
+    SysFreeString(bstr);
+    if(!ret)
+        return E_OUTOFMEMORY;
+    *r = jsval_string(ret);
 
     return S_OK;
 }
diff --git a/dlls/jscript/parser.h b/dlls/jscript/parser.h
index 9e212138480..da6b1c48ac7 100644
--- a/dlls/jscript/parser.h
+++ b/dlls/jscript/parser.h
@@ -291,6 +291,11 @@ typedef struct _parameter_t {
     struct _parameter_t *next;
 } parameter_t;
 
+struct _source_elements_t {
+    statement_t *statement;
+    statement_t *statement_tail;
+};
+
 typedef struct _function_expression_t {
     expression_t expr;
     const WCHAR *identifier;
diff --git a/dlls/jscript/parser.y b/dlls/jscript/parser.y
index fb2e1bd5929..3829b1de660 100644
--- a/dlls/jscript/parser.y
+++ b/dlls/jscript/parser.y
@@ -129,6 +129,7 @@ static expression_t *new_array_literal_expression(parser_ctx_t*,element_list_t*,
 static expression_t *new_prop_and_value_expression(parser_ctx_t*,property_list_t*);
 
 #define PARSER_LTYPE unsigned
+#define YYLTYPE unsigned
 #define YYLLOC_DEFAULT(Cur, Rhs, N) Cur = YYRHSLOC((Rhs), (N) ? 1 : 0)
 
 %}
@@ -221,7 +222,7 @@ static expression_t *new_prop_and_value_expression(parser_ctx_t*,property_list_t
 %type <expr> MemberExpression
 %type <expr> PrimaryExpression
 %type <expr> GetterSetterMethod
-%type <identifier> Identifier_opt
+%type <identifier> Identifier Identifier_opt
 %type <variable_list> VariableDeclarationList
 %type <variable_list> VariableDeclarationListNoIn
 %type <variable_declaration> VariableDeclaration
@@ -241,10 +242,11 @@ static expression_t *new_prop_and_value_expression(parser_ctx_t*,property_list_t
 %type <literal> PropertyName
 %type <literal> BooleanLiteral
 %type <ival> AssignOper
-%type <identifier> IdentifierName ReservedAsIdentifier
+%type <identifier> IdentifierName ReservedAsIdentifier ES5Keyword
 
 %nonassoc LOWER_THAN_ELSE
-%nonassoc kELSE
+%nonassoc kELSE kIN kINSTANCEOF ':'
+%nonassoc kGET kLET kSET
 
 %%
 
@@ -268,9 +270,9 @@ FunctionStatementList
 FunctionExpression
         : kFUNCTION left_bracket FormalParameterList_opt right_bracket '{' FunctionBody '}'
                                 { $$ = new_function_expression(ctx, NULL, $3, $6, NULL, ctx->begin + @1, @7 - @1 + 1); }
-        | kFUNCTION tIdentifier left_bracket FormalParameterList_opt right_bracket '{' FunctionBody '}'
+        | kFUNCTION Identifier left_bracket FormalParameterList_opt right_bracket '{' FunctionBody '}'
                                 { $$ = new_function_expression(ctx, $2, $4, $7, NULL, ctx->begin + @1, @8 - @1 + 1); }
-        | kFUNCTION tIdentifier kDCOL tIdentifier left_bracket FormalParameterList_opt right_bracket '{' FunctionBody '}'
+        | kFUNCTION Identifier kDCOL Identifier left_bracket FormalParameterList_opt right_bracket '{' FunctionBody '}'
                                 { $$ = new_function_expression(ctx, $4, $6, $9, $2, ctx->begin + @1, @10 - @1 + 1); }
 
 /* ECMA-262 10th Edition   14.1 */
@@ -279,8 +281,8 @@ FunctionBody
 
 /* ECMA-262 3rd Edition    13 */
 FormalParameterList
-        : tIdentifier           { $$ = new_parameter_list(ctx, $1); }
-        | FormalParameterList ',' tIdentifier
+        : Identifier           { $$ = new_parameter_list(ctx, $1); }
+        | FormalParameterList ',' Identifier
                                 { $$ = parameter_list_add(ctx, $1, $3); }
 
 /* ECMA-262 3rd Edition    13 */
@@ -381,12 +383,12 @@ VariableDeclarationListNoIn
 
 /* ECMA-262 3rd Edition    12.2 */
 VariableDeclaration
-        : tIdentifier Initialiser_opt
+        : Identifier Initialiser_opt
                                 { $$ = new_variable_declaration(ctx, $1, $2); }
 
 /* ECMA-262 3rd Edition    12.2 */
 VariableDeclarationNoIn
-        : tIdentifier InitialiserNoIn_opt
+        : Identifier InitialiserNoIn_opt
                                 { $$ = new_variable_declaration(ctx, $1, $2); }
 
 /* ECMA-262 3rd Edition    12.2 */
@@ -479,6 +481,12 @@ WithStatement
 LabelledStatement
         : tIdentifier ':' Statement
                                 { $$ = new_labelled_statement(ctx, @$, $1, $3); }
+        | kGET ':' Statement
+                                { $$ = new_labelled_statement(ctx, @$, $1, $3); }
+        | kSET ':' Statement
+                                { $$ = new_labelled_statement(ctx, @$, $1, $3); }
+        | kLET ':' Statement
+                                { $$ = new_labelled_statement(ctx, @$, $1, $3); }
 
 /* ECMA-262 3rd Edition    12.11 */
 SwitchStatement
@@ -527,7 +535,7 @@ TryStatement
 
 /* ECMA-262 3rd Edition    12.14 */
 Catch
-        : kCATCH left_bracket tIdentifier right_bracket Block
+        : kCATCH left_bracket Identifier right_bracket Block
                                 { $$ = new_catch_block(ctx, $3, $5); }
 
 /* ECMA-262 3rd Edition    12.14 */
@@ -786,7 +794,7 @@ ArgumentList
 /* ECMA-262 3rd Edition    11.1 */
 PrimaryExpression
         : kTHIS                 { $$ = new_expression(ctx, EXPR_THIS, 0); }
-        | tIdentifier           { $$ = new_identifier_expression(ctx, $1); }
+        | Identifier            { $$ = new_identifier_expression(ctx, $1); }
         | Literal               { $$ = new_literal_expression(ctx, $1); }
         | ArrayLiteral          { $$ = $1; }
         | ObjectLiteral         { $$ = $1; }
@@ -860,7 +868,11 @@ PropertyName
 /* ECMA-262 3rd Edition    7.6 */
 Identifier_opt
         : /* empty*/            { $$ = NULL; }
-        | tIdentifier           { $$ = $1; }
+        | Identifier            { $$ = $1; }
+
+Identifier
+        : tIdentifier           { $$ = $1; }
+        | ES5Keyword            { $$ = $1; }
 
 /* ECMA-262 5.1 Edition    7.6 */
 IdentifierName
@@ -890,15 +902,12 @@ ReservedAsIdentifier
         | kFINALLY              { $$ = $1; }
         | kFOR                  { $$ = $1; }
         | kFUNCTION             { $$ = $1; }
-        | kGET                  { $$ = $1; }
         | kIF                   { $$ = $1; }
         | kIN                   { $$ = $1; }
         | kINSTANCEOF           { $$ = $1; }
-        | kLET                  { $$ = $1; }
         | kNEW                  { $$ = $1; }
         | kNULL                 { $$ = $1; }
         | kRETURN               { $$ = $1; }
-        | kSET                  { $$ = $1; }
         | kSWITCH               { $$ = $1; }
         | kTHIS                 { $$ = $1; }
         | kTHROW                { $$ = $1; }
@@ -909,6 +918,12 @@ ReservedAsIdentifier
         | kVOID                 { $$ = $1; }
         | kWHILE                { $$ = $1; }
         | kWITH                 { $$ = $1; }
+        | ES5Keyword            { $$ = $1; }
+
+ES5Keyword
+        : kGET                  { $$ = $1; }
+        | kLET                  { $$ = $1; }
+        | kSET                  { $$ = $1; }
 
 /* ECMA-262 3rd Edition    7.8 */
 Literal
diff --git a/dlls/jscript/resource.h b/dlls/jscript/resource.h
index f84d77c198f..31822bffaea 100644
--- a/dlls/jscript/resource.h
+++ b/dlls/jscript/resource.h
@@ -31,6 +31,7 @@
 #define IDS_NO_PROPERTY                     0x01B6
 #define IDS_UNSUPPORTED_ACTION              0x01BD
 #define IDS_ARG_NOT_OPT                     0x01c1
+#define IDS_OBJECT_NOT_COLLECTION           0x01c3
 #define IDS_SYNTAX_ERROR                    0x03EA
 #define IDS_SEMICOLON                       0x03EC
 #define IDS_LBRACKET                        0x03ED
@@ -48,6 +49,7 @@
 #define IDS_DISABLED_CC                     0x0406
 #define IDS_EXPECTED_AT                     0x0408
 #define IDS_NOT_FUNC                        0x138A
+#define IDS_NOT_STRING                      0x138D
 #define IDS_NOT_DATE                        0x138E
 #define IDS_NOT_NUM                         0x1389
 #define IDS_OBJECT_EXPECTED                 0x138F
@@ -65,6 +67,7 @@
 #define IDS_URI_INVALID_CODING              0x13A1
 #define IDS_FRACTION_DIGITS_OUT_OF_RANGE    0x13A2
 #define IDS_PRECISION_OUT_OF_RANGE          0x13A3
+#define IDS_ARRAY_OR_ARGS_EXPECTED          0x13A4
 #define IDS_INVALID_LENGTH                  0x13A5
 #define IDS_ARRAY_EXPECTED                  0x13A7
 #define IDS_INVALID_WRITABLE_PROP_DESC      0x13AC
@@ -73,7 +76,17 @@
 #define IDS_OBJECT_NONEXTENSIBLE            0x13D5
 #define IDS_NONCONFIGURABLE_REDEFINED       0x13D6
 #define IDS_NONWRITABLE_MODIFIED            0x13D7
+#define IDS_TYPEDARRAY_BAD_CTOR_ARG         0x13DA
+#define IDS_NOT_TYPEDARRAY                  0x13DB
+#define IDS_TYPEDARRAY_INVALID_OFFSLEN      0x13DC
+#define IDS_TYPEDARRAY_INVALID_SUBARRAY     0x13DD
+#define IDS_TYPEDARRAY_INVALID_SOURCE       0x13DE
+#define IDS_NOT_DATAVIEW                    0x13DF
+#define IDS_DATAVIEW_NO_ARGUMENT            0x13E0
+#define IDS_DATAVIEW_INVALID_ACCESS         0x13E1
+#define IDS_DATAVIEW_INVALID_OFFSET         0x13E2
 #define IDS_WRONG_THIS                      0x13FC
+#define IDS_ARRAYBUFFER_EXPECTED            0x15E4
 /* FIXME: This is not compatible with native, but we would
  * conflict with IDS_UNSUPPORTED_ACTION otherwise */
 #define IDS_PROP_DESC_MISMATCH              0x1F00
diff --git a/dlls/jscript/set.c b/dlls/jscript/set.c
index d1ea6637956..4f58d5455d5 100644
--- a/dlls/jscript/set.c
+++ b/dlls/jscript/set.c
@@ -363,6 +363,33 @@ static void Map_destructor(jsdisp_t *dispex)
 
     heap_free(map);
 }
+
+static HRESULT Map_gc_traverse(jsdisp_t *dispex, void *arg)
+{
+    MapInstance *map = (MapInstance*)dispex;
+    struct jsval_map_entry *entry;
+    HRESULT hres;
+
+    if(arg == GC_TRAVERSE_UNLINK) {
+        while(!list_empty(&map->entries)) {
+            entry = LIST_ENTRY(list_head(&map->entries), struct jsval_map_entry, list_entry);
+            release_map_entry(entry);
+        }
+        wine_rb_destroy(&map->map, NULL, NULL);
+        return S_OK;
+    }
+
+    LIST_FOR_EACH_ENTRY(entry, &map->entries, struct jsval_map_entry, list_entry) {
+        hres = gc_process_linked_val(dispex, &entry->key, arg);
+        if(FAILED(hres))
+            return hres;
+        hres = gc_process_linked_val(dispex, &entry->value, arg);
+        if(FAILED(hres))
+            return hres;
+    }
+    return S_OK;
+}
+
 static const builtin_prop_t Map_prototype_props[] = {
     {L"clear",      Map_clear,     PROPF_METHOD},
     {L"delete" ,    Map_delete,    PROPF_METHOD|1},
@@ -391,7 +418,11 @@ static const builtin_info_t Map_info = {
     ARRAY_SIZE(Map_props),
     Map_props,
     Map_destructor,
-    NULL
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    Map_gc_traverse
 };
 
 static HRESULT Map_constructor(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv,
@@ -544,7 +575,11 @@ static const builtin_info_t Set_info = {
     ARRAY_SIZE(Map_props),
     Map_props,
     Map_destructor,
-    NULL
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    Map_gc_traverse
 };
 
 static HRESULT Set_constructor(script_ctx_t *ctx, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv,
@@ -594,7 +629,7 @@ HRESULT init_set_constructor(script_ctx_t *ctx)
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"Set", PROPF_WRITABLE,
+    hres = jsdisp_define_data_property(ctx->global, L"Set", PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                        jsval_obj(constructor));
     jsdisp_release(constructor);
     if(FAILED(hres))
@@ -609,7 +644,7 @@ HRESULT init_set_constructor(script_ctx_t *ctx)
     if(FAILED(hres))
         return hres;
 
-    hres = jsdisp_define_data_property(ctx->global, L"Map", PROPF_WRITABLE,
+    hres = jsdisp_define_data_property(ctx->global, L"Map", PROPF_CONFIGURABLE | PROPF_WRITABLE,
                                        jsval_obj(constructor));
     jsdisp_release(constructor);
     return hres;
diff --git a/dlls/jscript/string.c b/dlls/jscript/string.c
index dac89c9d8a9..37ac6b338c9 100644
--- a/dlls/jscript/string.c
+++ b/dlls/jscript/string.c
@@ -89,7 +89,7 @@ static HRESULT stringobj_to_string(jsval_t vthis, jsval_t *r)
 
     if(!(string = string_this(vthis))) {
         WARN("this is not a string object\n");
-        return E_FAIL;
+        return JS_E_STRING_EXPECTED;
     }
 
     if(r)
diff --git a/dlls/jscript/tests/api.js b/dlls/jscript/tests/api.js
index 1368f399b50..ae137377f72 100644
--- a/dlls/jscript/tests/api.js
+++ b/dlls/jscript/tests/api.js
@@ -1960,7 +1960,7 @@ ok(isNaN(tmp), "Math.tan(-Infinity) is not NaN");
         [[[,2,undefined,3,{prop:0},],undefined,"  "],"[\n  null,\n  2,\n  null,\n  3,\n  {\n    \"prop\": 0\n  },\n  null\n]"]
     ];
 
-    var i, s, v;
+    var i, s, v, t;
 
     for(i=0; i < stringify_tests.length; i++) {
         s = JSON.stringify.apply(null, stringify_tests[i][0]);
@@ -2025,7 +2025,7 @@ ok(isNaN(tmp), "Math.tan(-Infinity) is not NaN");
         for(var prop in x) {
             if(!x.hasOwnProperty(prop))
                 continue;
-            if(!x.hasOwnProperty(prop))
+            if(!y.hasOwnProperty(prop))
                 return false;
             if(!json_cmp(x[prop], y[prop]))
                 return false;
@@ -2043,6 +2043,61 @@ ok(isNaN(tmp), "Math.tan(-Infinity) is not NaN");
         v = JSON.parse(parse_tests[i][0]);
         ok(json_cmp(v, parse_tests[i][1]), "parse[" + i + "] returned " + v + ", expected " + parse_tests[i][1]);
     }
+
+    v = [ [-1, "b"], {"length": -2, "0": -4, "1": -5}, [{}], [{"x": [null]}] ];
+    s =
+    '{' +
+        '"foo": true,' +
+        '"bar": [],' +
+        '"baz": "remove_me",' +
+        '"obj": {' +
+        '    "arr": [ [1, "b"], {"length": 2, "0": 4, "1": 5}, [{}], [{"x": [null]}] ],' +
+        '    "": "empty"' +
+        '},' +
+        '"last": false' +
+    '}';
+    o = JSON.parse(s), t = JSON.parse(s), i = new Object();
+    i[""] = t;
+    delete t.baz;   /* baz gets removed */
+    t.obj.arr = v;  /* has negative values */
+
+    var walk_expect = [
+        [ o, "foo", true ],
+        [ o, "bar", [] ],
+        [ o, "baz", "remove_me" ],
+        [ [1, "b"], "0", 1 ],
+        [ [-1, "b"], "1", "b" ],
+        [ [ [-1, "b"], {"length": 2, "0": 4, "1": 5}, [{}], [{"x": [null]}] ], "0", [-1, "b"] ],
+        [ {"length": 2, "0": 4, "1": 5}, "length", 2 ],
+        [ {"length": -2, "0": 4, "1": 5}, "0", 4 ],
+        [ {"length": -2, "0": -4, "1": 5}, "1", 5 ],
+        [ v, "1", {"length": -2, "0": -4, "1": -5} ],
+        [ [{}], "0", {} ],
+        [ v, "2", [{}] ],
+        [ [null], "0", null ],
+        [ {"x": [null]}, "x", [null] ],
+        [ [{"x": [null]}], "0", {"x": [null]} ],
+        [ v, "3", [{"x": [null]}] ],
+        [ { "arr": v, "": "empty" }, "arr", v ],
+        [ { "arr": v, "": "empty" }, "", "empty" ],
+        [ t, "obj", { "arr": v, "": "empty" } ],
+        [ t, "last", false ],
+        [ i, "", t ]
+    ];
+    i = 0;
+    v = JSON.parse(s, function(prop, value) {
+        var a = [this, prop, value];
+        ok(json_cmp(a, walk_expect[i]), "[walk step " + i + "] got [" + a + "], expected [" + walk_expect[i] + "]");
+        i++;
+        return (typeof value === 'number') ? -value : (value === "remove_me" ? undefined : value);
+    });
+    ok(i === walk_expect.length, "parse with reviver walked " + i + " steps, expected " + walk_expect.length);
+    ok(json_cmp(v, t), "parse with reviver returned wrong object");
+
+    v = JSON.parse('true', function(prop, value) { return prop === "" ? undefined : value; });
+    ok(v === undefined, "parse with reviver removing last prop returned " + v);
+    v = JSON.parse('true', function(prop, value) { return prop === "" ? false : value; });
+    ok(v === false, "parse with reviver setting last prop to false returned " + v);
 })();
 
 var func = function  (a) {
@@ -2527,6 +2582,7 @@ var exception_array = {
     E_INVALID_LENGTH:  { type: "RangeError",  number: -2146823259 },
 
     E_NOT_DATE:            { type: "TypeError",   number: -2146823282 },
+    E_NOT_STRING:          { type: "TypeError",   number: -2146823283 },
     E_NOT_BOOL:            { type: "TypeError",   number: -2146823278 },
     E_ARG_NOT_OPT:         { type: "TypeError",   number: -2146827839 },
     E_NO_PROPERTY:         { type: "TypeError",   number: -2146827850 },
@@ -2597,6 +2653,7 @@ testException(function() {date.setTime();}, "E_ARG_NOT_OPT");
 testException(function() {date.setYear();}, "E_ARG_NOT_OPT");
 testException(function() {arr.test();}, "E_NO_PROPERTY");
 testException(function() {[1,2,3].sort(nullDisp);}, "E_JSCRIPT_EXPECTED");
+testException(function() {var o = new Object(); o.length = 1; o[0] = "a"; Array.prototype.toString.call(o);}, "E_NOT_ARRAY");
 testException(function() {var o = new Object(); o.length = 1; o[0] = "a"; Array.prototype.toLocaleString.call(o);}, "E_NOT_ARRAY");
 testException(function() {Number.prototype.toString.call(arr);}, "E_NOT_NUM");
 testException(function() {Number.prototype.toFixed.call(arr);}, "E_NOT_NUM");
@@ -2609,6 +2666,7 @@ testException(function() {not_existing_variable.something();}, "E_UNDEFINED");
 testException(function() {date();}, "E_NOT_FUNC");
 testException(function() {arr();}, "E_NOT_FUNC");
 testException(function() {(new Object) instanceof (new Object);}, "E_NOT_FUNC");
+testException(function() {var o = new Object(); o.prototype = new Object(); (new Object) instanceof o;}, "E_NOT_FUNC");
 testException(function() {eval("nonexistingfunc()")}, "E_OBJECT_EXPECTED");
 testException(function() {(new Object()) instanceof 3;}, "E_NOT_FUNC");
 testException(function() {(new Object()) instanceof null;}, "E_NOT_FUNC");
@@ -2616,6 +2674,8 @@ testException(function() {(new Object()) instanceof nullDisp;}, "E_NOT_FUNC");
 testException(function() {nullDisp instanceof Object;}, "E_OBJECT_EXPECTED");
 testException(function() {Function.prototype.apply.call(nullDisp, Object, []);}, "E_OBJECT_REQUIRED");
 testException(function() {Function.prototype.call.call(nullDisp, Object);}, "E_OBJECT_REQUIRED");
+testException(function() {String.prototype.toString.call(null);}, "E_NOT_STRING");
+testException(function() {String.prototype.toString.call([]);}, "E_NOT_STRING");
 testException(function() {"test" in 3;}, "E_OBJECT_EXPECTED");
 testException(function() {"test" in null;}, "E_OBJECT_EXPECTED");
 testException(function() {"test" in nullDisp;}, "E_OBJECT_EXPECTED");
@@ -2806,6 +2866,8 @@ testFunctionThis("toString");
 testFunctionThis("call");
 testFunctionThis("apply");
 
+testException(function() {(function (a, b) {}).apply(null, testObj)}, "E_JSCRIPT_EXPECTED");
+
 function testArrayHostThis(func) {
     testException(function() { Array.prototype[func].call(testObj); }, "E_JSCRIPT_EXPECTED");
 }
diff --git a/dlls/mshtml/binding.h b/dlls/mshtml/binding.h
index 26a337fe470..9a043864927 100644
--- a/dlls/mshtml/binding.h
+++ b/dlls/mshtml/binding.h
@@ -51,6 +51,7 @@ typedef struct {
     nsIURI *referrer;
     char *content_type;
     char *charset;
+    nsresult status;
     UINT32 response_status;
     char *response_status_text;
     REQUEST_METHOD request_method;
diff --git a/dlls/mshtml/dispex.c b/dlls/mshtml/dispex.c
index 7ab1df49cc5..3a7447837d5 100644
--- a/dlls/mshtml/dispex.c
+++ b/dlls/mshtml/dispex.c
@@ -25,6 +25,7 @@
 #include "winbase.h"
 #include "winuser.h"
 #include "ole2.h"
+#include "mshtmdid.h"
 #include "mscoree.h"
 
 #include "wine/debug.h"
@@ -84,14 +85,31 @@ typedef struct {
     DWORD flags;
 } dynamic_prop_t;
 
+struct proxy_prototype {
+    IUnknown IUnknown_iface;
+    DispatchEx dispex;
+    LONG ref;
+};
+
+struct proxy_ctor {
+    IUnknown IUnknown_iface;
+    DispatchEx dispex;
+    LONG ref;
+};
+
 #define DYNPROP_DELETED    0x01
+#define DYNPROP_PROTREF    0x02  /* V_VT(var) == VT_EMPTY and V_UI4(var) == the ref */
 
 typedef struct {
     DispatchEx dispex;
     IUnknown IUnknown_iface;
     LONG ref;
-    DispatchEx *obj;
+    union {
+        DispatchEx *obj;
+        DWORD idx;          /* index into function_props, used when info == NULL */
+    };
     func_info_t *info;
+    IDispatch *funcs[2];    /* apply, call */
 } func_disp_t;
 
 typedef struct {
@@ -125,6 +143,78 @@ PRIVATE_TID_LIST
 #undef XDIID
 };
 
+const tid_t no_iface_tids[1] = { 0 };
+static void proxy_prototype_init_dispex_info(dispex_data_t*,compat_mode_t);
+
+static struct prototype_static_data {
+    dispex_static_data_t dispex;
+    dispex_static_data_t *desc;
+} prototype_static_data[] = {
+#define X(id, name, dispex, proto_id) \
+{                                     \
+    {                                 \
+        L ## name L"Prototype",       \
+        NULL,                         \
+        PROTO_ID_ ## proto_id,        \
+        NULL_tid,                     \
+        no_iface_tids,                \
+        proxy_prototype_init_dispex_info \
+    },                                \
+    &dispex                           \
+},
+COMPAT_ONLY_PROTOTYPE_LIST
+COMPAT_PROTOTYPE_LIST
+PROXY_PROTOTYPE_LIST
+#undef X
+};
+
+static const WCHAR compat_prototype_nameW[] = L"[Interface prototype object]";
+static void compat_prototype_init_dispex_info(dispex_data_t*,compat_mode_t);
+static const dispex_static_data_vtbl_t compat_prototype_dispex_vtbl;
+
+static dispex_static_data_t compat_prototype_dispex[] = {
+#define X(id, name, dispex, proto_id) \
+{                                     \
+    compat_prototype_nameW,           \
+    &compat_prototype_dispex_vtbl,    \
+    PROTO_ID_NULL,                    \
+    NULL_tid,                         \
+    no_iface_tids,                    \
+    compat_prototype_init_dispex_info \
+},
+COMPAT_ONLY_PROTOTYPE_LIST
+COMPAT_PROTOTYPE_LIST
+#undef X
+};
+
+static const dispex_static_data_vtbl_t proxy_ctor_dispex_vtbl;
+
+static dispex_static_data_t proxy_ctor_dispex[] = {
+#define X(id, name, dispex, proto_id) \
+{                                     \
+    L ## name,                        \
+    &proxy_ctor_dispex_vtbl,          \
+    PROTO_ID_Object,                  \
+    NULL_tid,                         \
+    no_iface_tids                     \
+},
+COMPAT_PROTOTYPE_LIST
+PROXY_PROTOTYPE_LIST
+#undef X
+};
+
+static inline dispex_data_t *proxy_prototype_object_info(struct proxy_prototype *prot)
+{
+    dispex_static_data_t *desc = CONTAINING_RECORD(prot->dispex.info->desc, struct prototype_static_data, dispex)->desc;
+    return desc->info_cache[prot->dispex.info->compat_mode];
+}
+
+static func_disp_t *create_func_disp(DispatchEx*,func_info_t*);
+static HRESULT get_dynamic_prop(DispatchEx*,const WCHAR*,DWORD,dynamic_prop_t**);
+static HRESULT invoke_builtin_function(IDispatch*,func_info_t*,DISPPARAMS*,VARIANT*,EXCEPINFO*,IServiceProvider*);
+static inline BOOL is_compat_prototype(IDispatch*);
+static inline struct proxy_prototype *to_proxy_prototype(DispatchEx*);
+
 static HRESULT load_typelib(void)
 {
     WCHAR module_path[MAX_PATH + 3];
@@ -411,6 +501,32 @@ static void add_func_info(dispex_data_t *data, tid_t tid, const FUNCDESC *desc,
     }
 }
 
+static void copy_func_info(func_info_t *dst, func_info_t *src)
+{
+    unsigned i, argc = src->argc;
+
+    *dst = *src;
+    dst->name = SysAllocString(src->name);
+
+    if(src->arg_types) {
+        DWORD size = (argc + (src->prop_vt == VT_VOID ? 0 : 1)) * sizeof(*dst->arg_types);
+        dst->arg_types = heap_alloc(size);
+        if(dst->arg_types)
+            memcpy(dst->arg_types, src->arg_types, size);
+    }
+
+    if(src->arg_info) {
+        dst->arg_info = heap_alloc(argc * sizeof(*dst->arg_info));
+        if(dst->arg_info) {
+            for(i = 0; i < argc; i++) {
+                dst->arg_info[i].iid = src->arg_info[i].iid;
+                V_VT(&dst->arg_info[i].default_value) = VT_EMPTY;
+                VariantCopy(&dst->arg_info[i].default_value, &src->arg_info[i].default_value);
+            }
+        }
+    }
+}
+
 static HRESULT process_interface(dispex_data_t *data, tid_t tid, ITypeInfo *disp_typeinfo, const dispex_hook_t *hooks)
 {
     unsigned i = 7; /* skip IDispatch functions */
@@ -604,6 +720,23 @@ dispex_prop_type_t get_dispid_type(DISPID id)
     return DISPEXPROP_BUILTIN;
 }
 
+BOOL is_custom_attribute(DispatchEx *dispex, const WCHAR *name)
+{
+    func_info_t **funcs = dispex->info->name_table;
+    DWORD i, a = 0, b = dispex->info->func_cnt;
+    int c;
+
+    while(a < b) {
+        i = (a + b) / 2;
+        c = wcsicmp(funcs[i]->name, name);
+        if(!c)
+            return (funcs[i]->func_disp_idx != -1);
+        if(c > 0) b = i;
+        else      a = i + 1;
+    }
+    return TRUE;
+}
+
 static HRESULT variant_copy(VARIANT *dest, VARIANT *src)
 {
     if(V_VT(src) == VT_BSTR && !V_BSTR(src)) {
@@ -615,6 +748,26 @@ static HRESULT variant_copy(VARIANT *dest, VARIANT *src)
     return VariantCopy(dest, src);
 }
 
+static void fixup_prop_ref(DispatchEx *This, dynamic_prop_t *prop)
+{
+    dynamic_prop_t *prot_prop;
+
+    if(prop->flags & DYNPROP_DELETED) {
+        if(!This->prototype ||
+           FAILED(get_dynamic_prop(&This->prototype->dispex, prop->name, fdexNameCaseSensitive, &prot_prop)))
+            return;
+        if(!(prot_prop->flags & DYNPROP_DELETED)) {
+            prop->flags = DYNPROP_PROTREF;
+            V_UI4(&prop->var) = prot_prop - This->prototype->dispex.dynamic_data->props;
+        }
+        return;
+    }
+
+    if((prop->flags & DYNPROP_PROTREF) &&
+       (This->prototype->dispex.dynamic_data->props[V_UI4(&prop->var)].flags & DYNPROP_DELETED))
+        prop->flags = DYNPROP_DELETED;
+}
+
 static inline dispex_dynamic_data_t *get_dynamic_data(DispatchEx *This)
 {
     if(This->dynamic_data)
@@ -633,8 +786,8 @@ static inline dispex_dynamic_data_t *get_dynamic_data(DispatchEx *This)
 static HRESULT get_dynamic_prop(DispatchEx *This, const WCHAR *name, DWORD flags, dynamic_prop_t **ret)
 {
     const BOOL alloc = flags & fdexNameEnsure;
+    dynamic_prop_t *prop, *prot_prop = NULL;
     dispex_dynamic_data_t *data;
-    dynamic_prop_t *prop;
 
     data = get_dynamic_data(This);
     if(!data)
@@ -642,6 +795,7 @@ static HRESULT get_dynamic_prop(DispatchEx *This, const WCHAR *name, DWORD flags
 
     for(prop = data->props; prop < data->props+data->prop_cnt; prop++) {
         if(flags & fdexNameCaseInsensitive ? !wcsicmp(prop->name, name) : !wcscmp(prop->name, name)) {
+            fixup_prop_ref(This, prop);
             if(prop->flags & DYNPROP_DELETED) {
                 if(!alloc)
                     return DISP_E_UNKNOWNNAME;
@@ -652,7 +806,17 @@ static HRESULT get_dynamic_prop(DispatchEx *This, const WCHAR *name, DWORD flags
         }
     }
 
-    if(!alloc)
+    if(This->prototype) {
+        HRESULT hres = get_dynamic_prop(&This->prototype->dispex, name, fdexNameCaseSensitive, &prot_prop);
+        if(hres != DISP_E_UNKNOWNNAME) {
+            if(FAILED(hres))
+                return hres;
+            if(prot_prop->flags & DYNPROP_DELETED)
+                prot_prop = NULL;
+        }
+    }
+
+    if(!alloc && !prot_prop)
         return DISP_E_UNKNOWNNAME;
 
     TRACE("creating dynamic prop %s\n", debugstr_w(name));
@@ -681,6 +845,10 @@ static HRESULT get_dynamic_prop(DispatchEx *This, const WCHAR *name, DWORD flags
 
     VariantInit(&prop->var);
     prop->flags = 0;
+    if(prot_prop) {
+        prop->flags = DYNPROP_PROTREF;
+        V_UI4(&prop->var) = prot_prop - This->prototype->dispex.dynamic_data->props;
+    }
     data->prop_cnt++;
     *ret = prop;
     return S_OK;
@@ -695,6 +863,7 @@ HRESULT dispex_get_dprop_ref(DispatchEx *This, const WCHAR *name, BOOL alloc, VA
     if(FAILED(hres))
         return hres;
 
+    prop->flags &= ~DYNPROP_PROTREF;
     *ret = &prop->var;
     return S_OK;
 }
@@ -708,6 +877,7 @@ HRESULT dispex_get_dynid(DispatchEx *This, const WCHAR *name, DISPID *id)
     if(FAILED(hres))
         return hres;
 
+    prop->flags &= ~DYNPROP_PROTREF;
     *id = DISPID_DYNPROP_0 + (prop - This->dynamic_data->props);
     return S_OK;
 }
@@ -717,9 +887,6 @@ static HRESULT dispex_value(DispatchEx *This, LCID lcid, WORD flags, DISPPARAMS
 {
     HRESULT hres;
 
-    if(This->info->desc->vtbl && This->info->desc->vtbl->value)
-        return This->info->desc->vtbl->value(This, lcid, flags, params, res, ei, caller);
-
     switch(flags) {
     case DISPATCH_PROPERTYGET:
         V_VT(res) = VT_BSTR;
@@ -735,12 +902,11 @@ static HRESULT dispex_value(DispatchEx *This, LCID lcid, WORD flags, DISPPARAMS
     return S_OK;
 }
 
-static HRESULT typeinfo_invoke(DispatchEx *This, func_info_t *func, WORD flags, DISPPARAMS *dp, VARIANT *res,
+static HRESULT typeinfo_invoke(IUnknown *iface, func_info_t *func, WORD flags, DISPPARAMS *dp, VARIANT *res,
         EXCEPINFO *ei)
 {
     DISPPARAMS params = {dp->rgvarg, NULL, dp->cArgs, 0};
     ITypeInfo *ti;
-    IUnknown *unk;
     UINT argerr=0;
     HRESULT hres;
 
@@ -755,16 +921,7 @@ static HRESULT typeinfo_invoke(DispatchEx *This, func_info_t *func, WORD flags,
         return hres;
     }
 
-    hres = IUnknown_QueryInterface(This->outer, tid_ids[func->tid], (void**)&unk);
-    if(FAILED(hres)) {
-        ERR("Could not get iface %s: %08lx\n", debugstr_mshtml_guid(tid_ids[func->tid]), hres);
-        return E_FAIL;
-    }
-
-    hres = ITypeInfo_Invoke(ti, unk, func->id, flags, &params, res, ei, &argerr);
-
-    IUnknown_Release(unk);
-    return hres;
+    return ITypeInfo_Invoke(ti, iface, func->id, flags, &params, res, ei, &argerr);
 }
 
 static inline func_disp_t *impl_from_IUnknown(IUnknown *iface)
@@ -805,11 +962,15 @@ static ULONG WINAPI Function_Release(IUnknown *iface)
 {
     func_disp_t *This = impl_from_IUnknown(iface);
     LONG ref = InterlockedDecrement(&This->ref);
+    unsigned i;
 
     TRACE("(%p) ref=%ld\n", This, ref);
 
     if(!ref) {
-        assert(!This->obj);
+        assert(!This->info || !This->obj);
+        for(i = 0; i < ARRAY_SIZE(This->funcs); i++)
+            if(This->funcs[i])
+                IDispatch_Release(This->funcs[i]);
         release_dispex(&This->dispex);
         heap_free(This);
     }
@@ -823,6 +984,148 @@ static const IUnknownVtbl FunctionUnkVtbl = {
     Function_Release
 };
 
+static HRESULT function_apply(func_disp_t *func, DISPPARAMS *dp, LCID lcid, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+{
+    IDispatchEx *dispex = NULL;
+    DISPPARAMS params = { 0 };
+    HRESULT hres, errcode;
+    IDispatch *this_obj;
+    DISPID dispid;
+    UINT argc = 0;
+    VARIANT *arg;
+    VARIANT var;
+
+    arg = dp->rgvarg + dp->cArgs - 1;
+    if(dp->cArgs < 1 || V_VT(arg) != VT_DISPATCH || !V_DISPATCH(arg))
+        return CTL_E_ILLEGALFUNCTIONCALL;
+    this_obj = V_DISPATCH(arg);
+
+    errcode = is_compat_prototype(this_obj) ? MSHTML_E_INVALID_PROPERTY : CTL_E_ILLEGALFUNCTIONCALL;
+
+    if(dp->cArgs >= 2) {
+        UINT i, err = 0;
+        IDispatch *disp;
+        BSTR name;
+
+        arg--;
+        if((V_VT(arg) & ~VT_BYREF) != VT_DISPATCH)
+            return errcode;
+        disp = (V_VT(arg) & VT_BYREF) ? *(IDispatch**)(V_BYREF(arg)) : V_DISPATCH(arg);
+
+        /* get the array length */
+        if(!(name = SysAllocString(L"length")))
+            return E_OUTOFMEMORY;
+
+        hres = IDispatch_QueryInterface(disp, &IID_IDispatchEx, (void**)&dispex);
+        if(SUCCEEDED(hres) && dispex)
+            hres = IDispatchEx_GetDispID(dispex, name, fdexNameCaseSensitive, &dispid);
+        else {
+            hres = IDispatch_GetIDsOfNames(disp, &IID_NULL, &name, 1, 0, &dispid);
+            dispex = NULL;
+        }
+        SysFreeString(name);
+        if(FAILED(hres) || dispid == DISPID_UNKNOWN) {
+            hres = errcode;
+            goto fail;
+        }
+
+        if(dispex)
+            hres = IDispatchEx_InvokeEx(dispex, dispid, lcid, DISPATCH_PROPERTYGET, &params, res, ei, caller);
+        else
+            hres = IDispatch_Invoke(disp, dispid, &IID_NULL, lcid, DISPATCH_PROPERTYGET, &params, res, ei, &err);
+        if(FAILED(hres))
+            goto fail;
+
+        if(V_VT(res) == VT_I4)
+            V_I4(&var) = V_I4(res);
+        else {
+            V_VT(&var) = VT_EMPTY;
+            hres = change_type(&var, res, VT_I4, caller);
+        }
+        VariantClear(res);
+        if(FAILED(hres) || V_I4(&var) < 0) {
+            hres = errcode;
+            goto fail;
+        }
+        params.cArgs = V_I4(&var);
+
+        /* alloc new params */
+        if(params.cArgs) {
+            if(!(params.rgvarg = heap_alloc(params.cArgs * sizeof(VARIANTARG)))) {
+                hres = E_OUTOFMEMORY;
+                goto fail;
+            }
+            for(i = 0; i < params.cArgs; i++) {
+                WCHAR buf[12];
+
+                arg = params.rgvarg + params.cArgs - i - 1;
+                swprintf(buf, ARRAY_SIZE(buf), L"%u", i);
+                if(!(name = SysAllocString(buf))) {
+                    hres = E_OUTOFMEMORY;
+                    break;
+                }
+                if(dispex)
+                    hres = IDispatchEx_GetDispID(dispex, name, fdexNameCaseSensitive, &dispid);
+                else
+                    hres = IDispatch_GetIDsOfNames(disp, &IID_NULL, &name, 1, 0, &dispid);
+                SysFreeString(name);
+                if(FAILED(hres)) {
+                    if(hres == DISP_E_UNKNOWNNAME) {
+                        V_VT(arg) = VT_EMPTY;
+                        continue;
+                    }
+                    hres = errcode;
+                    break;
+                }
+                if(dispex)
+                    hres = IDispatchEx_InvokeEx(dispex, dispid, lcid, DISPATCH_PROPERTYGET, NULL, arg, ei, caller);
+                else
+                    hres = IDispatch_Invoke(disp, dispid, &IID_NULL, lcid, DISPATCH_PROPERTYGET, NULL, arg, ei, &err);
+                if(FAILED(hres))
+                    break;
+            }
+            argc = i;
+            if(argc < params.cArgs)
+                goto cleanup;
+        }
+    }
+
+    hres = invoke_builtin_function(this_obj, func->info, &params, res, ei, caller);
+
+cleanup:
+    while(argc--)
+        VariantClear(&params.rgvarg[params.cArgs - argc - 1]);
+    heap_free(params.rgvarg);
+fail:
+    if(dispex)
+        IDispatchEx_Release(dispex);
+    return (hres == E_UNEXPECTED) ? errcode : hres;
+}
+
+static HRESULT function_call(func_disp_t *func, DISPPARAMS *dp, LCID lcid, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+{
+    DISPPARAMS params = { dp->rgvarg, NULL, dp->cArgs - 1, 0 };
+    VARIANT *arg;
+    HRESULT hres;
+
+    arg = dp->rgvarg + dp->cArgs - 1;
+    if(dp->cArgs < 1 || V_VT(arg) != VT_DISPATCH || !V_DISPATCH(arg))
+        return CTL_E_ILLEGALFUNCTIONCALL;
+
+    hres = invoke_builtin_function(V_DISPATCH(arg), func->info, &params, res, ei, caller);
+
+    return (hres != E_UNEXPECTED) ? hres :
+           (is_compat_prototype(V_DISPATCH(arg)) ? MSHTML_E_INVALID_PROPERTY : CTL_E_ILLEGALFUNCTIONCALL);
+}
+
+static const struct {
+    const WCHAR *name;
+    HRESULT (*invoke)(func_disp_t*,DISPPARAMS*,LCID,VARIANT*,EXCEPINFO*,IServiceProvider*);
+} function_props[] = {
+    { L"apply", function_apply },
+    { L"call",  function_call }
+};
+
 static inline func_disp_t *impl_from_DispatchEx(DispatchEx *iface)
 {
     return CONTAINING_RECORD(iface, func_disp_t, dispex);
@@ -835,14 +1138,18 @@ static HRESULT function_value(DispatchEx *dispex, LCID lcid, WORD flags, DISPPAR
     HRESULT hres;
 
     switch(flags) {
+    case DISPATCH_CONSTRUCT:
+        return MSHTML_E_INVALID_PROPERTY;
     case DISPATCH_METHOD|DISPATCH_PROPERTYGET:
         if(!res)
             return E_INVALIDARG;
         /* fall through */
     case DISPATCH_METHOD:
+        if(!This->info)
+            return MSHTML_E_INVALID_PROPERTY;
         if(!This->obj)
             return E_UNEXPECTED;
-        hres = dispex_call_builtin(This->obj, This->info->id, params, res, ei, caller);
+        hres = invoke_builtin_function((IDispatch*)&This->obj->IDispatchEx_iface, This->info, params, res, ei, caller);
         break;
     case DISPATCH_PROPERTYGET: {
         unsigned name_len;
@@ -858,7 +1165,7 @@ static HRESULT function_value(DispatchEx *dispex, LCID lcid, WORD flags, DISPPAR
         if(!caller)
             return E_ACCESSDENIED;
 
-        name_len = SysStringLen(This->info->name);
+        name_len = This->info ? SysStringLen(This->info->name) : wcslen(function_props[This->idx].name);
         ptr = str = SysAllocStringLen(NULL, name_len + ARRAY_SIZE(func_prefixW) + ARRAY_SIZE(func_suffixW));
         if(!str)
             return E_OUTOFMEMORY;
@@ -866,7 +1173,7 @@ static HRESULT function_value(DispatchEx *dispex, LCID lcid, WORD flags, DISPPAR
         memcpy(ptr, func_prefixW, sizeof(func_prefixW));
         ptr += ARRAY_SIZE(func_prefixW);
 
-        memcpy(ptr, This->info->name, name_len*sizeof(WCHAR));
+        memcpy(ptr, This->info ? This->info->name : function_props[This->idx].name, name_len*sizeof(WCHAR));
         ptr += name_len;
 
         memcpy(ptr, func_suffixW, sizeof(func_suffixW));
@@ -883,20 +1190,73 @@ static HRESULT function_value(DispatchEx *dispex, LCID lcid, WORD flags, DISPPAR
     return hres;
 }
 
+static HRESULT function_get_dispid(DispatchEx *dispex, BSTR name, DWORD flags, DISPID *dispid)
+{
+    func_disp_t *This = impl_from_DispatchEx(dispex);
+    DWORD i;
+
+    for(i = 0; i < ARRAY_SIZE(function_props); i++) {
+        if((flags & fdexNameCaseInsensitive) ? wcsicmp(name, function_props[i].name) : wcscmp(name, function_props[i].name))
+            continue;
+
+        /* can't chain apply/call */
+        if(!This->info)
+            return DISP_E_UNKNOWNNAME;
+
+        *dispid = MSHTML_DISPID_CUSTOM_MIN + i;
+        return S_OK;
+    }
+    return DISP_E_UNKNOWNNAME;
+}
+
+static HRESULT function_invoke(DispatchEx *dispex, IDispatch *this_obj, DISPID id, LCID lcid, WORD flags,
+        DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+{
+    func_disp_t *This = impl_from_DispatchEx(dispex);
+    DWORD idx = id - MSHTML_DISPID_CUSTOM_MIN;
+
+    if(idx >= ARRAY_SIZE(function_props) || !This->info)
+        return DISP_E_MEMBERNOTFOUND;
+
+    switch(flags) {
+    case DISPATCH_METHOD|DISPATCH_PROPERTYGET:
+        if(!res)
+            return E_INVALIDARG;
+        /* fall through */
+    case DISPATCH_METHOD:
+        return function_props[idx].invoke(This, params, lcid, res, ei, caller);
+    case DISPATCH_PROPERTYGET:
+        if(!This->funcs[idx]) {
+            func_disp_t *disp = create_func_disp(dispex, NULL);
+            if(!disp)
+                return E_OUTOFMEMORY;
+            disp->idx = idx;
+            This->funcs[idx] = (IDispatch*)&disp->dispex.IDispatchEx_iface;
+        }
+        V_VT(res) = VT_DISPATCH;
+        V_DISPATCH(res) = This->funcs[idx];
+        IDispatch_AddRef(This->funcs[idx]);
+        break;
+    default:
+        return MSHTML_E_INVALID_PROPERTY;
+    }
+
+    return S_OK;
+}
+
 static const dispex_static_data_vtbl_t function_dispex_vtbl = {
     function_value,
-    NULL,
-    NULL,
+    function_get_dispid,
+    function_invoke,
     NULL
 };
 
-static const tid_t function_iface_tids[] = {0};
-
 static dispex_static_data_t function_dispex = {
     L"Function",
     &function_dispex_vtbl,
+    PROTO_ID_NULL,
     NULL_tid,
-    function_iface_tids
+    no_iface_tids
 };
 
 static func_disp_t *create_func_disp(DispatchEx *obj, func_info_t *info)
@@ -908,7 +1268,7 @@ static func_disp_t *create_func_disp(DispatchEx *obj, func_info_t *info)
         return NULL;
 
     ret->IUnknown_iface.lpVtbl = &FunctionUnkVtbl;
-    init_dispatch(&ret->dispex, &ret->IUnknown_iface,  &function_dispex, dispex_compat_mode(obj));
+    init_dispatch(&ret->dispex, &ret->IUnknown_iface,  &function_dispex, NULL, dispex_compat_mode(obj));
     ret->ref = 1;
     ret->obj = obj;
     ret->info = info;
@@ -916,7 +1276,7 @@ static func_disp_t *create_func_disp(DispatchEx *obj, func_info_t *info)
     return ret;
 }
 
-static HRESULT invoke_disp_value(DispatchEx *This, IDispatch *func_disp, LCID lcid, WORD flags, DISPPARAMS *dp,
+static HRESULT invoke_disp_value(IDispatch *this_obj, IDispatch *func_disp, LCID lcid, WORD flags, DISPPARAMS *dp,
         VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
     DISPID named_arg = DISPID_THIS;
@@ -937,7 +1297,7 @@ static HRESULT invoke_disp_value(DispatchEx *This, IDispatch *func_disp, LCID lc
     memcpy(new_dp.rgvarg+1, dp->rgvarg, dp->cArgs*sizeof(VARIANTARG));
 
     V_VT(new_dp.rgvarg) = VT_DISPATCH;
-    V_DISPATCH(new_dp.rgvarg) = (IDispatch*)&This->IDispatchEx_iface;
+    V_DISPATCH(new_dp.rgvarg) = this_obj;
 
     hres = IDispatch_QueryInterface(func_disp, &IID_IDispatchEx, (void**)&dispex);
     TRACE(">>>\n");
@@ -957,11 +1317,33 @@ static HRESULT invoke_disp_value(DispatchEx *This, IDispatch *func_disp, LCID lc
     return hres;
 }
 
-static HRESULT get_func_obj_entry(DispatchEx *This, func_info_t *func, func_obj_entry_t **ret)
+static HRESULT get_func_obj_entry(DispatchEx *This, struct compat_prototype *prototype, func_info_t *func,
+        func_obj_entry_t **ret)
 {
     dispex_dynamic_data_t *dynamic_data;
     func_obj_entry_t *entry;
 
+    /* Use the prototype's if it's not the default while ours is */
+    if(prototype && prototype->dispex.dynamic_data && prototype->dispex.dynamic_data->func_disps &&
+       prototype->dispex.dynamic_data->func_disps[func->func_disp_idx].func_obj) {
+        func_obj_entry_t *prot_entry = prototype->dispex.dynamic_data->func_disps + func->func_disp_idx;
+
+        if(V_VT(&prot_entry->val) != VT_DISPATCH ||
+           V_DISPATCH(&prot_entry->val) != (IDispatch*)&prot_entry->func_obj->dispex.IDispatchEx_iface) {
+            entry = NULL;
+            if(This->dynamic_data && This->dynamic_data->func_disps &&
+               This->dynamic_data->func_disps[func->func_disp_idx].func_obj) {
+                entry = This->dynamic_data->func_disps + func->func_disp_idx;
+
+                if(V_VT(&entry->val) == VT_DISPATCH &&
+                   V_DISPATCH(&entry->val) == (IDispatch*)&entry->func_obj->dispex.IDispatchEx_iface)
+                    entry = NULL;
+            }
+            *ret = entry ? entry : prot_entry;
+            return S_OK;
+        }
+    }
+
     dynamic_data = get_dynamic_data(This);
     if(!dynamic_data)
         return E_OUTOFMEMORY;
@@ -1009,7 +1391,14 @@ static HRESULT get_builtin_func(dispex_data_t *data, DISPID id, func_info_t **re
     }
 
     WARN("invalid id %lx\n", id);
-    return DISP_E_UNKNOWNNAME;
+    return DISP_E_MEMBERNOTFOUND;
+}
+
+static HRESULT get_builtin_func_prot(DispatchEx *This, DISPID id, func_info_t **ret)
+{
+    if(This->proxy && !to_proxy_prototype(This) && id != DISPID_VALUE && This->info->desc->prototype_id >= 0)
+        return DISP_E_MEMBERNOTFOUND;
+    return get_builtin_func(This->info, id, ret);
 }
 
 static HRESULT get_builtin_id(DispatchEx *This, BSTR name, DWORD grfdex, DISPID *ret)
@@ -1037,17 +1426,40 @@ static HRESULT get_builtin_id(DispatchEx *This, BSTR name, DWORD grfdex, DISPID
             min = n+1;
     }
 
-    if(This->info->desc->vtbl && This->info->desc->vtbl->get_dispid) {
+    if(This->info->desc->vtbl) {
         HRESULT hres;
 
-        hres = This->info->desc->vtbl->get_dispid(This, name, grfdex, ret);
-        if(hres != DISP_E_UNKNOWNNAME)
-            return hres;
+        if(This->info->desc->vtbl->get_static_dispid) {
+            hres = This->info->desc->vtbl->get_static_dispid(dispex_compat_mode(This), name, grfdex, ret);
+            if(hres != DISP_E_UNKNOWNNAME)
+                return hres;
+        }
+
+        if(This->info->desc->vtbl->get_dispid) {
+            hres = This->info->desc->vtbl->get_dispid(This, name, grfdex, ret);
+            if(hres != DISP_E_UNKNOWNNAME)
+                return hres;
+        }
     }
 
     return DISP_E_UNKNOWNNAME;
 }
 
+static inline DispatchEx *get_dispex_for_hook(IUnknown *iface)
+{
+    IWineDispatchProxyPrivate *itf;
+    DispatchEx *dispex;
+
+    if(FAILED(IUnknown_QueryInterface(iface, &IID_IWineDispatchProxyPrivate, (void**)&itf)) || !itf)
+        return NULL;
+
+    dispex = CONTAINING_RECORD(itf->lpVtbl->GetProxyFieldRef(itf), DispatchEx, proxy);
+    IDispatchEx_AddRef(&dispex->IDispatchEx_iface);
+
+    IDispatchEx_Release((IDispatchEx*)itf);
+    return dispex;
+}
+
 HRESULT change_type(VARIANT *dst, VARIANT *src, VARTYPE vt, IServiceProvider *caller)
 {
     V_VT(dst) = VT_EMPTY;
@@ -1077,9 +1489,8 @@ HRESULT change_type(VARIANT *dst, VARIANT *src, VARTYPE vt, IServiceProvider *ca
     return VariantChangeType(dst, src, 0, vt);
 }
 
-static HRESULT builtin_propget(DispatchEx *This, func_info_t *func, DISPPARAMS *dp, VARIANT *res)
+static HRESULT builtin_propget(IUnknown *iface, func_info_t *func, DISPPARAMS *dp, VARIANT *res)
 {
-    IUnknown *iface;
     HRESULT hres;
 
     if(dp && dp->cArgs) {
@@ -1089,24 +1500,20 @@ static HRESULT builtin_propget(DispatchEx *This, func_info_t *func, DISPPARAMS *
 
     assert(func->get_vtbl_off);
 
-    hres = IUnknown_QueryInterface(This->outer, tid_ids[func->tid], (void**)&iface);
-    if(SUCCEEDED(hres)) {
-        switch(func->prop_vt) {
+    switch(func->prop_vt) {
 #define CASE_VT(vt,type,access) \
-        case vt: { \
-            type val; \
-            hres = ((HRESULT (WINAPI*)(IUnknown*,type*))((void**)iface->lpVtbl)[func->get_vtbl_off])(iface,&val); \
-            if(SUCCEEDED(hres)) \
-                access(res) = val; \
-            } \
-            break
-        BUILTIN_TYPES_SWITCH;
+    case vt: { \
+        type val; \
+        hres = ((HRESULT (WINAPI*)(IUnknown*,type*))((void**)iface->lpVtbl)[func->get_vtbl_off])(iface,&val); \
+        if(SUCCEEDED(hres)) \
+            access(res) = val; \
+        } \
+        break
+    BUILTIN_TYPES_SWITCH;
 #undef CASE_VT
-        default:
-            FIXME("Unhandled vt %d\n", func->prop_vt);
-            hres = E_NOTIMPL;
-        }
-        IUnknown_Release(iface);
+    default:
+        FIXME("Unhandled vt %d\n", func->prop_vt);
+        hres = E_NOTIMPL;
     }
 
     if(FAILED(hres))
@@ -1117,10 +1524,9 @@ static HRESULT builtin_propget(DispatchEx *This, func_info_t *func, DISPPARAMS *
     return S_OK;
 }
 
-static HRESULT builtin_propput(DispatchEx *This, func_info_t *func, DISPPARAMS *dp, IServiceProvider *caller)
+static HRESULT builtin_propput(DispatchEx *This, IUnknown *iface, func_info_t *func, DISPPARAMS *dp, IServiceProvider *caller)
 {
     VARIANT *v, tmpv;
-    IUnknown *iface;
     HRESULT hres;
 
     if(dp->cArgs != 1 || (dp->cNamedArgs == 1 && *dp->rgdispidNamedArgs != DISPID_PROPERTYPUT)
@@ -1146,21 +1552,16 @@ static HRESULT builtin_propput(DispatchEx *This, func_info_t *func, DISPPARAMS *
         v = &tmpv;
     }
 
-    hres = IUnknown_QueryInterface(This->outer, tid_ids[func->tid], (void**)&iface);
-    if(SUCCEEDED(hres)) {
-        switch(func->prop_vt) {
+    switch(func->prop_vt) {
 #define CASE_VT(vt,type,access) \
-        case vt: \
-            hres = ((HRESULT (WINAPI*)(IUnknown*,type))((void**)iface->lpVtbl)[func->put_vtbl_off])(iface,access(v)); \
-            break
-        BUILTIN_TYPES_SWITCH;
+    case vt: \
+        hres = ((HRESULT (WINAPI*)(IUnknown*,type))((void**)iface->lpVtbl)[func->put_vtbl_off])(iface,access(v)); \
+        break
+    BUILTIN_TYPES_SWITCH;
 #undef CASE_VT
-        default:
-            FIXME("Unimplemented vt %d\n", func->prop_vt);
-            hres = E_NOTIMPL;
-        }
-
-        IUnknown_Release(iface);
+    default:
+        FIXME("Unimplemented vt %d\n", func->prop_vt);
+        hres = E_NOTIMPL;
     }
 
     if(v == &tmpv)
@@ -1168,32 +1569,40 @@ static HRESULT builtin_propput(DispatchEx *This, func_info_t *func, DISPPARAMS *
     return hres;
 }
 
-static HRESULT invoke_builtin_function(DispatchEx *This, func_info_t *func, DISPPARAMS *dp,
+static HRESULT invoke_builtin_function(IDispatch *this_obj, func_info_t *func, DISPPARAMS *dp,
                                        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
     VARIANT arg_buf[MAX_ARGS], *arg_ptrs[MAX_ARGS], *arg, retv, ret_ref, vhres;
     unsigned i, nconv = 0;
+    DispatchEx *dispex;
     IUnknown *iface;
     HRESULT hres;
 
-    if(func->hook) {
-        hres = func->hook(This, DISPATCH_METHOD, dp, res, ei, caller);
-        if(hres != S_FALSE)
+    hres = IDispatch_QueryInterface(this_obj, tid_ids[func->tid], (void**)&iface);
+    if(FAILED(hres) || !iface)
+        return E_UNEXPECTED;
+
+    if(func->hook && (dispex = get_dispex_for_hook(iface))) {
+        hres = func->hook(dispex, DISPATCH_METHOD, dp, res, ei, caller);
+        IDispatchEx_Release(&dispex->IDispatchEx_iface);
+        if(hres != S_FALSE) {
+            IUnknown_Release(iface);
             return hres;
+        }
     }
 
-    if(!func->call_vtbl_off)
-        return typeinfo_invoke(This, func, DISPATCH_METHOD, dp, res, ei);
+    if(!func->call_vtbl_off) {
+        hres = typeinfo_invoke(iface, func, DISPATCH_METHOD, dp, res, ei);
+        IUnknown_Release(iface);
+        return hres;
+    }
 
     if(dp->cArgs + func->default_value_cnt < func->argc) {
         FIXME("Invalid argument count (expected %u, got %u)\n", func->argc, dp->cArgs);
+        IUnknown_Release(iface);
         return E_INVALIDARG;
     }
 
-    hres = IUnknown_QueryInterface(This->outer, tid_ids[func->tid], (void**)&iface);
-    if(FAILED(hres))
-        return hres;
-
     for(i=0; i < func->argc; i++) {
         BOOL own_value = FALSE;
         if(i >= dp->cArgs) {
@@ -1275,9 +1684,10 @@ static HRESULT invoke_builtin_function(DispatchEx *This, func_info_t *func, DISP
     return V_ERROR(&vhres);
 }
 
-static HRESULT function_invoke(DispatchEx *This, func_info_t *func, WORD flags, DISPPARAMS *dp, VARIANT *res,
+static HRESULT func_invoke(DispatchEx *This, IDispatch *this_obj, func_info_t *func, WORD flags, DISPPARAMS *dp, VARIANT *res,
         EXCEPINFO *ei, IServiceProvider *caller)
 {
+    func_obj_entry_t *entry;
     HRESULT hres;
 
     switch(flags) {
@@ -1286,10 +1696,24 @@ static HRESULT function_invoke(DispatchEx *This, func_info_t *func, WORD flags,
             return E_INVALIDARG;
         /* fall through */
     case DISPATCH_METHOD:
-        if(This->dynamic_data && This->dynamic_data->func_disps
-           && This->dynamic_data->func_disps[func->func_disp_idx].func_obj) {
-            func_obj_entry_t *entry = This->dynamic_data->func_disps + func->func_disp_idx;
+        entry = NULL;
+
+        if(This->dynamic_data && This->dynamic_data->func_disps &&
+           This->dynamic_data->func_disps[func->func_disp_idx].func_obj) {
+            entry = This->dynamic_data->func_disps + func->func_disp_idx;
+
+            if(V_VT(&entry->val) == VT_DISPATCH &&
+               V_DISPATCH(&entry->val) == (IDispatch*)&entry->func_obj->dispex.IDispatchEx_iface)
+                entry = NULL;
+        }
+
+        if(!entry && This->prototype) {
+            if(This->prototype->dispex.dynamic_data && This->prototype->dispex.dynamic_data->func_disps &&
+               This->prototype->dispex.dynamic_data->func_disps[func->func_disp_idx].func_obj)
+                entry = This->prototype->dispex.dynamic_data->func_disps + func->func_disp_idx;
+        }
 
+        if(entry) {
             if(V_VT(&entry->val) != VT_DISPATCH) {
                 FIXME("calling %s not supported\n", debugstr_variant(&entry->val));
                 return E_NOTIMPL;
@@ -1301,16 +1725,16 @@ static HRESULT function_invoke(DispatchEx *This, func_info_t *func, WORD flags,
                     return E_FAIL;
                 }
 
-                hres = invoke_disp_value(This, V_DISPATCH(&entry->val), 0, flags, dp, res, ei, NULL);
+                hres = invoke_disp_value(this_obj, V_DISPATCH(&entry->val), 0, flags, dp, res, ei, NULL);
                 break;
             }
         }
 
-        hres = invoke_builtin_function(This, func, dp, res, ei, caller);
+        hres = invoke_builtin_function(this_obj, func, dp, res, ei, caller);
+        if(hres == E_UNEXPECTED && dispex_compat_mode(This) < COMPAT_MODE_IE9)
+            hres = MSHTML_E_INVALID_PROPERTY;
         break;
-    case DISPATCH_PROPERTYGET: {
-        func_obj_entry_t *entry;
-
+    case DISPATCH_PROPERTYGET:
         if(func->id == DISPID_VALUE) {
             BSTR ret;
 
@@ -1323,16 +1747,13 @@ static HRESULT function_invoke(DispatchEx *This, func_info_t *func, WORD flags,
             return S_OK;
         }
 
-        hres = get_func_obj_entry(This, func, &entry);
+        hres = get_func_obj_entry(This, This->prototype, func, &entry);
         if(FAILED(hres))
             return hres;
 
         V_VT(res) = VT_EMPTY;
         return VariantCopy(res, &entry->val);
-    }
-    case DISPATCH_PROPERTYPUT: {
-        func_obj_entry_t *entry;
-
+    case DISPATCH_PROPERTYPUT:
         if(dp->cArgs != 1 || (dp->cNamedArgs == 1 && *dp->rgdispidNamedArgs != DISPID_PROPERTYPUT)
            || dp->cNamedArgs > 1) {
             FIXME("invalid args\n");
@@ -1345,12 +1766,11 @@ static HRESULT function_invoke(DispatchEx *This, func_info_t *func, WORD flags,
          * Native probably uses some undocumented interface in this case, but it should
          * be fine for us to allow IDispatchEx handle that.
          */
-        hres = get_func_obj_entry(This, func, &entry);
+        hres = get_func_obj_entry(This, NULL, func, &entry);
         if(FAILED(hres))
             return hres;
 
         return VariantCopy(&entry->val, dp->rgvarg);
-    }
     default:
         FIXME("Unimplemented flags %x\n", flags);
         hres = E_NOTIMPL;
@@ -1359,54 +1779,75 @@ static HRESULT function_invoke(DispatchEx *This, func_info_t *func, WORD flags,
     return hres;
 }
 
-static HRESULT invoke_builtin_prop(DispatchEx *This, DISPID id, LCID lcid, WORD flags, DISPPARAMS *dp,
-        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+static HRESULT invoke_builtin_prop(DispatchEx *This, IDispatch *this_obj, DISPID id, LCID lcid, WORD flags,
+        DISPPARAMS *dp, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
+    DispatchEx *dispex;
     func_info_t *func;
+    IUnknown *iface;
     HRESULT hres;
 
-    hres = get_builtin_func(This->info, id, &func);
-    if(id == DISPID_VALUE && hres == DISP_E_UNKNOWNNAME)
+    if(id == DISPID_VALUE && This->info->desc->vtbl && This->info->desc->vtbl->value) {
+        hres = This->info->desc->vtbl->value(This, lcid, flags, dp, res, ei, caller);
+        if(hres != S_FALSE)
+            return hres;
+    }
+
+    hres = get_builtin_func_prot(This, id, &func);
+    if(id == DISPID_VALUE && hres == DISP_E_MEMBERNOTFOUND)
         return dispex_value(This, lcid, flags, dp, res, ei, caller);
     if(FAILED(hres))
         return hres;
 
     if(func->func_disp_idx != -1)
-        return function_invoke(This, func, flags, dp, res, ei, caller);
+        return func_invoke(This, this_obj, func, flags, dp, res, ei, caller);
 
-    if(func->hook) {
-        hres = func->hook(This, flags, dp, res, ei, caller);
-        if(hres != S_FALSE)
+    hres = IDispatch_QueryInterface(this_obj, tid_ids[func->tid], (void**)&iface);
+    if(FAILED(hres) || !iface) {
+        if(dispex_compat_mode(This) >= COMPAT_MODE_IE9)
+            return E_UNEXPECTED;
+        if(res)
+            V_VT(res) = VT_EMPTY;
+        return S_OK;
+    }
+
+    if(func->hook && (dispex = get_dispex_for_hook(iface))) {
+        hres = func->hook(dispex, flags, dp, res, ei, caller);
+        IDispatchEx_Release(&dispex->IDispatchEx_iface);
+        if(hres != S_FALSE) {
+            IUnknown_Release(iface);
             return hres;
+        }
     }
 
     switch(flags) {
     case DISPATCH_PROPERTYPUT:
         if(res)
             V_VT(res) = VT_EMPTY;
-        hres = builtin_propput(This, func, dp, caller);
+        hres = builtin_propput(This, iface, func, dp, caller);
         break;
     case DISPATCH_PROPERTYGET:
-        hres = builtin_propget(This, func, dp, res);
+        hres = builtin_propget(iface, func, dp, res);
         break;
     default:
         if(!func->get_vtbl_off) {
-            hres = typeinfo_invoke(This, func, flags, dp, res, ei);
+            hres = typeinfo_invoke(iface, func, flags, dp, res, ei);
         }else {
             VARIANT v;
 
-            hres = builtin_propget(This, func, NULL, &v);
+            hres = builtin_propget(iface, func, NULL, &v);
             if(FAILED(hres))
-                return hres;
+                break;
 
             if(flags != (DISPATCH_PROPERTYGET|DISPATCH_METHOD) || dp->cArgs) {
                 if(V_VT(&v) != VT_DISPATCH) {
                     FIXME("Not a function %s flags %08x\n", debugstr_variant(&v), flags);
                     VariantClear(&v);
-                    return E_FAIL;
+                    hres = E_FAIL;
+                    break;
                 }
 
-                hres = invoke_disp_value(This, V_DISPATCH(&v), lcid, flags, dp, res, ei, caller);
+                hres = invoke_disp_value(this_obj, V_DISPATCH(&v), lcid, flags, dp, res, ei, caller);
                 IDispatch_Release(V_DISPATCH(&v));
             }else if(res) {
                 *res = v;
@@ -1416,6 +1857,7 @@ static HRESULT invoke_builtin_prop(DispatchEx *This, DISPID id, LCID lcid, WORD
         }
     }
 
+    IUnknown_Release(iface);
     return hres;
 }
 
@@ -1429,64 +1871,131 @@ HRESULT dispex_call_builtin(DispatchEx *dispex, DISPID id, DISPPARAMS *dp,
     if(FAILED(hres))
         return hres;
 
-    return invoke_builtin_function(dispex, func, dp, res, ei, caller);
+    return invoke_builtin_function((IDispatch*)&dispex->IDispatchEx_iface, func, dp, res, ei, caller);
 }
 
-HRESULT remove_attribute(DispatchEx *This, DISPID id, VARIANT_BOOL *success)
+BOOL dispex_is_builtin_attribute(DispatchEx *dispex, DISPID id)
 {
-    switch(get_dispid_type(id)) {
-    case DISPEXPROP_CUSTOM:
-        FIXME("DISPEXPROP_CUSTOM not supported\n");
-        return E_NOTIMPL;
+    func_info_t *func;
 
-    case DISPEXPROP_DYNAMIC: {
-        DWORD idx = id - DISPID_DYNPROP_0;
-        dynamic_prop_t *prop;
+    if(id == DISPID_VALUE)
+        return TRUE;
 
-        prop = This->dynamic_data->props+idx;
-        VariantClear(&prop->var);
-        prop->flags |= DYNPROP_DELETED;
-        *success = VARIANT_TRUE;
-        return S_OK;
-    }
-    case DISPEXPROP_BUILTIN: {
-        VARIANT var;
-        DISPPARAMS dp = {&var,NULL,1,0};
-        func_info_t *func;
-        HRESULT hres;
+    if(get_dispid_type(id) != DISPEXPROP_BUILTIN)
+        return FALSE;
 
-        hres = get_builtin_func(This->info, id, &func);
-        if(FAILED(hres))
-            return hres;
+    if(FAILED(get_builtin_func(dispex->info, id, &func)))
+        return FALSE;
 
-        /* For builtin functions, we set their value to the original function. */
-        if(func->func_disp_idx != -1) {
-            func_obj_entry_t *entry;
+    return func->func_disp_idx == -1;
+}
 
-            if(!This->dynamic_data || !This->dynamic_data->func_disps
-                || !This->dynamic_data->func_disps[func->func_disp_idx].func_obj) {
-                *success = VARIANT_FALSE;
-                return S_OK;
-            }
+BOOL dispex_is_builtin_method(DispatchEx *dispex, DISPID id)
+{
+    func_info_t *func;
 
-            entry = This->dynamic_data->func_disps + func->func_disp_idx;
-            if(V_VT(&entry->val) == VT_DISPATCH
-                    && V_DISPATCH(&entry->val) == (IDispatch*)&entry->func_obj->dispex.IDispatchEx_iface) {
-                *success = VARIANT_FALSE;
-                return S_OK;
-            }
+    if(get_dispid_type(id) != DISPEXPROP_BUILTIN)
+        return FALSE;
+
+    if(FAILED(get_builtin_func(dispex->info, id, &func)) || func->func_disp_idx == -1)
+        return FALSE;
+
+    if(dispex->dynamic_data && dispex->dynamic_data->func_disps) {
+        func_obj_entry_t *entry = dispex->dynamic_data->func_disps + func->func_disp_idx;
+
+        if(entry->func_obj && (V_VT(&entry->val) != VT_DISPATCH ||
+           V_DISPATCH(&entry->val) != (IDispatch*)&entry->func_obj->dispex.IDispatchEx_iface))
+            return FALSE;
+    }
+
+    return TRUE;
+}
+
+BOOL dispex_is_builtin_value(DispatchEx *dispex, DISPID id)
+{
+    func_info_t *func;
+
+    if(get_dispid_type(id) != DISPEXPROP_BUILTIN)
+        return FALSE;
+
+    if(FAILED(get_builtin_func(dispex->info, id, &func)))
+        return FALSE;
+
+    if(func->func_disp_idx == -1)
+        return TRUE;
+
+    if(dispex->dynamic_data && dispex->dynamic_data->func_disps) {
+        func_obj_entry_t *entry = dispex->dynamic_data->func_disps + func->func_disp_idx;
+
+        if(entry->func_obj && (V_VT(&entry->val) != VT_DISPATCH ||
+           V_DISPATCH(&entry->val) != (IDispatch*)&entry->func_obj->dispex.IDispatchEx_iface))
+            return FALSE;
+    }
+
+    return TRUE;
+}
+
+static VARIANT_BOOL reset_builtin_func(DispatchEx *dispex, func_info_t *func)
+{
+    func_obj_entry_t *entry;
 
-            VariantClear(&entry->val);
-            V_VT(&entry->val) = VT_DISPATCH;
-            V_DISPATCH(&entry->val) = (IDispatch*)&entry->func_obj->dispex.IDispatchEx_iface;
-            IDispatch_AddRef(V_DISPATCH(&entry->val));
-            *success = VARIANT_TRUE;
+    if(!dispex->dynamic_data || !dispex->dynamic_data->func_disps ||
+       !dispex->dynamic_data->func_disps[func->func_disp_idx].func_obj)
+        return VARIANT_FALSE;
+
+    entry = dispex->dynamic_data->func_disps + func->func_disp_idx;
+    if(V_VT(&entry->val) == VT_DISPATCH &&
+       V_DISPATCH(&entry->val) == (IDispatch*)&entry->func_obj->dispex.IDispatchEx_iface)
+        return VARIANT_FALSE;
+
+    VariantClear(&entry->val);
+    V_VT(&entry->val) = VT_DISPATCH;
+    V_DISPATCH(&entry->val) = (IDispatch*)&entry->func_obj->dispex.IDispatchEx_iface;
+    IDispatch_AddRef(V_DISPATCH(&entry->val));
+    return VARIANT_TRUE;
+}
+
+HRESULT remove_attribute(DispatchEx *This, DISPID id, VARIANT_BOOL *success)
+{
+    switch(get_dispid_type(id)) {
+    case DISPEXPROP_CUSTOM:
+        FIXME("DISPEXPROP_CUSTOM not supported\n");
+        return E_NOTIMPL;
+
+    case DISPEXPROP_DYNAMIC: {
+        DWORD idx = id - DISPID_DYNPROP_0;
+        dynamic_prop_t *prop;
+
+        prop = This->dynamic_data->props+idx;
+        if(!(prop->flags & DYNPROP_PROTREF)) {
+            VariantClear(&prop->var);
+            prop->flags |= DYNPROP_DELETED;
+        }
+        *success = VARIANT_TRUE;
+        return S_OK;
+    }
+    case DISPEXPROP_BUILTIN: {
+        VARIANT var;
+        DISPPARAMS dp = {&var,NULL,1,0};
+        func_info_t *func;
+        IUnknown *iface;
+        HRESULT hres;
+
+        hres = get_builtin_func(This->info, id, &func);
+        if(FAILED(hres))
+            return hres;
+
+        /* For builtin functions, we set their value to the original function. */
+        if(func->func_disp_idx != -1) {
+            *success = reset_builtin_func(This, func);
             return S_OK;
         }
         *success = VARIANT_TRUE;
 
+        IDispatchEx_QueryInterface(&This->IDispatchEx_iface, tid_ids[func->tid], (void**)&iface);
+
         V_VT(&var) = VT_EMPTY;
-        hres = builtin_propput(This, func, &dp, NULL);
+        hres = builtin_propput(This, iface, func, &dp, NULL);
         if(FAILED(hres)) {
             VARIANT *ref;
             hres = dispex_get_dprop_ref(This, func->name, FALSE, &ref);
@@ -1495,6 +2004,7 @@ HRESULT remove_attribute(DispatchEx *This, DISPID id, VARIANT_BOOL *success)
             else
                 VariantClear(ref);
         }
+        IUnknown_Release(iface);
         return S_OK;
     }
     default:
@@ -1514,7 +2024,7 @@ HRESULT dispex_to_string(DispatchEx *dispex, BSTR *ret)
 {
     static const WCHAR prefix[8] = L"[object ";
     static const WCHAR suffix[] = L"]";
-    WCHAR buf[ARRAY_SIZE(prefix) + 28 + ARRAY_SIZE(suffix)], *p = buf;
+    WCHAR buf[ARRAY_SIZE(prefix) + 36 + ARRAY_SIZE(suffix)], *p = buf;
     compat_mode_t compat_mode = dispex_compat_mode(dispex);
     const WCHAR *name = dispex->info->desc->name;
     unsigned len;
@@ -1528,7 +2038,7 @@ HRESULT dispex_to_string(DispatchEx *dispex, BSTR *ret)
         p--;
     else {
         len = wcslen(name);
-        assert(len <= 28);
+        assert(len <= 36);
         memcpy(p, name, len * sizeof(WCHAR));
         p += len;
     }
@@ -1558,126 +2068,1249 @@ static BOOL ensure_real_info(DispatchEx *dispex)
     return dispex->info != NULL;
 }
 
-static inline DispatchEx *impl_from_IDispatchEx(IDispatchEx *iface)
+static inline struct compat_prototype *compat_prototype_from_IUnknown(IUnknown *iface)
 {
-    return CONTAINING_RECORD(iface, DispatchEx, IDispatchEx_iface);
+    return CONTAINING_RECORD(iface, struct compat_prototype, IUnknown_iface);
 }
 
-static HRESULT WINAPI DispatchEx_QueryInterface(IDispatchEx *iface, REFIID riid, void **ppv)
+static HRESULT WINAPI compat_prototype_QueryInterface(IUnknown *iface, REFIID riid, void **ppv)
 {
-    DispatchEx *This = impl_from_IDispatchEx(iface);
+    struct compat_prototype *This = compat_prototype_from_IUnknown(iface);
 
-    return IUnknown_QueryInterface(This->outer, riid, ppv);
+    TRACE("(%p)->(%s %p)\n", This, debugstr_mshtml_guid(riid), ppv);
+
+    if(IsEqualGUID(&IID_IUnknown, riid)) {
+        *ppv = &This->IUnknown_iface;
+    }else if(dispex_query_interface(&This->dispex, riid, ppv)) {
+        return *ppv ? S_OK : E_NOINTERFACE;
+    }else {
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown*)*ppv);
+    return S_OK;
 }
 
-static ULONG WINAPI DispatchEx_AddRef(IDispatchEx *iface)
+static ULONG WINAPI compat_prototype_AddRef(IUnknown *iface)
 {
-    DispatchEx *This = impl_from_IDispatchEx(iface);
+    struct compat_prototype *This = compat_prototype_from_IUnknown(iface);
+    LONG ref = InterlockedIncrement(&This->ref);
 
-    return IUnknown_AddRef(This->outer);
+    TRACE("(%p) ref=%ld\n", This, ref);
+
+    return ref;
 }
 
-static ULONG WINAPI DispatchEx_Release(IDispatchEx *iface)
+static ULONG WINAPI compat_prototype_Release(IUnknown *iface)
 {
-    DispatchEx *This = impl_from_IDispatchEx(iface);
+    struct compat_prototype *This = compat_prototype_from_IUnknown(iface);
+    LONG ref = InterlockedDecrement(&This->ref);
 
-    return IUnknown_Release(This->outer);
+    TRACE("(%p) ref=%ld\n", This, ref);
+
+    if(!ref) {
+        release_dispex(&This->dispex);
+        heap_free(This);
+    }
+    return ref;
 }
 
-static HRESULT WINAPI DispatchEx_GetTypeInfoCount(IDispatchEx *iface, UINT *pctinfo)
+static const IUnknownVtbl compat_prototype_vtbl = {
+    compat_prototype_QueryInterface,
+    compat_prototype_AddRef,
+    compat_prototype_Release
+};
+
+static struct compat_prototype *get_compat_prototype(HTMLInnerWindow *window, prototype_id_t prot_id,
+        compat_mode_t compat_mode)
 {
-    DispatchEx *This = impl_from_IDispatchEx(iface);
+    struct compat_prototype *prot = window->compat_prototypes[prot_id];
 
-    TRACE("(%p)->(%p)\n", This, pctinfo);
+    if(!prot) {
+        if(!(prot = heap_alloc(sizeof(*prot))))
+            return NULL;
 
-    *pctinfo = 1;
+        prot->IUnknown_iface.lpVtbl = &compat_prototype_vtbl;
+        prot->ref = 1;
+        prot->window = window;
+        window->compat_prototypes[prot_id] = prot;
+
+        init_dispatch(&prot->dispex, &prot->IUnknown_iface, &compat_prototype_dispex[prot_id], NULL, compat_mode);
+    }
+
+    IUnknown_AddRef(&prot->IUnknown_iface);
+    return prot;
+}
+
+static inline struct compat_prototype *compat_prototype_from_DispatchEx(DispatchEx *iface)
+{
+    return CONTAINING_RECORD(iface, struct compat_prototype, dispex);
+}
+
+static HRESULT compat_prototype_value(DispatchEx *dispex, LCID lcid, WORD flags, DISPPARAMS *params,
+        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+{
+    switch(flags) {
+    case DISPATCH_METHOD|DISPATCH_PROPERTYGET:
+        if(!res)
+            return E_INVALIDARG;
+        /* fall through */
+    case DISPATCH_METHOD:
+    case DISPATCH_CONSTRUCT:
+        return MSHTML_E_INVALID_ACTION;
+    case DISPATCH_PROPERTYGET:
+        if(!(V_BSTR(res) = SysAllocString(compat_prototype_nameW)))
+            return E_OUTOFMEMORY;
+        V_VT(res) = VT_BSTR;
+        break;
+    case DISPATCH_PROPERTYPUTREF|DISPATCH_PROPERTYPUT:
+    case DISPATCH_PROPERTYPUTREF:
+    case DISPATCH_PROPERTYPUT:
+        break;
+    default:
+        return E_INVALIDARG;
+    }
     return S_OK;
 }
 
-static HRESULT WINAPI DispatchEx_GetTypeInfo(IDispatchEx *iface, UINT iTInfo,
-                                              LCID lcid, ITypeInfo **ppTInfo)
+static HRESULT compat_prototype_get_dispid(DispatchEx *dispex, BSTR name, DWORD flags, DISPID *dispid)
 {
-    DispatchEx *This = impl_from_IDispatchEx(iface);
-    HRESULT hres;
+    if(dispex_compat_mode(dispex) == COMPAT_MODE_IE8) {
+        if((flags & fdexNameCaseInsensitive) ? !wcsicmp(name, L"constructor") : !wcscmp(name, L"constructor")) {
+            *dispid = MSHTML_DISPID_CUSTOM_MIN;
+            return S_OK;
+        }
+    }
+    return DISP_E_UNKNOWNNAME;
+}
 
-    TRACE("(%p)->(%u %lu %p)\n", This, iTInfo, lcid, ppTInfo);
+static HRESULT compat_prototype_invoke(DispatchEx *dispex, IDispatch *this_obj, DISPID id, LCID lcid, WORD flags,
+        DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+{
+    static WCHAR ElementW[] = L"Element";
+    struct compat_prototype *This = compat_prototype_from_DispatchEx(dispex);
+    prototype_id_t prot_id = This->dispex.info->desc - compat_prototype_dispex;
+    DWORD idx = id - MSHTML_DISPID_CUSTOM_MIN;
+    HTMLInnerWindow *window = This->window;
+    DISPPARAMS dp = { 0 };
 
-    hres = get_typeinfo(This->info->desc->disp_tid, ppTInfo);
-    if(FAILED(hres))
-        return hres;
+    if(idx > 0 || dispex_compat_mode(dispex) != COMPAT_MODE_IE8)
+        return DISP_E_MEMBERNOTFOUND;
 
-    ITypeInfo_AddRef(*ppTInfo);
+    if(!window)
+        return E_UNEXPECTED;
+
+    switch(flags) {
+    case DISPATCH_METHOD|DISPATCH_PROPERTYGET:
+        if(!res)
+            return E_INVALIDARG;
+        /* fall through */
+    case DISPATCH_METHOD:
+        return MSHTML_E_INVALID_PROPERTY;
+    case DISPATCH_PROPERTYGET:
+        if(prot_id < PROTO_ID_HTMLGenericElement && prot_id != PROTO_ID_HTMLUnknownElement)
+            break;
+        if(FAILED(IDispatchEx_GetDispID(&window->base.IDispatchEx_iface, ElementW, fdexNameCaseSensitive, &id)))
+            break;
+        return IDispatchEx_InvokeEx(&window->base.IDispatchEx_iface, id, lcid, DISPATCH_PROPERTYGET, &dp, res, ei, caller);
+    case DISPATCH_PROPERTYPUTREF|DISPATCH_PROPERTYPUT:
+    case DISPATCH_PROPERTYPUTREF:
+    case DISPATCH_PROPERTYPUT:
+        return S_OK;
+    default:
+        return MSHTML_E_INVALID_PROPERTY;
+    }
+
+    V_VT(res) = VT_NULL;
     return S_OK;
 }
 
-static HRESULT WINAPI DispatchEx_GetIDsOfNames(IDispatchEx *iface, REFIID riid,
-                                                LPOLESTR *rgszNames, UINT cNames,
-                                                LCID lcid, DISPID *rgDispId)
+static const dispex_static_data_vtbl_t compat_prototype_dispex_vtbl = {
+    compat_prototype_value,
+    compat_prototype_get_dispid,
+    compat_prototype_invoke
+};
+
+static void compat_prototype_init_dispex_info(dispex_data_t *info, compat_mode_t compat_mode)
+{
+    static const DISPID empty_exclude_list[] = { DISPID_UNKNOWN };
+    static const DISPID window_exclude_list[] = {
+        DISPID_IHTMLWINDOW2_IMAGE,
+        DISPID_IHTMLWINDOW2_OPTION,
+        DISPID_IHTMLWINDOW5_XMLHTTPREQUEST,
+        DISPID_IWINEHTMLWINDOWPRIVATE_DOMPARSER,
+        DISPID_UNKNOWN
+    };
+    prototype_id_t prot_id = info->desc - compat_prototype_dispex;
+    dispex_data_t *data = ensure_dispex_info(prototype_static_data[prot_id].desc, compat_mode);
+    const DISPID *exclude = empty_exclude_list;
+    func_info_t *func;
+    unsigned i, j;
+
+    if(!data)
+        return;
+
+    if(prototype_static_data[prot_id].desc == &HTMLWindow_dispex)
+        exclude = window_exclude_list;
+
+    /* Copy the info from the object instance data */
+    func = heap_realloc_zero(info->funcs, data->func_size * sizeof(*func));
+    if(!func)
+        return;
+    info->funcs = func;
+    info->func_disp_cnt = data->func_disp_cnt;
+    info->func_size = data->func_size;
+
+    for(i = 0; i < data->func_cnt; i++) {
+        for(j = 0; exclude[j] != DISPID_UNKNOWN; j++)
+            if(exclude[j] == data->funcs[i].id)
+                break;
+        if(exclude[j] != DISPID_UNKNOWN)
+            continue;
+        copy_func_info(func, &data->funcs[i]);
+        func++;
+    }
+    info->func_cnt = func - info->funcs;
+}
+
+HRESULT compat_ctor_value(DispatchEx *dispex, LCID lcid, WORD flags, DISPPARAMS *params,
+        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
-    DispatchEx *This = impl_from_IDispatchEx(iface);
-    UINT i;
-    HRESULT hres;
+    switch(flags) {
+    case DISPATCH_METHOD|DISPATCH_PROPERTYGET:
+        if(!res)
+            return E_INVALIDARG;
+        /* fall through */
+    case DISPATCH_METHOD:
+    case DISPATCH_CONSTRUCT:
+        return MSHTML_E_INVALID_ACTION;
+    case DISPATCH_PROPERTYGET: {
+        static const WCHAR prefix[8] = L"[object ";
+        static const WCHAR suffix[] = L"]";
+        WCHAR buf[ARRAY_SIZE(prefix) + 28 + ARRAY_SIZE(suffix)], *p = buf;
+        const WCHAR *name = dispex->info->desc->name;
+        unsigned len = wcslen(name);
+
+        memcpy(p, prefix, sizeof(prefix));
+        p += ARRAY_SIZE(prefix);
+        memcpy(p, name, len * sizeof(WCHAR));
+        p += len;
+        memcpy(p, suffix, sizeof(suffix));
 
-    TRACE("(%p)->(%s %p %u %lu %p)\n", This, debugstr_guid(riid), rgszNames, cNames,
-          lcid, rgDispId);
+        if(!(V_BSTR(res) = SysAllocString(buf)))
+            return E_OUTOFMEMORY;
+        V_VT(res) = VT_BSTR;
+        break;
+    }
+    case DISPATCH_PROPERTYPUTREF|DISPATCH_PROPERTYPUT:
+    case DISPATCH_PROPERTYPUTREF:
+    case DISPATCH_PROPERTYPUT:
+        break;
+    default:
+        return E_INVALIDARG;
+    }
+    return S_OK;
+}
 
-    for(i=0; i < cNames; i++) {
-        hres = IDispatchEx_GetDispID(&This->IDispatchEx_iface, rgszNames[i], 0, rgDispId+i);
-        if(FAILED(hres))
-            return hres;
+HRESULT compat_ctor_get_dispid(DispatchEx *dispex, BSTR name, DWORD flags, DISPID *dispid)
+{
+    if((flags & fdexNameCaseInsensitive) ? !wcsicmp(name, L"prototype") : !wcscmp(name, L"prototype")) {
+        *dispid = MSHTML_DISPID_CUSTOM_MIN;
+        return S_OK;
+    }
+    return DISP_E_UNKNOWNNAME;
+}
+
+HRESULT compat_ctor_invoke(DispatchEx *dispex, IDispatch *this_obj, DISPID id, LCID lcid, WORD flags,
+        DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+{
+    struct compat_ctor *This = CONTAINING_RECORD(dispex, struct compat_ctor, dispex);
+    DWORD idx = id - MSHTML_DISPID_CUSTOM_MIN;
+    struct compat_prototype *prot;
+
+    if(idx > 0)
+        return DISP_E_MEMBERNOTFOUND;
+
+    if(!This->window)
+        return E_UNEXPECTED;
+
+    switch(flags) {
+    case DISPATCH_METHOD|DISPATCH_PROPERTYGET:
+        if(!res)
+            return E_INVALIDARG;
+        /* fall through */
+    case DISPATCH_METHOD:
+        return MSHTML_E_INVALID_PROPERTY;
+    case DISPATCH_PROPERTYGET:
+        if(!(prot = get_compat_prototype(This->window, This->prot_id, dispex_compat_mode(dispex))))
+            return E_OUTOFMEMORY;
+        V_VT(res) = VT_DISPATCH;
+        V_DISPATCH(res) = (IDispatch*)&prot->dispex.IDispatchEx_iface;
+        break;
+    default:
+        return MSHTML_E_INVALID_PROPERTY;
     }
 
     return S_OK;
 }
 
-static HRESULT WINAPI DispatchEx_Invoke(IDispatchEx *iface, DISPID dispIdMember,
-                            REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
-                            VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+HRESULT compat_ctor_delete(DispatchEx *dispex, DISPID id)
 {
-    DispatchEx *This = impl_from_IDispatchEx(iface);
+    DWORD idx = id - MSHTML_DISPID_CUSTOM_MIN;
+    return idx ? S_OK : MSHTML_E_INVALID_PROPERTY;
+}
 
-    TRACE("(%p)->(%ld %s %ld %d %p %p %p %p)\n", This, dispIdMember, debugstr_guid(riid),
-          lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+static inline struct proxy_prototype *proxy_prototype_from_IUnknown(IUnknown *iface)
+{
+    return CONTAINING_RECORD(iface, struct proxy_prototype, IUnknown_iface);
+}
+
+static HRESULT WINAPI proxy_prototype_QueryInterface(IUnknown *iface, REFIID riid, void **ppv)
+{
+    struct proxy_prototype *This = proxy_prototype_from_IUnknown(iface);
+
+    TRACE("(%p)->(%s %p)\n", This, debugstr_mshtml_guid(riid), ppv);
+
+    if(IsEqualGUID(&IID_IUnknown, riid)) {
+        *ppv = &This->IUnknown_iface;
+    }else if(dispex_query_interface(&This->dispex, riid, ppv)) {
+        return *ppv ? S_OK : E_NOINTERFACE;
+    }else {
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown*)*ppv);
+    return S_OK;
+}
+
+static ULONG WINAPI proxy_prototype_AddRef(IUnknown *iface)
+{
+    struct proxy_prototype *This = proxy_prototype_from_IUnknown(iface);
+    LONG ref = InterlockedIncrement(&This->ref);
+
+    TRACE("(%p) ref=%ld\n", This, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI proxy_prototype_Release(IUnknown *iface)
+{
+    struct proxy_prototype *This = proxy_prototype_from_IUnknown(iface);
+    LONG ref = InterlockedDecrement(&This->ref);
+
+    TRACE("(%p) ref=%ld\n", This, ref);
+
+    if(!ref) {
+        release_dispex(&This->dispex);
+        heap_free(This);
+    }
+    return ref;
+}
+
+static const IUnknownVtbl proxy_prototype_vtbl = {
+    proxy_prototype_QueryInterface,
+    proxy_prototype_AddRef,
+    proxy_prototype_Release
+};
+
+static inline struct proxy_prototype *to_proxy_prototype(DispatchEx *dispex)
+{
+    return (dispex->outer->lpVtbl == &proxy_prototype_vtbl) ? proxy_prototype_from_IUnknown(dispex->outer) : NULL;
+}
+
+static void proxy_prototype_init_dispex_info(dispex_data_t *info, compat_mode_t compat_mode)
+{
+    dispex_static_data_t *desc = CONTAINING_RECORD(info->desc, struct prototype_static_data, dispex)->desc;
+    dispex_data_t *data = ensure_dispex_info(desc, compat_mode);
+    prototype_id_t prot_id;
+    func_info_t *func;
+    unsigned i;
+
+    if(!data)
+        return;
+
+    /* Copy the info from the object instance data, but
+       exclude builtins found up the prototype chain. */
+    func = heap_realloc_zero(info->funcs, data->func_size * sizeof(*func));
+    if(!func)
+        return;
+    info->funcs = func;
+    info->func_disp_cnt = 0;
+
+    for(i = 0; i < data->func_cnt; i++) {
+        BOOL found = FALSE;
+
+        for(prot_id = info->desc->prototype_id; prot_id >= 0; prot_id = prototype_static_data[prot_id].dispex.prototype_id) {
+            dispex_data_t *chain_data = ensure_dispex_info(prototype_static_data[prot_id].desc, compat_mode);
+            DWORD a = 0, b = chain_data->func_cnt;
+
+            while(a < b) {
+                DWORD idx = (a + b) / 2;
+                int c = wcsicmp(chain_data->name_table[idx]->name, data->funcs[i].name);
+                if(!c) {
+                    found = TRUE;
+                    break;
+                }
+                if(c > 0) b = idx;
+                else      a = idx + 1;
+            }
+            if(found)
+                break;
+        }
+        if(found)
+            continue;
+
+        copy_func_info(func, &data->funcs[i]);
+        if(func->func_disp_idx != -1)
+            info->func_disp_cnt++;
+        func++;
+    }
+
+    info->func_cnt = func - info->funcs;
+    info->func_size = max(info->func_cnt, 16);
+    func = heap_realloc_zero(info->funcs, info->func_size * sizeof(*func));
+    if(func)
+        info->funcs = func;
+}
+
+static HRESULT get_prototype_builtin_id(struct proxy_prototype *prot, WCHAR *name, DISPID *id)
+{
+    dispex_data_t *data = prot->dispex.info;
+    func_info_t **funcs = data->name_table;
+    DWORD i, a = 0, b = data->func_cnt;
+    int c;
+
+    while(a < b) {
+        i = (a + b) / 2;
+        c = wcsicmp(funcs[i]->name, name);
+        if(!c) {
+            if(wcscmp(funcs[i]->name, name))
+                break;
+            *id = funcs[i]->id;
+            return S_OK;
+        }
+        if(c > 0) b = i;
+        else      a = i + 1;
+    }
+
+    data = proxy_prototype_object_info(prot);
+    if(data->desc->vtbl && data->desc->vtbl->get_static_dispid)
+        return data->desc->vtbl->get_static_dispid(dispex_compat_mode(&prot->dispex), name, fdexNameCaseSensitive, id);
+    return DISP_E_UNKNOWNNAME;
+}
+
+static IDispatch *get_default_prototype(prototype_id_t prot_id, compat_mode_t compat_mode, struct proxy_prototypes **prots_ref)
+{
+    unsigned num_prots = ARRAY_SIZE(prototype_static_data) - COMPAT_ONLY_PROTOTYPE_COUNT;
+    struct proxy_prototype *prot;
+    IDispatch **entry;
+
+    if(!*prots_ref) {
+        if(!(*prots_ref = heap_alloc_zero(FIELD_OFFSET(struct proxy_prototypes, disp[num_prots]))))
+            return NULL;
+        (*prots_ref)->num = num_prots;
+    }
+
+    entry = &(*prots_ref)->disp[prot_id - COMPAT_ONLY_PROTOTYPE_COUNT].prototype;
+    if(*entry) {
+        IDispatch_AddRef(*entry);
+        return *entry;
+    }
+
+    if(!(prot = heap_alloc(sizeof(*prot))))
+        return NULL;
+
+    prot->IUnknown_iface.lpVtbl = &proxy_prototype_vtbl;
+    prot->ref = 2;  /* the script's ctx also holds one ref */
+
+    init_dispatch(&prot->dispex, &prot->IUnknown_iface, &prototype_static_data[prot_id].dispex, NULL, compat_mode);
+
+    *entry = (IDispatch*)&prot->dispex.IDispatchEx_iface;
+    return *entry;
+}
+
+static inline struct proxy_ctor *proxy_ctor_from_IUnknown(IUnknown *iface)
+{
+    return CONTAINING_RECORD(iface, struct proxy_ctor, IUnknown_iface);
+}
+
+static HRESULT WINAPI proxy_ctor_QueryInterface(IUnknown *iface, REFIID riid, void **ppv)
+{
+    struct proxy_ctor *This = proxy_ctor_from_IUnknown(iface);
+
+    TRACE("(%p)->(%s %p)\n", This, debugstr_mshtml_guid(riid), ppv);
+
+    if(IsEqualGUID(&IID_IUnknown, riid)) {
+        *ppv = &This->IUnknown_iface;
+    }else if(dispex_query_interface(&This->dispex, riid, ppv)) {
+        return *ppv ? S_OK : E_NOINTERFACE;
+    }else {
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown*)*ppv);
+    return S_OK;
+}
+
+static ULONG WINAPI proxy_ctor_AddRef(IUnknown *iface)
+{
+    struct proxy_ctor *This = proxy_ctor_from_IUnknown(iface);
+    LONG ref = InterlockedIncrement(&This->ref);
+
+    TRACE("(%p) ref=%ld\n", This, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI proxy_ctor_Release(IUnknown *iface)
+{
+    struct proxy_ctor *This = proxy_ctor_from_IUnknown(iface);
+    LONG ref = InterlockedDecrement(&This->ref);
+
+    TRACE("(%p) ref=%ld\n", This, ref);
+
+    if(!ref) {
+        release_dispex(&This->dispex);
+        heap_free(This);
+    }
+    return ref;
+}
+
+static const IUnknownVtbl proxy_ctor_vtbl = {
+    proxy_ctor_QueryInterface,
+    proxy_ctor_AddRef,
+    proxy_ctor_Release
+};
+
+static HRESULT proxy_ctor_value(DispatchEx *dispex, LCID lcid, WORD flags, DISPPARAMS *params,
+        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+{
+    switch(flags) {
+    case DISPATCH_METHOD|DISPATCH_PROPERTYGET:
+        if(!res)
+            return E_INVALIDARG;
+        /* fall through */
+    case DISPATCH_METHOD:
+    case DISPATCH_CONSTRUCT:
+        return MSHTML_E_INVALID_ACTION;
+    case DISPATCH_PROPERTYGET:
+        V_VT(res) = VT_BSTR;
+        return dispex_to_string(dispex, &V_BSTR(res));
+    case DISPATCH_PROPERTYPUTREF|DISPATCH_PROPERTYPUT:
+    case DISPATCH_PROPERTYPUTREF:
+    case DISPATCH_PROPERTYPUT:
+        break;
+    default:
+        return E_INVALIDARG;
+    }
+    return S_OK;
+}
+
+static const dispex_static_data_vtbl_t proxy_ctor_dispex_vtbl = {
+    proxy_ctor_value,
+    NULL
+};
+
+static HRESULT WINAPI proxy_func_invoke(IDispatch *this_obj, void *context, DISPPARAMS *dp, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+{
+    func_info_t *func = context;
+    return invoke_builtin_function(this_obj, func, dp, res, ei, caller);
+}
+
+static HRESULT WINAPI proxy_getter_invoke(IDispatch *this_obj, void *context, DISPPARAMS *dp, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+{
+    func_info_t *func = context;
+    DispatchEx *dispex;
+    IUnknown *iface;
+    HRESULT hres;
+
+    hres = IDispatch_QueryInterface(this_obj, tid_ids[func->tid], (void**)&iface);
+    if(FAILED(hres) || !iface)
+        return E_UNEXPECTED;
+
+    if(func->hook && (dispex = get_dispex_for_hook(iface))) {
+        hres = func->hook(dispex, DISPATCH_PROPERTYGET, dp, res, ei, caller);
+        IDispatchEx_Release(&dispex->IDispatchEx_iface);
+        if(hres != S_FALSE)
+            goto done;
+    }
+    hres = builtin_propget(iface, func, dp, res);
+
+done:
+    IUnknown_Release(iface);
+    return hres;
+}
+
+static HRESULT WINAPI proxy_setter_invoke(IDispatch *this_obj, void *context, DISPPARAMS *dp, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+{
+    static DISPID propput_dispid = DISPID_PROPERTYPUT;
+    func_info_t *func = context;
+    DispatchEx *dispex;
+    IUnknown *iface;
+    HRESULT hres;
+
+    dp->cNamedArgs = 1;
+    dp->rgdispidNamedArgs = &propput_dispid;
+
+    hres = IDispatch_QueryInterface(this_obj, tid_ids[func->tid], (void**)&iface);
+    if(FAILED(hres) || !iface)
+        return E_UNEXPECTED;
+
+    if(func->hook && (dispex = get_dispex_for_hook(iface))) {
+        hres = func->hook(dispex, DISPATCH_PROPERTYPUT, dp, res, ei, caller);
+        IDispatchEx_Release(&dispex->IDispatchEx_iface);
+        if(hres != S_FALSE)
+            goto done;
+    }
+    hres = builtin_propput(NULL, iface, func, dp, caller);
+
+done:
+    IUnknown_Release(iface);
+    return hres;
+}
+
+static inline DispatchEx *impl_from_IDispatchEx(IDispatchEx *iface)
+{
+    return CONTAINING_RECORD(iface, DispatchEx, IDispatchEx_iface);
+}
+
+static HRESULT WINAPI DispatchEx_QueryInterface(IDispatchEx *iface, REFIID riid, void **ppv)
+{
+    DispatchEx *This = impl_from_IDispatchEx(iface);
+
+    return IUnknown_QueryInterface(This->outer, riid, ppv);
+}
+
+static ULONG WINAPI DispatchEx_AddRef(IDispatchEx *iface)
+{
+    DispatchEx *This = impl_from_IDispatchEx(iface);
+
+    return IUnknown_AddRef(This->outer);
+}
+
+static ULONG WINAPI DispatchEx_Release(IDispatchEx *iface)
+{
+    DispatchEx *This = impl_from_IDispatchEx(iface);
+
+    return IUnknown_Release(This->outer);
+}
+
+static HRESULT WINAPI DispatchEx_GetTypeInfoCount(IDispatchEx *iface, UINT *pctinfo)
+{
+    DispatchEx *This = impl_from_IDispatchEx(iface);
+
+    TRACE("(%p)->(%p)\n", This, pctinfo);
+
+    *pctinfo = 1;
+    return S_OK;
+}
+
+static HRESULT WINAPI DispatchEx_GetTypeInfo(IDispatchEx *iface, UINT iTInfo,
+                                              LCID lcid, ITypeInfo **ppTInfo)
+{
+    DispatchEx *This = impl_from_IDispatchEx(iface);
+    HRESULT hres;
+
+    TRACE("(%p)->(%u %lu %p)\n", This, iTInfo, lcid, ppTInfo);
+
+    hres = get_typeinfo(This->info->desc->disp_tid, ppTInfo);
+    if(FAILED(hres))
+        return hres;
+
+    ITypeInfo_AddRef(*ppTInfo);
+    return S_OK;
+}
+
+static HRESULT WINAPI DispatchEx_GetIDsOfNames(IDispatchEx *iface, REFIID riid,
+                                                LPOLESTR *rgszNames, UINT cNames,
+                                                LCID lcid, DISPID *rgDispId)
+{
+    DispatchEx *This = impl_from_IDispatchEx(iface);
+    UINT i;
+    HRESULT hres;
+
+    if(This->proxy)
+        return IDispatchEx_GetIDsOfNames((IDispatchEx*)This->proxy, riid, rgszNames,
+                                         cNames, lcid, rgDispId);
+
+    TRACE("(%p)->(%s %p %u %lu %p)\n", This, debugstr_guid(riid), rgszNames, cNames,
+          lcid, rgDispId);
+
+    for(i=0; i < cNames; i++) {
+        hres = IDispatchEx_GetDispID(&This->IDispatchEx_iface, rgszNames[i], 0, rgDispId+i);
+        if(FAILED(hres))
+            return hres;
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI DispatchEx_Invoke(IDispatchEx *iface, DISPID dispIdMember,
+                            REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+                            VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    DispatchEx *This = impl_from_IDispatchEx(iface);
+
+    if(This->proxy)
+        return IDispatchEx_Invoke((IDispatchEx*)This->proxy, dispIdMember, riid, lcid, wFlags,
+                                  pDispParams, pVarResult, pExcepInfo, puArgErr);
+
+    TRACE("(%p)->(%ld %s %ld %d %p %p %p %p)\n", This, dispIdMember, debugstr_guid(riid),
+          lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+
+    return dispex_invoke(This, (IDispatch*)iface, dispIdMember, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, NULL);
+}
+
+static HRESULT WINAPI DispatchEx_GetDispID(IDispatchEx *iface, BSTR bstrName, DWORD grfdex, DISPID *pid)
+{
+    DispatchEx *This = impl_from_IDispatchEx(iface);
+    dynamic_prop_t *dprop;
+    HRESULT hres;
+
+    if(This->proxy)
+        return IDispatchEx_GetDispID((IDispatchEx*)This->proxy, bstrName, grfdex, pid);
+
+    TRACE("(%p)->(%s %lx %p)\n", This, debugstr_w(bstrName), grfdex, pid);
+
+    if(grfdex & ~(fdexNameCaseSensitive|fdexNameCaseInsensitive|fdexNameEnsure|fdexNameImplicit|FDEX_VERSION_MASK))
+        FIXME("Unsupported grfdex %lx\n", grfdex);
+
+    if(!ensure_real_info(This))
+        return E_OUTOFMEMORY;
+
+    hres = get_builtin_id(This, bstrName, grfdex, pid);
+    if(hres != DISP_E_UNKNOWNNAME)
+        return hres;
+
+    hres = get_dynamic_prop(This, bstrName, grfdex, &dprop);
+    if(FAILED(hres))
+        return hres;
+
+    *pid = DISPID_DYNPROP_0 + (dprop - This->dynamic_data->props);
+    return S_OK;
+}
+
+static HRESULT WINAPI DispatchEx_InvokeEx(IDispatchEx *iface, DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp,
+        VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
+{
+    DispatchEx *This = impl_from_IDispatchEx(iface);
+
+    if(This->proxy)
+        return IDispatchEx_InvokeEx((IDispatchEx*)This->proxy, id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
+
+    TRACE("(%p)->(%lx %lx %x %p %p %p %p)\n", This, id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
+
+    return dispex_invoke(This, (IDispatch*)iface, id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
+}
+
+static HRESULT WINAPI DispatchEx_DeleteMemberByName(IDispatchEx *iface, BSTR name, DWORD grfdex)
+{
+    DispatchEx *This = impl_from_IDispatchEx(iface);
+    DISPID id;
+    HRESULT hres;
+
+    if(This->proxy)
+        return IDispatchEx_DeleteMemberByName((IDispatchEx*)This->proxy, name, grfdex);
+
+    TRACE("(%p)->(%s %lx)\n", This, debugstr_w(name), grfdex);
+
+    if(dispex_compat_mode(This) < COMPAT_MODE_IE8) {
+        /* Not implemented by IE */
+        return E_NOTIMPL;
+    }
+
+    hres = IDispatchEx_GetDispID(&This->IDispatchEx_iface, name, grfdex & ~fdexNameEnsure, &id);
+    if(FAILED(hres)) {
+        TRACE("property %s not found\n", debugstr_w(name));
+        return hres;
+    }
+
+    return dispex_delete_prop(This, id);
+}
+
+static HRESULT WINAPI DispatchEx_DeleteMemberByDispID(IDispatchEx *iface, DISPID id)
+{
+    DispatchEx *This = impl_from_IDispatchEx(iface);
+
+    if(This->proxy)
+        return IDispatchEx_DeleteMemberByDispID((IDispatchEx*)This->proxy, id);
+
+    TRACE("(%p)->(%lx)\n", This, id);
+
+    if(dispex_compat_mode(This) < COMPAT_MODE_IE8) {
+        /* Not implemented by IE */
+        return E_NOTIMPL;
+    }
+
+    return dispex_delete_prop(This, id);
+}
+
+static HRESULT WINAPI DispatchEx_GetMemberProperties(IDispatchEx *iface, DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
+{
+    DispatchEx *This = impl_from_IDispatchEx(iface);
+
+    if(This->proxy)
+        return IDispatchEx_GetMemberProperties((IDispatchEx*)This->proxy, id, grfdexFetch, pgrfdex);
+
+    FIXME("(%p)->(%lx %lx %p)\n", This, id, grfdexFetch, pgrfdex);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI DispatchEx_GetMemberName(IDispatchEx *iface, DISPID id, BSTR *pbstrName)
+{
+    DispatchEx *This = impl_from_IDispatchEx(iface);
+    func_info_t *func;
+    HRESULT hres;
+
+    if(This->proxy)
+        return IDispatchEx_GetMemberName((IDispatchEx*)This->proxy, id, pbstrName);
+
+    TRACE("(%p)->(%lx %p)\n", This, id, pbstrName);
+
+    if(!ensure_real_info(This))
+        return E_OUTOFMEMORY;
+
+    if(is_dynamic_dispid(id)) {
+        DWORD idx = id - DISPID_DYNPROP_0;
+
+        if(!get_dynamic_data(This) || This->dynamic_data->prop_cnt <= idx)
+            return DISP_E_UNKNOWNNAME;
+
+        *pbstrName = SysAllocString(This->dynamic_data->props[idx].name);
+        if(!*pbstrName)
+            return E_OUTOFMEMORY;
+
+        return S_OK;
+    }
+
+    hres = get_builtin_func_prot(This, id, &func);
+    if(FAILED(hres))
+        return hres;
+
+    *pbstrName = SysAllocString(func->name);
+    if(!*pbstrName)
+        return E_OUTOFMEMORY;
+    return S_OK;
+}
+
+static HRESULT next_dynamic_id(DispatchEx *dispex, DWORD idx, DISPID *ret_id)
+{
+    /* FIXME: Go through PROTREFs? (must exclude props with same name as builtins) */
+    while(idx < dispex->dynamic_data->prop_cnt &&
+          dispex->dynamic_data->props[idx].flags & (DYNPROP_DELETED | DYNPROP_PROTREF))
+        idx++;
+
+    if(idx == dispex->dynamic_data->prop_cnt) {
+        *ret_id = DISPID_STARTENUM;
+        return S_FALSE;
+    }
+
+    *ret_id = DISPID_DYNPROP_0+idx;
+    return S_OK;
+}
+
+static HRESULT WINAPI DispatchEx_GetNextDispID(IDispatchEx *iface, DWORD grfdex, DISPID id, DISPID *pid)
+{
+    DispatchEx *This = impl_from_IDispatchEx(iface);
+    func_info_t *func;
+    HRESULT hres;
+
+    if(This->proxy)
+        return IDispatchEx_GetNextDispID((IDispatchEx*)This->proxy, grfdex, id, pid);
+
+    TRACE("(%p)->(%lx %lx %p)\n", This, grfdex, id, pid);
+
+    if(!ensure_real_info(This))
+        return E_OUTOFMEMORY;
+
+    if(is_dynamic_dispid(id)) {
+        DWORD idx = id - DISPID_DYNPROP_0;
+
+        if(!get_dynamic_data(This) || This->dynamic_data->prop_cnt <= idx)
+            return DISP_E_UNKNOWNNAME;
+
+        return next_dynamic_id(This, idx+1, pid);
+    }
+
+    if(id == DISPID_STARTENUM) {
+        func = This->info->funcs;
+    }else {
+        hres = get_builtin_func_prot(This, id, &func);
+        if(FAILED(hres))
+            return hres;
+        func++;
+    }
+
+    while(func < This->info->funcs + This->info->func_cnt) {
+        /* FIXME: Skip hidden properties */
+        if(func->func_disp_idx == -1) {
+            *pid = func->id;
+            return S_OK;
+        }
+        func++;
+    }
+
+    if(get_dynamic_data(This) && This->dynamic_data->prop_cnt)
+        return next_dynamic_id(This, 0, pid);
+
+    *pid = DISPID_STARTENUM;
+    return S_FALSE;
+}
+
+static HRESULT WINAPI DispatchEx_GetNameSpaceParent(IDispatchEx *iface, IUnknown **ppunk)
+{
+    DispatchEx *This = impl_from_IDispatchEx(iface);
+    FIXME("(%p)->(%p)\n", This, ppunk);
+    return E_NOTIMPL;
+}
+
+static inline DispatchEx *impl_from_IWineDispatchProxyPrivate(IWineDispatchProxyPrivate *iface)
+{
+    return impl_from_IDispatchEx((IDispatchEx*)iface);
+}
+
+static IWineDispatchProxyCbPrivate** WINAPI WineDispatchProxyPrivate_GetProxyFieldRef(IWineDispatchProxyPrivate *iface)
+{
+    DispatchEx *This = impl_from_IWineDispatchProxyPrivate(iface);
+    return &This->proxy;
+}
+
+static IDispatch* WINAPI WineDispatchProxyPrivate_GetDefaultPrototype(IWineDispatchProxyPrivate *iface, struct proxy_prototypes **prots_ref)
+{
+    DispatchEx *This = impl_from_IWineDispatchProxyPrivate(iface);
+    prototype_id_t prot_id = This->info->desc->prototype_id;
+
+    if(prot_id < 0)
+        return (IDispatch*)(INT_PTR)prot_id;
+
+    if(prot_id < COMPAT_ONLY_PROTOTYPE_COUNT)
+        return (IDispatch*)(INT_PTR)PROTO_ID_NULL;
+
+    return get_default_prototype(prot_id, dispex_compat_mode(This), prots_ref);
+}
+
+static IDispatch* WINAPI WineDispatchProxyPrivate_GetDefaultConstructor(IWineDispatchProxyPrivate *iface, struct proxy_prototypes *prots)
+{
+    static const struct {
+        prototype_id_t prot_id;
+        DISPID dispid;
+    } special_ctors[] = {
+        { PROTO_ID_DOMParser,           DISPID_IWINEHTMLWINDOWPRIVATE_DOMPARSER },
+        { PROTO_ID_HTMLXMLHttpRequest,  DISPID_IHTMLWINDOW5_XMLHTTPREQUEST },
+    };
+    DispatchEx *This = impl_from_IWineDispatchProxyPrivate(iface);
+    struct proxy_prototype *prot = proxy_prototype_from_IUnknown(This->outer);
+    struct proxy_ctor *ctor;
+    prototype_id_t prot_id;
+    IDispatch **entry;
+    unsigned i;
+
+    prot_id = CONTAINING_RECORD(prot->dispex.info->desc, struct prototype_static_data, dispex) - prototype_static_data;
+
+    entry = &prots->disp[prot_id - COMPAT_ONLY_PROTOTYPE_COUNT].ctor;
+    if(*entry) {
+        IDispatch_AddRef(*entry);
+        return *entry;
+    }
+
+    for(i = 0; i < ARRAY_SIZE(special_ctors); i++) {
+        if(prot_id != special_ctors[i].prot_id)
+            continue;
+        *entry = This->proxy->lpVtbl->CreateConstructor(This->proxy, special_ctors[i].dispid,
+                                                        proxy_ctor_dispex[prot_id - COMPAT_ONLY_PROTOTYPE_COUNT].name);
+        if(*entry) {
+            IDispatch_AddRef(*entry);
+            return *entry;
+        }
+    }
+
+    if(!(ctor = heap_alloc(sizeof(*ctor))))
+        return NULL;
+
+    ctor->IUnknown_iface.lpVtbl = &proxy_ctor_vtbl;
+    ctor->ref = 2;  /* the script's ctx also holds one ref */
+
+    init_dispatch(&ctor->dispex, &ctor->IUnknown_iface, &proxy_ctor_dispex[prot_id - COMPAT_ONLY_PROTOTYPE_COUNT],
+                  NULL, dispex_compat_mode(This));
+
+    *entry = (IDispatch*)&ctor->dispex.IDispatchEx_iface;
+    return *entry;
+}
+
+static HRESULT WINAPI WineDispatchProxyPrivate_DefineConstructors(IWineDispatchProxyPrivate *iface, struct proxy_prototypes **prots_ref)
+{
+    static WCHAR ImageW[] = L"Image";
+    static WCHAR OptionW[] = L"Option";
+    static const struct {
+        WCHAR *name;
+        prototype_id_t proto_id;
+    } extra_ctors[] = {
+        { ImageW,       PROTO_ID_HTMLImgElement },
+        { OptionW,      PROTO_ID_HTMLOptionElement },
+    };
+    DispatchEx *This = impl_from_IWineDispatchProxyPrivate(iface);
+    compat_mode_t compat_mode;
+    IDispatch *prot;
+    unsigned int i;
+    HRESULT hres;
+    DISPID id;
+
+    if(!ensure_real_info(This))
+        return E_OUTOFMEMORY;
+    if(This->info->desc != &HTMLWindow_dispex)
+        return S_FALSE;
+    compat_mode = dispex_compat_mode(This);
+
+    for(i = 0; i < ARRAY_SIZE(proxy_ctor_dispex); i++) {
+        if(!(prot = get_default_prototype(i + COMPAT_ONLY_PROTOTYPE_COUNT, compat_mode, prots_ref)))
+            return E_OUTOFMEMORY;
+
+        hres = This->proxy->lpVtbl->DefineConstructor(This->proxy, proxy_ctor_dispex[i].name, prot, DISPID_UNKNOWN);
+        if(FAILED(hres))
+            return hres;
+    }
+
+    for(i = 0; i < ARRAY_SIZE(extra_ctors); i++) {
+        if(get_builtin_id(This, extra_ctors[i].name, fdexNameCaseSensitive, &id) != S_OK)
+            continue;
+
+        if(!(prot = get_default_prototype(extra_ctors[i].proto_id, compat_mode, prots_ref)))
+            return E_OUTOFMEMORY;
+
+        hres = This->proxy->lpVtbl->DefineConstructor(This->proxy, extra_ctors[i].name, prot, id);
+        if(FAILED(hres))
+            return hres;
+    }
+
+    return S_OK;
+}
+
+static BOOL WINAPI WineDispatchProxyPrivate_IsPrototype(IWineDispatchProxyPrivate *iface)
+{
+    DispatchEx *This = impl_from_IWineDispatchProxyPrivate(iface);
+    return to_proxy_prototype(This) != NULL;
+}
+
+static BOOL WINAPI WineDispatchProxyPrivate_IsConstructor(IWineDispatchProxyPrivate *iface)
+{
+    DispatchEx *This = impl_from_IWineDispatchProxyPrivate(iface);
+    return This->outer->lpVtbl == &proxy_ctor_vtbl;
+}
+
+static DWORD WINAPI WineDispatchProxyPrivate_PropFlags(IWineDispatchProxyPrivate *iface, DISPID id)
+{
+    DispatchEx *This = impl_from_IWineDispatchProxyPrivate(iface);
+    func_info_t *func;
+
+    if(is_dynamic_dispid(id))
+        return PROPF_WRITABLE | PROPF_CONFIGURABLE | PROPF_ENUMERABLE;
+
+    if(is_custom_dispid(id))
+        return PROPF_WRITABLE;
+
+    if(FAILED(get_builtin_func_prot(This, id, &func)))
+        return 0;
+
+    if(func->func_disp_idx != -1) {
+        if(This->dynamic_data && This->dynamic_data->func_disps
+           && This->dynamic_data->func_disps[func->func_disp_idx].func_obj) {
+            func_obj_entry_t *entry = This->dynamic_data->func_disps + func->func_disp_idx;
+
+            if((IDispatch*)&entry->func_obj->dispex.IDispatchEx_iface != V_DISPATCH(&entry->val))
+                return PROPF_WRITABLE | PROPF_CONFIGURABLE;
+        }
+        return PROPF_METHOD | func->argc | PROPF_WRITABLE | PROPF_CONFIGURABLE;
+    }
+
+    /* FIXME: Don't add PROPF_ENUMERABLE to hidden properties */
+    return PROPF_PROXY_ACCESSOR | PROPF_ENUMERABLE | PROPF_CONFIGURABLE | (func->put_vtbl_off ? PROPF_WRITABLE : 0);
+}
+
+static HRESULT WINAPI WineDispatchProxyPrivate_PropGetID(IWineDispatchProxyPrivate *iface, WCHAR *name, DISPID *id)
+{
+    DispatchEx *This = impl_from_IWineDispatchProxyPrivate(iface);
+    struct proxy_prototype *prot = to_proxy_prototype(This);
+    dynamic_prop_t *dprop;
+    HRESULT hres;
+
+    if(!ensure_real_info(This))
+        return E_OUTOFMEMORY;
+
+    if(!prot && This->info->desc->prototype_id < 0) {
+        hres = get_builtin_id(This, name, fdexNameCaseSensitive, id);
+        if(hres != DISP_E_UNKNOWNNAME)
+            return hres;
+    }else {
+        if(prot) {
+            hres = get_prototype_builtin_id(prot, name, id);
+            if(hres != DISP_E_UNKNOWNNAME)
+                return hres;
+        }
+
+        if(This->info->desc->vtbl && This->info->desc->vtbl->get_dispid) {
+            hres = This->info->desc->vtbl->get_dispid(This, name, fdexNameCaseSensitive, id);
+            if(hres != DISP_E_UNKNOWNNAME)
+                return hres;
+        }
+    }
+
+    hres = get_dynamic_prop(This, name, fdexNameCaseSensitive, &dprop);
+    if(FAILED(hres))
+        return hres;
+
+    *id = DISPID_DYNPROP_0 + (dprop - This->dynamic_data->props);
+    return S_OK;
+}
+
+static HRESULT WINAPI WineDispatchProxyPrivate_PropInvoke(IWineDispatchProxyPrivate *iface, IDispatch *this_obj, DISPID id,
+        LCID lcid, DWORD flags, DISPPARAMS *dp, VARIANT *ret, EXCEPINFO *ei, IServiceProvider *caller)
+{
+    DispatchEx *This = impl_from_IWineDispatchProxyPrivate(iface);
+
+    /* Prototypes use this for their default value, to be able
+       to be distinguished from builtin ids with DISPID_VALUE. */
+    if(id == DISPID_UNKNOWN)
+        return dispex_value(This, lcid, flags, dp, ret, ei, caller);
+
+    return dispex_invoke(This, this_obj, id, lcid, flags, dp, ret, ei, caller);
+}
+
+static HRESULT WINAPI WineDispatchProxyPrivate_PropDelete(IWineDispatchProxyPrivate *iface, DISPID id)
+{
+    DispatchEx *This = impl_from_IWineDispatchProxyPrivate(iface);
+
+    return dispex_delete_prop(This, id);
+}
+
+static HRESULT WINAPI WineDispatchProxyPrivate_FuncInfo(IWineDispatchProxyPrivate *iface, DISPID id, struct proxy_func_invoker *ret)
+{
+    DispatchEx *This = impl_from_IWineDispatchProxyPrivate(iface);
+    func_info_t *func;
+    HRESULT hres;
+
+    hres = get_builtin_func_prot(This, id, &func);
+    if(FAILED(hres))
+        return (hres == DISP_E_MEMBERNOTFOUND) ? E_UNEXPECTED : hres;
+    if(func->func_disp_idx == -1)
+        return E_UNEXPECTED;
+
+    ret->invoke = proxy_func_invoke;
+    ret->context = func;
+    ret->name = func->name;
+    return S_OK;
+}
+
+static HRESULT WINAPI WineDispatchProxyPrivate_AccessorInfo(IWineDispatchProxyPrivate *iface, DISPID id, struct proxy_func_invoker *ret)
+{
+    DispatchEx *This = impl_from_IWineDispatchProxyPrivate(iface);
+    func_info_t *func;
+    HRESULT hres;
+
+    hres = get_builtin_func_prot(This, id, &func);
+    if(FAILED(hres))
+        return (hres == DISP_E_MEMBERNOTFOUND) ? E_UNEXPECTED : hres;
+    if(func->func_disp_idx != -1)
+        return E_UNEXPECTED;
+
+    ret[0].invoke = func->get_vtbl_off ? proxy_getter_invoke : NULL;
+    ret[1].invoke = func->put_vtbl_off ? proxy_setter_invoke : NULL;
+    ret[0].context = ret[1].context = func;
+    ret[0].name = ret[1].name = func->name;
+    return S_OK;
+}
+
+static HRESULT WINAPI WineDispatchProxyPrivate_ToString(IWineDispatchProxyPrivate *iface, BSTR *string)
+{
+    DispatchEx *This = impl_from_IWineDispatchProxyPrivate(iface);
+    return dispex_to_string(This, string);
+}
+
+static BOOL WINAPI WineDispatchProxyPrivate_CanGC(IWineDispatchProxyPrivate *iface)
+{
+    DispatchEx *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IUnknown *outer = This->outer;
+
+    /* Allow garbage collection only if the proxy is the only one holding a ref to us */
+    IUnknown_AddRef(outer);
+    return IUnknown_Release(outer) == 1;
+}
+
+static IWineDispatchProxyPrivateVtbl WineDispatchProxyPrivateVtbl = {
+    {
+    DispatchEx_QueryInterface,
+    DispatchEx_AddRef,
+    DispatchEx_Release,
+    DispatchEx_GetTypeInfoCount,
+    DispatchEx_GetTypeInfo,
+    DispatchEx_GetIDsOfNames,
+    DispatchEx_Invoke,
+    DispatchEx_GetDispID,
+    DispatchEx_InvokeEx,
+    DispatchEx_DeleteMemberByName,
+    DispatchEx_DeleteMemberByDispID,
+    DispatchEx_GetMemberProperties,
+    DispatchEx_GetMemberName,
+    DispatchEx_GetNextDispID,
+    DispatchEx_GetNameSpaceParent
+    },
+
+    /* IWineDispatchProxyPrivate extension */
+    WineDispatchProxyPrivate_GetProxyFieldRef,
+    WineDispatchProxyPrivate_GetDefaultPrototype,
+    WineDispatchProxyPrivate_GetDefaultConstructor,
+    WineDispatchProxyPrivate_DefineConstructors,
+    WineDispatchProxyPrivate_IsPrototype,
+    WineDispatchProxyPrivate_IsConstructor,
+    WineDispatchProxyPrivate_PropFlags,
+    WineDispatchProxyPrivate_PropGetID,
+    WineDispatchProxyPrivate_PropInvoke,
+    WineDispatchProxyPrivate_PropDelete,
+    WineDispatchProxyPrivate_FuncInfo,
+    WineDispatchProxyPrivate_AccessorInfo,
+    WineDispatchProxyPrivate_ToString,
+    WineDispatchProxyPrivate_CanGC
+};
 
-    return IDispatchEx_InvokeEx(&This->IDispatchEx_iface, dispIdMember, lcid, wFlags, pDispParams,
-            pVarResult, pExcepInfo, NULL);
+static inline BOOL is_compat_prototype(IDispatch *disp)
+{
+    if(!disp || disp->lpVtbl != (const IDispatchVtbl*)&WineDispatchProxyPrivateVtbl)
+        return FALSE;
+    return (impl_from_IDispatchEx((IDispatchEx*)disp)->outer->lpVtbl == &compat_prototype_vtbl);
 }
 
-static HRESULT WINAPI DispatchEx_GetDispID(IDispatchEx *iface, BSTR bstrName, DWORD grfdex, DISPID *pid)
+BOOL dispex_query_interface(DispatchEx *This, REFIID riid, void **ppv)
 {
-    DispatchEx *This = impl_from_IDispatchEx(iface);
-    dynamic_prop_t *dprop;
-    HRESULT hres;
-
-    TRACE("(%p)->(%s %lx %p)\n", This, debugstr_w(bstrName), grfdex, pid);
-
-    if(grfdex & ~(fdexNameCaseSensitive|fdexNameCaseInsensitive|fdexNameEnsure|fdexNameImplicit|FDEX_VERSION_MASK))
-        FIXME("Unsupported grfdex %lx\n", grfdex);
-
-    if(!ensure_real_info(This))
-        return E_OUTOFMEMORY;
-
-    hres = get_builtin_id(This, bstrName, grfdex, pid);
-    if(hres != DISP_E_UNKNOWNNAME)
-        return hres;
-
-    hres = get_dynamic_prop(This, bstrName, grfdex, &dprop);
-    if(FAILED(hres))
-        return hres;
+    if(IsEqualGUID(&IID_IDispatch, riid))
+        *ppv = &This->IDispatchEx_iface;
+    else if(IsEqualGUID(&IID_IDispatchEx, riid))
+        *ppv = &This->IDispatchEx_iface;
+    else if(IsEqualGUID(&IID_IWineDispatchProxyPrivate, riid))
+        *ppv = &This->IDispatchEx_iface;
+    else if(IsEqualGUID(&IID_IDispatchJS, riid))
+        *ppv = NULL;
+    else if(IsEqualGUID(&IID_UndocumentedScriptIface, riid))
+        *ppv = NULL;
+    else if(IsEqualGUID(&IID_IMarshal, riid))
+        *ppv = NULL;
+    else if(IsEqualGUID(&IID_IManagedObject, riid))
+        *ppv = NULL;
+    else
+        return FALSE;
 
-    *pid = DISPID_DYNPROP_0 + (dprop - This->dynamic_data->props);
-    return S_OK;
+    if(*ppv)
+        IUnknown_AddRef((IUnknown*)*ppv);
+    return TRUE;
 }
 
-static HRESULT WINAPI DispatchEx_InvokeEx(IDispatchEx *iface, DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp,
-        VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
+HRESULT dispex_invoke(DispatchEx *dispex, IDispatch *this_obj, DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp,
+        VARIANT *res, EXCEPINFO *pei, IServiceProvider *caller)
 {
-    DispatchEx *This = impl_from_IDispatchEx(iface);
     HRESULT hres;
 
-    TRACE("(%p)->(%lx %lx %x %p %p %p %p)\n", This, id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
-
-    if(!ensure_real_info(This))
+    if(!ensure_real_info(dispex))
         return E_OUTOFMEMORY;
 
     if(wFlags == (DISPATCH_PROPERTYPUT|DISPATCH_PROPERTYPUTREF))
@@ -1685,36 +3318,45 @@ static HRESULT WINAPI DispatchEx_InvokeEx(IDispatchEx *iface, DISPID id, LCID lc
 
     switch(get_dispid_type(id)) {
     case DISPEXPROP_CUSTOM:
-        if(!This->info->desc->vtbl || !This->info->desc->vtbl->invoke)
+        if(!dispex->info->desc->vtbl || !dispex->info->desc->vtbl->invoke)
             return DISP_E_UNKNOWNNAME;
-        return This->info->desc->vtbl->invoke(This, id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
+        return dispex->info->desc->vtbl->invoke(dispex, this_obj, id, lcid, wFlags, pdp, res, pei, caller);
 
     case DISPEXPROP_DYNAMIC: {
         DWORD idx = id - DISPID_DYNPROP_0;
         dynamic_prop_t *prop;
 
-        if(!get_dynamic_data(This) || This->dynamic_data->prop_cnt <= idx)
+        if(!get_dynamic_data(dispex) || dispex->dynamic_data->prop_cnt <= idx)
             return DISP_E_UNKNOWNNAME;
 
-        prop = This->dynamic_data->props+idx;
+        prop = dispex->dynamic_data->props+idx;
 
         switch(wFlags) {
         case DISPATCH_METHOD|DISPATCH_PROPERTYGET:
-            if(!pvarRes)
+            if(!res)
                 return E_INVALIDARG;
             /* fall through */
         case DISPATCH_METHOD:
+            fixup_prop_ref(dispex, prop);
+            if(prop->flags & DYNPROP_DELETED)
+                return DISP_E_UNKNOWNNAME;
+            if(prop->flags & DYNPROP_PROTREF)
+                prop = &dispex->prototype->dispex.dynamic_data->props[V_UI4(&prop->var)];
+
             if(V_VT(&prop->var) != VT_DISPATCH) {
                 FIXME("invoke %s\n", debugstr_variant(&prop->var));
                 return E_NOTIMPL;
             }
 
-            return invoke_disp_value(This, V_DISPATCH(&prop->var), lcid, wFlags, pdp, pvarRes, pei, pspCaller);
+            return invoke_disp_value(this_obj, V_DISPATCH(&prop->var), lcid, wFlags, pdp, res, pei, caller);
         case DISPATCH_PROPERTYGET:
+            fixup_prop_ref(dispex, prop);
             if(prop->flags & DYNPROP_DELETED)
                 return DISP_E_UNKNOWNNAME;
-            V_VT(pvarRes) = VT_EMPTY;
-            return variant_copy(pvarRes, &prop->var);
+            if(prop->flags & DYNPROP_PROTREF)
+                prop = &dispex->prototype->dispex.dynamic_data->props[V_UI4(&prop->var)];
+            V_VT(res) = VT_EMPTY;
+            return variant_copy(res, &prop->var);
         case DISPATCH_PROPERTYPUT:
             if(pdp->cArgs != 1 || (pdp->cNamedArgs == 1 && *pdp->rgdispidNamedArgs != DISPID_PROPERTYPUT)
                || pdp->cNamedArgs > 1) {
@@ -1728,7 +3370,7 @@ static HRESULT WINAPI DispatchEx_InvokeEx(IDispatchEx *iface, DISPID id, LCID lc
             if(FAILED(hres))
                 return hres;
 
-            prop->flags &= ~DYNPROP_DELETED;
+            prop->flags &= ~(DYNPROP_DELETED | DYNPROP_PROTREF);
             return S_OK;
         default:
             FIXME("unhandled wFlags %x\n", wFlags);
@@ -1738,8 +3380,8 @@ static HRESULT WINAPI DispatchEx_InvokeEx(IDispatchEx *iface, DISPID id, LCID lc
     case DISPEXPROP_BUILTIN:
         if(wFlags == DISPATCH_CONSTRUCT) {
             if(id == DISPID_VALUE) {
-                if(This->info->desc->vtbl && This->info->desc->vtbl->value) {
-                    return This->info->desc->vtbl->value(This, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
+                if(dispex->info->desc->vtbl && dispex->info->desc->vtbl->value) {
+                    return dispex->info->desc->vtbl->value(dispex, lcid, wFlags, pdp, res, pei, caller);
                 }
                 FIXME("DISPATCH_CONSTRUCT flag but missing value function\n");
                 return E_FAIL;
@@ -1748,213 +3390,69 @@ static HRESULT WINAPI DispatchEx_InvokeEx(IDispatchEx *iface, DISPID id, LCID lc
             return E_FAIL;
         }
 
-        return invoke_builtin_prop(This, id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
+        return invoke_builtin_prop(dispex, this_obj, id, lcid, wFlags, pdp, res, pei, caller);
     default:
         assert(0);
         return E_FAIL;
     }
 }
 
-static HRESULT WINAPI DispatchEx_DeleteMemberByName(IDispatchEx *iface, BSTR name, DWORD grfdex)
+HRESULT dispex_delete_prop(DispatchEx *dispex, DISPID id)
 {
-    DispatchEx *This = impl_from_IDispatchEx(iface);
-    DISPID id;
     HRESULT hres;
 
-    TRACE("(%p)->(%s %lx)\n", This, debugstr_w(name), grfdex);
-
-    if(dispex_compat_mode(This) < COMPAT_MODE_IE8) {
-        /* Not implemented by IE */
-        return E_NOTIMPL;
-    }
-
-    hres = IDispatchEx_GetDispID(&This->IDispatchEx_iface, name, grfdex & ~fdexNameEnsure, &id);
-    if(FAILED(hres)) {
-        TRACE("property %s not found\n", debugstr_w(name));
-        return dispex_compat_mode(This) < COMPAT_MODE_IE9 ? hres : S_OK;
-    }
-
-    return IDispatchEx_DeleteMemberByDispID(&This->IDispatchEx_iface, id);
-}
-
-static HRESULT WINAPI DispatchEx_DeleteMemberByDispID(IDispatchEx *iface, DISPID id)
-{
-    DispatchEx *This = impl_from_IDispatchEx(iface);
-
-    TRACE("(%p)->(%lx)\n", This, id);
-
-    if(dispex_compat_mode(This) < COMPAT_MODE_IE8) {
-        /* Not implemented by IE */
-        return E_NOTIMPL;
-    }
-
-    if(is_dynamic_dispid(id)) {
+    switch(get_dispid_type(id)) {
+    case DISPEXPROP_CUSTOM:
+        if(dispex->info->desc->vtbl && dispex->info->desc->vtbl->delete)
+            return dispex->info->desc->vtbl->delete(dispex, id);
+        break;
+    case DISPEXPROP_DYNAMIC: {
         DWORD idx = id - DISPID_DYNPROP_0;
         dynamic_prop_t *prop;
 
-        if(!get_dynamic_data(This) || idx >= This->dynamic_data->prop_cnt)
+        if(!get_dynamic_data(dispex) || idx >= dispex->dynamic_data->prop_cnt)
             return S_OK;
 
-        prop = This->dynamic_data->props + idx;
-        VariantClear(&prop->var);
-        prop->flags |= DYNPROP_DELETED;
+        prop = dispex->dynamic_data->props + idx;
+        if(!(prop->flags & DYNPROP_PROTREF)) {
+            VariantClear(&prop->var);
+            prop->flags |= DYNPROP_DELETED;
+        }
         return S_OK;
     }
+    case DISPEXPROP_BUILTIN: {
+        func_info_t *func;
 
-    return S_OK;
-}
-
-static HRESULT WINAPI DispatchEx_GetMemberProperties(IDispatchEx *iface, DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
-{
-    DispatchEx *This = impl_from_IDispatchEx(iface);
-    FIXME("(%p)->(%lx %lx %p)\n", This, id, grfdexFetch, pgrfdex);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI DispatchEx_GetMemberName(IDispatchEx *iface, DISPID id, BSTR *pbstrName)
-{
-    DispatchEx *This = impl_from_IDispatchEx(iface);
-    func_info_t *func;
-    HRESULT hres;
-
-    TRACE("(%p)->(%lx %p)\n", This, id, pbstrName);
-
-    if(!ensure_real_info(This))
-        return E_OUTOFMEMORY;
-
-    if(is_dynamic_dispid(id)) {
-        DWORD idx = id - DISPID_DYNPROP_0;
-
-        if(!get_dynamic_data(This) || This->dynamic_data->prop_cnt <= idx)
-            return DISP_E_UNKNOWNNAME;
-
-        *pbstrName = SysAllocString(This->dynamic_data->props[idx].name);
-        if(!*pbstrName)
+        if(!ensure_real_info(dispex))
             return E_OUTOFMEMORY;
 
-        return S_OK;
-    }
-
-    hres = get_builtin_func(This->info, id, &func);
-    if(FAILED(hres))
-        return hres;
-
-    *pbstrName = SysAllocString(func->name);
-    if(!*pbstrName)
-        return E_OUTOFMEMORY;
-    return S_OK;
-}
-
-static HRESULT next_dynamic_id(DispatchEx *dispex, DWORD idx, DISPID *ret_id)
-{
-    while(idx < dispex->dynamic_data->prop_cnt && dispex->dynamic_data->props[idx].flags & DYNPROP_DELETED)
-        idx++;
-
-    if(idx == dispex->dynamic_data->prop_cnt) {
-        *ret_id = DISPID_STARTENUM;
-        return S_FALSE;
-    }
-
-    *ret_id = DISPID_DYNPROP_0+idx;
-    return S_OK;
-}
-
-static HRESULT WINAPI DispatchEx_GetNextDispID(IDispatchEx *iface, DWORD grfdex, DISPID id, DISPID *pid)
-{
-    DispatchEx *This = impl_from_IDispatchEx(iface);
-    func_info_t *func;
-    HRESULT hres;
-
-    TRACE("(%p)->(%lx %lx %p)\n", This, grfdex, id, pid);
-
-    if(!ensure_real_info(This))
-        return E_OUTOFMEMORY;
-
-    if(is_dynamic_dispid(id)) {
-        DWORD idx = id - DISPID_DYNPROP_0;
-
-        if(!get_dynamic_data(This) || This->dynamic_data->prop_cnt <= idx)
-            return DISP_E_UNKNOWNNAME;
-
-        return next_dynamic_id(This, idx+1, pid);
-    }
-
-    if(id == DISPID_STARTENUM) {
-        func = This->info->funcs;
-    }else {
-        hres = get_builtin_func(This->info, id, &func);
+        hres = get_builtin_func_prot(dispex, id, &func);
         if(FAILED(hres))
             return hres;
-        func++;
-    }
 
-    while(func < This->info->funcs + This->info->func_cnt) {
-        /* FIXME: Skip hidden properties */
-        if(func->func_disp_idx == -1) {
-            *pid = func->id;
-            return S_OK;
-        }
-        func++;
+        if(func->func_disp_idx != -1)
+            reset_builtin_func(dispex, func);
+        return S_OK;
+    }
+    default:
+        break;
     }
 
-    if(get_dynamic_data(This) && This->dynamic_data->prop_cnt)
-        return next_dynamic_id(This, 0, pid);
-
-    *pid = DISPID_STARTENUM;
-    return S_FALSE;
-}
-
-static HRESULT WINAPI DispatchEx_GetNameSpaceParent(IDispatchEx *iface, IUnknown **ppunk)
-{
-    DispatchEx *This = impl_from_IDispatchEx(iface);
-    FIXME("(%p)->(%p)\n", This, ppunk);
-    return E_NOTIMPL;
+    return S_OK;
 }
 
-static IDispatchExVtbl DispatchExVtbl = {
-    DispatchEx_QueryInterface,
-    DispatchEx_AddRef,
-    DispatchEx_Release,
-    DispatchEx_GetTypeInfoCount,
-    DispatchEx_GetTypeInfo,
-    DispatchEx_GetIDsOfNames,
-    DispatchEx_Invoke,
-    DispatchEx_GetDispID,
-    DispatchEx_InvokeEx,
-    DispatchEx_DeleteMemberByName,
-    DispatchEx_DeleteMemberByDispID,
-    DispatchEx_GetMemberProperties,
-    DispatchEx_GetMemberName,
-    DispatchEx_GetNextDispID,
-    DispatchEx_GetNameSpaceParent
-};
-
-BOOL dispex_query_interface(DispatchEx *This, REFIID riid, void **ppv)
+static void WINAPI dispex_traverse_cb(IDispatch *obj, void *cb)
 {
-    if(IsEqualGUID(&IID_IDispatch, riid))
-        *ppv = &This->IDispatchEx_iface;
-    else if(IsEqualGUID(&IID_IDispatchEx, riid))
-        *ppv = &This->IDispatchEx_iface;
-    else if(IsEqualGUID(&IID_IDispatchJS, riid))
-        *ppv = NULL;
-    else if(IsEqualGUID(&IID_UndocumentedScriptIface, riid))
-        *ppv = NULL;
-    else if(IsEqualGUID(&IID_IMarshal, riid))
-        *ppv = NULL;
-    else if(IsEqualGUID(&IID_IManagedObject, riid))
-        *ppv = NULL;
-    else
-        return FALSE;
-
-    if(*ppv)
-        IUnknown_AddRef((IUnknown*)*ppv);
-    return TRUE;
+    note_cc_edge((nsISupports*)obj, "dispex_data", cb);
 }
 
 void dispex_traverse(DispatchEx *This, nsCycleCollectionTraversalCallback *cb)
 {
     dynamic_prop_t *prop;
 
+    if(This->proxy)
+        This->proxy->lpVtbl->Traverse(This->proxy, dispex_traverse_cb, cb);
+
     if(!This->dynamic_data)
         return;
 
@@ -1992,6 +3490,12 @@ void release_dispex(DispatchEx *This)
 {
     dynamic_prop_t *prop;
 
+    if(This->proxy)
+        This->proxy->lpVtbl->Unlinked(This->proxy);
+
+    if(This->prototype)
+        IUnknown_Release(&This->prototype->IUnknown_iface);
+
     if(!This->dynamic_data)
         return;
 
@@ -2019,14 +3523,8 @@ void release_dispex(DispatchEx *This)
     heap_free(This->dynamic_data);
 }
 
-void init_dispatch(DispatchEx *dispex, IUnknown *outer, dispex_static_data_t *data, compat_mode_t compat_mode)
+void update_dispex(DispatchEx *dispex, dispex_static_data_t *data, HTMLDocumentNode *doc, compat_mode_t compat_mode)
 {
-    assert(compat_mode < COMPAT_MODE_CNT);
-
-    dispex->IDispatchEx_iface.lpVtbl = &DispatchExVtbl;
-    dispex->outer = outer;
-    dispex->dynamic_data = NULL;
-
     if(data->vtbl && data->vtbl->get_compat_mode) {
         /* delayed init */
         if(!data->delayed_init_info) {
@@ -2044,4 +3542,21 @@ void init_dispatch(DispatchEx *dispex, IUnknown *outer, dispex_static_data_t *da
     }else {
         dispex->info = ensure_dispex_info(data, compat_mode);
     }
+
+    if(doc && doc->window && data->prototype_id < ARRAY_SIZE(doc->window->compat_prototypes))
+        dispex->prototype = get_compat_prototype(doc->window, data->prototype_id, compat_mode);
+}
+
+void init_dispatch(DispatchEx *dispex, IUnknown *outer, dispex_static_data_t *data, HTMLDocumentNode *doc,
+        compat_mode_t compat_mode)
+{
+    assert(compat_mode < COMPAT_MODE_CNT);
+
+    dispex->IDispatchEx_iface.lpVtbl = (const IDispatchExVtbl*)&WineDispatchProxyPrivateVtbl;
+    dispex->outer = outer;
+    dispex->proxy = NULL;
+    dispex->prototype = NULL;
+    dispex->dynamic_data = NULL;
+
+    update_dispex(dispex, data, doc, compat_mode);
 }
diff --git a/dlls/mshtml/editor.c b/dlls/mshtml/editor.c
index d21616288e6..4c31fe4c896 100644
--- a/dlls/mshtml/editor.c
+++ b/dlls/mshtml/editor.c
@@ -183,8 +183,13 @@ static DWORD query_align_status(HTMLDocumentNode *doc, const WCHAR *align)
     if(doc->browser->usermode != EDITMODE || doc->basedoc.window->readystate < READYSTATE_INTERACTIVE)
         return OLECMDF_SUPPORTED;
 
+    if(!doc->nshtmldoc) {
+        FIXME("Not implemented for XML document\n");
+        return E_NOTIMPL;
+    }
+
     nsAString_Init(&justify_str, align);
-    nsres = nsIDOMHTMLDocument_QueryCommandState(doc->nsdoc, &justify_str, &b);
+    nsres = nsIDOMHTMLDocument_QueryCommandState(doc->nshtmldoc, &justify_str, &b);
     nsAString_Finish(&justify_str);
     if(NS_SUCCEEDED(nsres) && b)
         ret |= OLECMDF_LATCHED;
@@ -1105,7 +1110,7 @@ static HRESULT exec_hyperlink(HTMLDocumentNode *doc, DWORD cmdexecopt, VARIANT *
         nsIDOMNode *unused_node;
         nsIDOMText *text_node;
 
-        nsIDOMHTMLDocument_CreateTextNode(doc->nsdoc, &ns_url, &text_node);
+        nsIDOMDocument_CreateTextNode(doc->nsdoc, &ns_url, &text_node);
 
         /* wrap the <a> tags around the text element */
         nsIDOMElement_AppendChild(anchor_elem, (nsIDOMNode*)text_node, &unused_node);
diff --git a/dlls/mshtml/htmlanchor.c b/dlls/mshtml/htmlanchor.c
index cfe49ac05bd..f384d064832 100644
--- a/dlls/mshtml/htmlanchor.c
+++ b/dlls/mshtml/htmlanchor.c
@@ -890,9 +890,10 @@ static const tid_t HTMLAnchorElement_iface_tids[] = {
     0
 };
 
-static dispex_static_data_t HTMLAnchorElement_dispex = {
+dispex_static_data_t HTMLAnchorElement_dispex = {
     L"HTMLAnchorElement",
     NULL,
+    PROTO_ID_HTMLAnchorElement,
     DispHTMLAnchorElement_tid,
     HTMLAnchorElement_iface_tids,
     HTMLElement_init_dispex_info
diff --git a/dlls/mshtml/htmlarea.c b/dlls/mshtml/htmlarea.c
index 9e43a7b0e80..24f27aa5235 100644
--- a/dlls/mshtml/htmlarea.c
+++ b/dlls/mshtml/htmlarea.c
@@ -476,9 +476,10 @@ static const tid_t HTMLAreaElement_iface_tids[] = {
     IHTMLAreaElement_tid,
     0
 };
-static dispex_static_data_t HTMLAreaElement_dispex = {
+dispex_static_data_t HTMLAreaElement_dispex = {
     L"HTMLAreaElement",
     NULL,
+    PROTO_ID_HTMLAreaElement,
     DispHTMLAreaElement_tid,
     HTMLAreaElement_iface_tids,
     HTMLElement_init_dispex_info
diff --git a/dlls/mshtml/htmlattr.c b/dlls/mshtml/htmlattr.c
index 7365b9ea63f..194f4a5a73a 100644
--- a/dlls/mshtml/htmlattr.c
+++ b/dlls/mshtml/htmlattr.c
@@ -42,6 +42,9 @@ static HRESULT WINAPI HTMLDOMAttribute_QueryInterface(IHTMLDOMAttribute *iface,
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute(iface);
 
+    if(This->node.nsnode)
+        return IHTMLDOMNode_QueryInterface(&This->node.IHTMLDOMNode_iface, riid, ppv);
+
     TRACE("(%p)->(%s %p)\n", This, debugstr_mshtml_guid(riid), ppv);
 
     if(IsEqualGUID(&IID_IUnknown, riid)) {
@@ -50,7 +53,7 @@ static HRESULT WINAPI HTMLDOMAttribute_QueryInterface(IHTMLDOMAttribute *iface,
         *ppv = &This->IHTMLDOMAttribute_iface;
     }else if(IsEqualGUID(&IID_IHTMLDOMAttribute2, riid)) {
         *ppv = &This->IHTMLDOMAttribute2_iface;
-    }else if(dispex_query_interface(&This->dispex, riid, ppv)) {
+    }else if(dispex_query_interface(&This->node.event_target.dispex, riid, ppv)) {
         return *ppv ? S_OK : E_NOINTERFACE;
     }else {
         WARN("%s not supported\n", debugstr_mshtml_guid(riid));
@@ -65,7 +68,11 @@ static HRESULT WINAPI HTMLDOMAttribute_QueryInterface(IHTMLDOMAttribute *iface,
 static ULONG WINAPI HTMLDOMAttribute_AddRef(IHTMLDOMAttribute *iface)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute(iface);
-    LONG ref = InterlockedIncrement(&This->ref);
+    LONG ref;
+
+    if(This->node.nsnode)
+        return IHTMLDOMNode_AddRef(&This->node.IHTMLDOMNode_iface);
+    ref = InterlockedIncrement(&This->ref);
 
     TRACE("(%p) ref=%ld\n", This, ref);
 
@@ -75,13 +82,17 @@ static ULONG WINAPI HTMLDOMAttribute_AddRef(IHTMLDOMAttribute *iface)
 static ULONG WINAPI HTMLDOMAttribute_Release(IHTMLDOMAttribute *iface)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute(iface);
-    LONG ref = InterlockedDecrement(&This->ref);
+    LONG ref;
+
+    if(This->node.nsnode)
+        return IHTMLDOMNode_Release(&This->node.IHTMLDOMNode_iface);
+    ref = InterlockedDecrement(&This->ref);
 
     TRACE("(%p) ref=%ld\n", This, ref);
 
     if(!ref) {
         assert(!This->elem);
-        release_dispex(&This->dispex);
+        release_dispex(&This->node.event_target.dispex);
         VariantClear(&This->value);
         heap_free(This->name);
         heap_free(This);
@@ -93,14 +104,14 @@ static ULONG WINAPI HTMLDOMAttribute_Release(IHTMLDOMAttribute *iface)
 static HRESULT WINAPI HTMLDOMAttribute_GetTypeInfoCount(IHTMLDOMAttribute *iface, UINT *pctinfo)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute(iface);
-    return IDispatchEx_GetTypeInfoCount(&This->dispex.IDispatchEx_iface, pctinfo);
+    return IDispatchEx_GetTypeInfoCount(&This->node.event_target.dispex.IDispatchEx_iface, pctinfo);
 }
 
 static HRESULT WINAPI HTMLDOMAttribute_GetTypeInfo(IHTMLDOMAttribute *iface, UINT iTInfo,
                                               LCID lcid, ITypeInfo **ppTInfo)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute(iface);
-    return IDispatchEx_GetTypeInfo(&This->dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
+    return IDispatchEx_GetTypeInfo(&This->node.event_target.dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
 }
 
 static HRESULT WINAPI HTMLDOMAttribute_GetIDsOfNames(IHTMLDOMAttribute *iface, REFIID riid,
@@ -108,7 +119,7 @@ static HRESULT WINAPI HTMLDOMAttribute_GetIDsOfNames(IHTMLDOMAttribute *iface, R
                                                 LCID lcid, DISPID *rgDispId)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute(iface);
-    return IDispatchEx_GetIDsOfNames(&This->dispex.IDispatchEx_iface, riid, rgszNames, cNames,
+    return IDispatchEx_GetIDsOfNames(&This->node.event_target.dispex.IDispatchEx_iface, riid, rgszNames, cNames,
             lcid, rgDispId);
 }
 
@@ -117,7 +128,7 @@ static HRESULT WINAPI HTMLDOMAttribute_Invoke(IHTMLDOMAttribute *iface, DISPID d
                             VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute(iface);
-    return IDispatchEx_Invoke(&This->dispex.IDispatchEx_iface, dispIdMember, riid, lcid,
+    return IDispatchEx_Invoke(&This->node.event_target.dispex.IDispatchEx_iface, dispIdMember, riid, lcid,
             wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
 }
 
@@ -125,6 +136,9 @@ static HRESULT WINAPI HTMLDOMAttribute_get_nodeName(IHTMLDOMAttribute *iface, BS
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute(iface);
 
+    if(This->node.nsnode)
+        return IHTMLDOMNode_get_nodeName(&This->node.IHTMLDOMNode_iface, p);
+
     TRACE("(%p)->(%p)\n", This, p);
 
     if(!This->elem) {
@@ -148,6 +162,9 @@ static HRESULT WINAPI HTMLDOMAttribute_put_nodeValue(IHTMLDOMAttribute *iface, V
     EXCEPINFO ei;
     VARIANT ret;
 
+    if(This->node.nsnode)
+        return IHTMLDOMNode_put_nodeValue(&This->node.IHTMLDOMNode_iface, v);
+
     TRACE("(%p)->(%s)\n", This, debugstr_variant(&v));
 
     if(!This->elem)
@@ -163,6 +180,9 @@ static HRESULT WINAPI HTMLDOMAttribute_get_nodeValue(IHTMLDOMAttribute *iface, V
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute(iface);
 
+    if(This->node.nsnode)
+        return IHTMLDOMNode_get_nodeValue(&This->node.IHTMLDOMNode_iface, p);
+
     TRACE("(%p)->(%p)\n", This, p);
 
     if(!This->elem)
@@ -179,15 +199,22 @@ static HRESULT WINAPI HTMLDOMAttribute_get_specified(IHTMLDOMAttribute *iface, V
     BSTR name;
     nsresult nsres;
     HRESULT hres;
+    cpp_bool b;
 
     TRACE("(%p)->(%p)\n", This, p);
 
+    if(This->node.nsnode) {
+        nsres = nsIDOMAttr_GetSpecified((nsIDOMAttr*)This->node.nsnode, &b);
+        *p = variant_bool(NS_SUCCEEDED(nsres) && b);
+        return S_OK;
+    }
+
     if(!This->elem || !This->elem->dom_element) {
-        FIXME("NULL This->elem\n");
-        return E_UNEXPECTED;
+        *p = VARIANT_FALSE;
+        return S_OK;
     }
 
-    if(get_dispid_type(This->dispid) != DISPEXPROP_BUILTIN) {
+    if(!dispex_is_builtin_value(&This->elem->node.event_target.dispex, This->dispid)) {
         *p = VARIANT_TRUE;
         return S_OK;
     }
@@ -255,21 +282,21 @@ static ULONG WINAPI HTMLDOMAttribute2_Release(IHTMLDOMAttribute2 *iface)
 static HRESULT WINAPI HTMLDOMAttribute2_GetTypeInfoCount(IHTMLDOMAttribute2 *iface, UINT *pctinfo)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
-    return IDispatchEx_GetTypeInfoCount(&This->dispex.IDispatchEx_iface, pctinfo);
+    return IDispatchEx_GetTypeInfoCount(&This->node.event_target.dispex.IDispatchEx_iface, pctinfo);
 }
 
 static HRESULT WINAPI HTMLDOMAttribute2_GetTypeInfo(IHTMLDOMAttribute2 *iface, UINT iTInfo,
         LCID lcid, ITypeInfo **ppTInfo)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
-    return IDispatchEx_GetTypeInfo(&This->dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
+    return IDispatchEx_GetTypeInfo(&This->node.event_target.dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
 }
 
 static HRESULT WINAPI HTMLDOMAttribute2_GetIDsOfNames(IHTMLDOMAttribute2 *iface, REFIID riid,
         LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
-    return IDispatchEx_GetIDsOfNames(&This->dispex.IDispatchEx_iface, riid, rgszNames, cNames,
+    return IDispatchEx_GetIDsOfNames(&This->node.event_target.dispex.IDispatchEx_iface, riid, rgszNames, cNames,
             lcid, rgDispId);
 }
 
@@ -278,24 +305,42 @@ static HRESULT WINAPI HTMLDOMAttribute2_Invoke(IHTMLDOMAttribute2 *iface, DISPID
         VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
-    return IDispatchEx_Invoke(&This->dispex.IDispatchEx_iface, dispIdMember, riid, lcid,
+    return IDispatchEx_Invoke(&This->node.event_target.dispex.IDispatchEx_iface, dispIdMember, riid, lcid,
             wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
 }
 
 static HRESULT WINAPI HTMLDOMAttribute2_get_name(IHTMLDOMAttribute2 *iface, BSTR *p)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
+    nsAString nsstr;
+    nsresult nsres;
+
+    TRACE("(%p)->(%p)\n", This, p);
+
+    if(This->node.nsnode) {
+        nsres = nsIDOMAttr_GetName((nsIDOMAttr*)This->node.nsnode, &nsstr);
+        return return_nsstr(nsres, &nsstr, p);
+    }
+
+    return IHTMLDOMAttribute_get_nodeName(&This->IHTMLDOMAttribute_iface, p);
 }
 
 static HRESULT WINAPI HTMLDOMAttribute2_put_value(IHTMLDOMAttribute2 *iface, BSTR v)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
+    nsAString nsstr;
+    nsresult nsres;
     VARIANT var;
 
     TRACE("(%p)->(%s)\n", This, debugstr_w(v));
 
+    if(This->node.nsnode) {
+        nsAString_InitDepend(&nsstr, v);
+        nsres = nsIDOMAttr_SetValue((nsIDOMAttr*)This->node.nsnode, &nsstr);
+        nsAString_Finish(&nsstr);
+        return NS_SUCCEEDED(nsres) ? S_OK : E_FAIL;
+    }
+
     V_VT(&var) = VT_BSTR;
     V_BSTR(&var) = v;
     return IHTMLDOMAttribute_put_nodeValue(&This->IHTMLDOMAttribute_iface, var);
@@ -304,11 +349,18 @@ static HRESULT WINAPI HTMLDOMAttribute2_put_value(IHTMLDOMAttribute2 *iface, BST
 static HRESULT WINAPI HTMLDOMAttribute2_get_value(IHTMLDOMAttribute2 *iface, BSTR *p)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
+    nsAString nsstr;
+    nsresult nsres;
     VARIANT val;
     HRESULT hres;
 
     TRACE("(%p)->(%p)\n", This, p);
 
+    if(This->node.nsnode) {
+        nsres = nsIDOMAttr_GetValue((nsIDOMAttr*)This->node.nsnode, &nsstr);
+        return return_nsstr(nsres, &nsstr, p);
+    }
+
     V_VT(&val) = VT_EMPTY;
     if(This->elem)
         hres = get_elem_attr_value_by_dispid(This->elem, This->dispid, &val);
@@ -332,14 +384,19 @@ static HRESULT WINAPI HTMLDOMAttribute2_get_expando(IHTMLDOMAttribute2 *iface, V
 
     TRACE("(%p)->(%p)\n", This, p);
 
-    *p = variant_bool(This->elem && get_dispid_type(This->dispid) != DISPEXPROP_BUILTIN);
+    *p = variant_bool(This->elem && !dispex_is_builtin_attribute(&This->elem->node.event_target.dispex, This->dispid));
     return S_OK;
 }
 
 static HRESULT WINAPI HTMLDOMAttribute2_get_nodeType(IHTMLDOMAttribute2 *iface, LONG *p)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
+
+    if(This->node.nsnode)
+        return IHTMLDOMNode_get_nodeType(&This->node.IHTMLDOMNode_iface, p);
+
     FIXME("(%p)->(%p)\n", This, p);
+
     return E_NOTIMPL;
 }
 
@@ -347,6 +404,9 @@ static HRESULT WINAPI HTMLDOMAttribute2_get_parentNode(IHTMLDOMAttribute2 *iface
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
 
+    if(This->node.nsnode)
+        return IHTMLDOMNode_get_parentNode(&This->node.IHTMLDOMNode_iface, p);
+
     TRACE("(%p)->(%p)\n", This, p);
 
     *p = NULL;
@@ -356,49 +416,84 @@ static HRESULT WINAPI HTMLDOMAttribute2_get_parentNode(IHTMLDOMAttribute2 *iface
 static HRESULT WINAPI HTMLDOMAttribute2_get_childNodes(IHTMLDOMAttribute2 *iface, IDispatch **p)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
+
+    if(This->node.nsnode)
+        return IHTMLDOMNode_get_childNodes(&This->node.IHTMLDOMNode_iface, p);
+
     FIXME("(%p)->(%p)\n", This, p);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI HTMLDOMAttribute2_get_firstChild(IHTMLDOMAttribute2 *iface, IHTMLDOMNode **p)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
+
+    if(This->node.nsnode)
+        return IHTMLDOMNode_get_firstChild(&This->node.IHTMLDOMNode_iface, p);
+
     FIXME("(%p)->(%p)\n", This, p);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI HTMLDOMAttribute2_get_lastChild(IHTMLDOMAttribute2 *iface, IHTMLDOMNode **p)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
+
+    if(This->node.nsnode)
+        return IHTMLDOMNode_get_lastChild(&This->node.IHTMLDOMNode_iface, p);
+
     FIXME("(%p)->(%p)\n", This, p);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI HTMLDOMAttribute2_get_previousSibling(IHTMLDOMAttribute2 *iface, IHTMLDOMNode **p)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
+
+    if(This->node.nsnode)
+        return IHTMLDOMNode_get_previousSibling(&This->node.IHTMLDOMNode_iface, p);
+
     FIXME("(%p)->(%p)\n", This, p);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI HTMLDOMAttribute2_get_nextSibling(IHTMLDOMAttribute2 *iface, IHTMLDOMNode **p)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
+
+    if(This->node.nsnode)
+        return IHTMLDOMNode_get_nextSibling(&This->node.IHTMLDOMNode_iface, p);
+
     FIXME("(%p)->(%p)\n", This, p);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI HTMLDOMAttribute2_get_attributes(IHTMLDOMAttribute2 *iface, IDispatch **p)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
+
+    if(This->node.nsnode)
+        return IHTMLDOMNode_get_attributes(&This->node.IHTMLDOMNode_iface, p);
+
     FIXME("(%p)->(%p)\n", This, p);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI HTMLDOMAttribute2_get_ownerDocument(IHTMLDOMAttribute2 *iface, IDispatch **p)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
+
+    if(This->node.nsnode)
+        return IHTMLDOMNode2_get_ownerDocument(&This->node.IHTMLDOMNode2_iface, p);
+
     FIXME("(%p)->(%p)\n", This, p);
+
     return E_NOTIMPL;
 }
 
@@ -406,7 +501,12 @@ static HRESULT WINAPI HTMLDOMAttribute2_insertBefore(IHTMLDOMAttribute2 *iface,
         VARIANT refChild, IHTMLDOMNode **node)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
+
+    if(This->node.nsnode)
+        return IHTMLDOMNode_insertBefore(&This->node.IHTMLDOMNode_iface, newChild, refChild, node);
+
     FIXME("(%p)->(%p %s %p)\n", This, newChild, debugstr_variant(&refChild), node);
+
     return E_NOTIMPL;
 }
 
@@ -414,7 +514,12 @@ static HRESULT WINAPI HTMLDOMAttribute2_replaceChild(IHTMLDOMAttribute2 *iface,
         IHTMLDOMNode *oldChild, IHTMLDOMNode **node)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
+
+    if(This->node.nsnode)
+        return IHTMLDOMNode_replaceChild(&This->node.IHTMLDOMNode_iface, newChild, oldChild, node);
+
     FIXME("(%p)->(%p %p %p)\n", This, newChild, oldChild, node);
+
     return E_NOTIMPL;
 }
 
@@ -422,7 +527,12 @@ static HRESULT WINAPI HTMLDOMAttribute2_removeChild(IHTMLDOMAttribute2 *iface, I
         IHTMLDOMNode **node)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
+
+    if(This->node.nsnode)
+        return IHTMLDOMNode_removeChild(&This->node.IHTMLDOMNode_iface, oldChild, node);
+
     FIXME("(%p)->(%p %p)\n", This, oldChild, node);
+
     return E_NOTIMPL;
 }
 
@@ -430,14 +540,24 @@ static HRESULT WINAPI HTMLDOMAttribute2_appendChild(IHTMLDOMAttribute2 *iface, I
         IHTMLDOMNode **node)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
+
+    if(This->node.nsnode)
+        return IHTMLDOMNode_appendChild(&This->node.IHTMLDOMNode_iface, newChild, node);
+
     FIXME("(%p)->(%p %p)\n", This, newChild, node);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI HTMLDOMAttribute2_hasChildNodes(IHTMLDOMAttribute2 *iface, VARIANT_BOOL *fChildren)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
+
+    if(This->node.nsnode)
+        return IHTMLDOMNode_hasChildNodes(&This->node.IHTMLDOMNode_iface, fChildren);
+
     FIXME("(%p)->(%p)\n", This, fChildren);
+
     return E_NOTIMPL;
 }
 
@@ -445,7 +565,20 @@ static HRESULT WINAPI HTMLDOMAttribute2_cloneNode(IHTMLDOMAttribute2 *iface, VAR
         IHTMLDOMAttribute **clonedNode)
 {
     HTMLDOMAttribute *This = impl_from_IHTMLDOMAttribute2(iface);
+    HRESULT hres;
+
+    if(This->node.nsnode) {
+        IHTMLDOMNode *cloned;
+        hres = IHTMLDOMNode_cloneNode(&This->node.IHTMLDOMNode_iface, fDeep, &cloned);
+        if(SUCCEEDED(hres)) {
+            hres = IHTMLDOMNode_QueryInterface(cloned, &IID_IHTMLDOMAttribute, (void**)clonedNode);
+            IHTMLDOMNode_Release(cloned);
+        }
+        return hres;
+    }
+
     FIXME("(%p)->(%x %p)\n", This, fDeep, clonedNode);
+
     return E_NOTIMPL;
 }
 
@@ -478,16 +611,85 @@ static const IHTMLDOMAttribute2Vtbl HTMLDOMAttribute2Vtbl = {
     HTMLDOMAttribute2_cloneNode
 };
 
+static inline HTMLDOMAttribute *impl_from_HTMLDOMNode(HTMLDOMNode *iface)
+{
+    return CONTAINING_RECORD(iface, HTMLDOMAttribute, node);
+}
+
+static HRESULT HTMLDOMAttribute_QI(HTMLDOMNode *iface, REFIID riid, void **ppv)
+{
+    HTMLDOMAttribute *This = impl_from_HTMLDOMNode(iface);
+
+    *ppv =  NULL;
+
+    if(IsEqualGUID(&IID_IUnknown, riid) || IsEqualGUID(&IID_IHTMLDOMAttribute, riid)) {
+        *ppv = &This->IHTMLDOMAttribute_iface;
+    }else if(IsEqualGUID(&IID_IHTMLDOMAttribute2, riid)) {
+        *ppv = &This->IHTMLDOMAttribute2_iface;
+    }else {
+        return HTMLDOMNode_QI(&This->node, riid, ppv);
+    }
+
+    IUnknown_AddRef((IUnknown*)*ppv);
+    return S_OK;
+}
+
+static HRESULT HTMLDOMAttribute_clone(HTMLDOMNode *iface, nsIDOMNode *nsnode, HTMLDOMNode **ret)
+{
+    HTMLDOMAttribute *This = impl_from_HTMLDOMNode(iface);
+    HTMLDOMAttribute *new_attr;
+    nsIDOMAttr *nsattr;
+    nsresult nsres;
+    HRESULT hres;
+
+    nsres = nsIDOMNode_QueryInterface(nsnode, &IID_nsIDOMAttr, (void**)&nsattr);
+    if(NS_FAILED(nsres)) {
+        ERR("no nsIDOMAttr iface\n");
+        return E_FAIL;
+    }
+
+    hres = HTMLDOMAttribute_Create(NULL, This->node.doc, This->elem, This->dispid, nsattr,
+                                   dispex_compat_mode(&This->node.event_target.dispex), &new_attr);
+    nsIDOMAttr_Release(nsattr);
+    if(FAILED(hres))
+        return hres;
+
+    *ret = &new_attr->node;
+    return S_OK;
+}
+
+static const cpc_entry_t HTMLDOMAttribute_cpc[] = {{NULL}};
+
+static const NodeImplVtbl HTMLDOMAttributeImplVtbl = {
+    NULL,
+    HTMLDOMAttribute_QI,
+    HTMLDOMNode_destructor,
+    HTMLDOMAttribute_cpc,
+    HTMLDOMAttribute_clone
+};
+
+static void HTMLDOMAttribute_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
+{
+    HTMLDOMNode_init_dispex_info(info, mode);
+
+    if(mode >= COMPAT_MODE_IE9) {
+        dispex_info_add_interface(info, IHTMLDOMNode_tid, NULL);
+        dispex_info_add_interface(info, IHTMLDOMNode2_tid, NULL);
+    }
+}
+
 static const tid_t HTMLDOMAttribute_iface_tids[] = {
     IHTMLDOMAttribute_tid,
     IHTMLDOMAttribute2_tid,
     0
 };
-static dispex_static_data_t HTMLDOMAttribute_dispex = {
+dispex_static_data_t HTMLDOMAttribute_dispex = {
     L"Attr",
     NULL,
+    PROTO_ID_HTMLDOMAttribute,
     DispHTMLDOMAttribute_tid,
-    HTMLDOMAttribute_iface_tids
+    HTMLDOMAttribute_iface_tids,
+    HTMLDOMAttribute_init_dispex_info
 };
 
 HTMLDOMAttribute *unsafe_impl_from_IHTMLDOMAttribute(IHTMLDOMAttribute *iface)
@@ -495,7 +697,8 @@ HTMLDOMAttribute *unsafe_impl_from_IHTMLDOMAttribute(IHTMLDOMAttribute *iface)
     return iface->lpVtbl == &HTMLDOMAttributeVtbl ? impl_from_IHTMLDOMAttribute(iface) : NULL;
 }
 
-HRESULT HTMLDOMAttribute_Create(const WCHAR *name, HTMLElement *elem, DISPID dispid, compat_mode_t compat_mode, HTMLDOMAttribute **attr)
+HRESULT HTMLDOMAttribute_Create(const WCHAR *name, HTMLDocumentNode *doc, HTMLElement *elem, DISPID dispid,
+        nsIDOMAttr *nsattr, compat_mode_t compat_mode, HTMLDOMAttribute **attr)
 {
     HTMLAttributeCollection *col;
     HTMLDOMAttribute *ret;
@@ -511,14 +714,12 @@ HRESULT HTMLDOMAttribute_Create(const WCHAR *name, HTMLElement *elem, DISPID dis
     ret->dispid = dispid;
     ret->elem = elem;
 
-    init_dispatch(&ret->dispex, (IUnknown*)&ret->IHTMLDOMAttribute_iface,
-                  &HTMLDOMAttribute_dispex, compat_mode);
-
-    /* For attributes attached to an element, (elem,dispid) pair should be valid used for its operation. */
+    /* For attributes attached to an element, (elem,dispid) pair should
+       be valid used for its operation if we don't have a proper node. */
     if(elem) {
         hres = HTMLElement_get_attr_col(&elem->node, &col);
         if(FAILED(hres)) {
-            IHTMLDOMAttribute_Release(&ret->IHTMLDOMAttribute_iface);
+            heap_free(ret);
             return hres;
         }
         IHTMLAttributeCollection_Release(&col->IHTMLAttributeCollection_iface);
@@ -526,6 +727,17 @@ HRESULT HTMLDOMAttribute_Create(const WCHAR *name, HTMLElement *elem, DISPID dis
         list_add_tail(&elem->attrs->attrs, &ret->entry);
     }
 
+    /* If we have a nsattr, use proper node */
+    if(nsattr) {
+        ret->node.vtbl = &HTMLDOMAttributeImplVtbl;
+        HTMLDOMNode_Init(doc, &ret->node, (nsIDOMNode*)nsattr, &HTMLDOMAttribute_dispex);
+        *attr = ret;
+        return S_OK;
+    }
+
+    init_dispatch(&ret->node.event_target.dispex, (IUnknown*)&ret->IHTMLDOMAttribute_iface,
+                  &HTMLDOMAttribute_dispex, doc, compat_mode);
+
     /* For detached attributes we may still do most operations if we have its name available. */
     if(name) {
         ret->name = heap_strdupW(name);
diff --git a/dlls/mshtml/htmlbody.c b/dlls/mshtml/htmlbody.c
index 663a75d2e2a..b5584a8ef3e 100644
--- a/dlls/mshtml/htmlbody.c
+++ b/dlls/mshtml/htmlbody.c
@@ -674,7 +674,7 @@ static HRESULT WINAPI HTMLBodyElement_createTextRange(IHTMLBodyElement *iface, I
         return E_UNEXPECTED;
     }
 
-    nsres = nsIDOMHTMLDocument_CreateRange(This->element.node.doc->nsdoc, &nsrange);
+    nsres = nsIDOMDocument_CreateRange(This->element.node.doc->nsdoc, &nsrange);
     if(NS_SUCCEEDED(nsres)) {
         nsres = nsIDOMRange_SelectNodeContents(nsrange, This->element.node.nsnode);
         if(NS_FAILED(nsres))
@@ -1007,9 +1007,10 @@ static const tid_t HTMLBodyElement_iface_tids[] = {
     0
 };
 
-static dispex_static_data_t HTMLBodyElement_dispex = {
+dispex_static_data_t HTMLBodyElement_dispex = {
     L"HTMLBodyElement",
     NULL,
+    PROTO_ID_HTMLBodyElement,
     DispHTMLBody_tid,
     HTMLBodyElement_iface_tids,
     HTMLElement_init_dispex_info
diff --git a/dlls/mshtml/htmlcomment.c b/dlls/mshtml/htmlcomment.c
index a9843858a9b..701ac38a178 100644
--- a/dlls/mshtml/htmlcomment.c
+++ b/dlls/mshtml/htmlcomment.c
@@ -35,6 +35,8 @@ WINE_DEFAULT_DEBUG_CHANNEL(mshtml);
 struct HTMLCommentElement {
     HTMLElement element;
     IHTMLCommentElement IHTMLCommentElement_iface;
+    IHTMLDOMTextNode IHTMLDOMTextNode_iface;
+    IHTMLDOMTextNode2 IHTMLDOMTextNode2_iface;
 };
 
 static inline HTMLCommentElement *impl_from_IHTMLCommentElement(IHTMLCommentElement *iface)
@@ -140,6 +142,220 @@ static const IHTMLCommentElementVtbl HTMLCommentElementVtbl = {
     HTMLCommentElement_get_atomic
 };
 
+static inline HTMLCommentElement *impl_from_IHTMLDOMTextNode(IHTMLDOMTextNode *iface)
+{
+    return CONTAINING_RECORD(iface, HTMLCommentElement, IHTMLDOMTextNode_iface);
+}
+
+static HRESULT WINAPI HTMLCommentElement_TextNode_QueryInterface(IHTMLDOMTextNode *iface,
+                                                 REFIID riid, void **ppv)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode(iface);
+
+    return IHTMLDOMNode_QueryInterface(&This->element.node.IHTMLDOMNode_iface, riid, ppv);
+}
+
+static ULONG WINAPI HTMLCommentElement_TextNode_AddRef(IHTMLDOMTextNode *iface)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode(iface);
+
+    return IHTMLDOMNode_AddRef(&This->element.node.IHTMLDOMNode_iface);
+}
+
+static ULONG WINAPI HTMLCommentElement_TextNode_Release(IHTMLDOMTextNode *iface)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode(iface);
+
+    return IHTMLDOMNode_Release(&This->element.node.IHTMLDOMNode_iface);
+}
+
+static HRESULT WINAPI HTMLCommentElement_TextNode_GetTypeInfoCount(IHTMLDOMTextNode *iface, UINT *pctinfo)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode(iface);
+    return IDispatchEx_GetTypeInfoCount(&This->element.node.event_target.dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI HTMLCommentElement_TextNode_GetTypeInfo(IHTMLDOMTextNode *iface, UINT iTInfo,
+                                              LCID lcid, ITypeInfo **ppTInfo)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode(iface);
+    return IDispatchEx_GetTypeInfo(&This->element.node.event_target.dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
+}
+
+static HRESULT WINAPI HTMLCommentElement_TextNode_GetIDsOfNames(IHTMLDOMTextNode *iface, REFIID riid,
+                                                LPOLESTR *rgszNames, UINT cNames,
+                                                LCID lcid, DISPID *rgDispId)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode(iface);
+    return IDispatchEx_GetIDsOfNames(&This->element.node.event_target.dispex.IDispatchEx_iface, riid, rgszNames, cNames,
+            lcid, rgDispId);
+}
+
+static HRESULT WINAPI HTMLCommentElement_TextNode_Invoke(IHTMLDOMTextNode *iface, DISPID dispIdMember,
+                            REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+                            VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode(iface);
+    return IDispatchEx_Invoke(&This->element.node.event_target.dispex.IDispatchEx_iface, dispIdMember, riid, lcid,
+            wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI HTMLCommentElement_TextNode_put_data(IHTMLDOMTextNode *iface, BSTR v)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCommentElement_TextNode_get_data(IHTMLDOMTextNode *iface, BSTR *p)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCommentElement_TextNode_toString(IHTMLDOMTextNode *iface, BSTR *String)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode(iface);
+    WARN("(%p)->(%p)\n", This, String);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCommentElement_TextNode_get_length(IHTMLDOMTextNode *iface, LONG *p)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCommentElement_TextNode_splitText(IHTMLDOMTextNode *iface, LONG offset, IHTMLDOMNode **pRetNode)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode(iface);
+    WARN("(%p)->(%ld %p)\n", This, offset, pRetNode);
+    return E_UNEXPECTED;
+}
+
+static const IHTMLDOMTextNodeVtbl HTMLCommentElement_TextNodeVtbl = {
+    HTMLCommentElement_TextNode_QueryInterface,
+    HTMLCommentElement_TextNode_AddRef,
+    HTMLCommentElement_TextNode_Release,
+    HTMLCommentElement_TextNode_GetTypeInfoCount,
+    HTMLCommentElement_TextNode_GetTypeInfo,
+    HTMLCommentElement_TextNode_GetIDsOfNames,
+    HTMLCommentElement_TextNode_Invoke,
+    HTMLCommentElement_TextNode_put_data,
+    HTMLCommentElement_TextNode_get_data,
+    HTMLCommentElement_TextNode_toString,
+    HTMLCommentElement_TextNode_get_length,
+    HTMLCommentElement_TextNode_splitText
+};
+
+static inline HTMLCommentElement *impl_from_IHTMLDOMTextNode2(IHTMLDOMTextNode2 *iface)
+{
+    return CONTAINING_RECORD(iface, HTMLCommentElement, IHTMLDOMTextNode2_iface);
+}
+
+static HRESULT WINAPI HTMLCommentElement_TextNode2_QueryInterface(IHTMLDOMTextNode2 *iface, REFIID riid, void **ppv)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode2(iface);
+
+    return IHTMLDOMNode_QueryInterface(&This->element.node.IHTMLDOMNode_iface, riid, ppv);
+}
+
+static ULONG WINAPI HTMLCommentElement_TextNode2_AddRef(IHTMLDOMTextNode2 *iface)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode2(iface);
+
+    return IHTMLDOMNode_AddRef(&This->element.node.IHTMLDOMNode_iface);
+}
+
+static ULONG WINAPI HTMLCommentElement_TextNode2_Release(IHTMLDOMTextNode2 *iface)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode2(iface);
+
+    return IHTMLDOMNode_Release(&This->element.node.IHTMLDOMNode_iface);
+}
+
+static HRESULT WINAPI HTMLCommentElement_TextNode2_GetTypeInfoCount(IHTMLDOMTextNode2 *iface, UINT *pctinfo)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode2(iface);
+    return IDispatchEx_GetTypeInfoCount(&This->element.node.event_target.dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI HTMLCommentElement_TextNode2_GetTypeInfo(IHTMLDOMTextNode2 *iface, UINT iTInfo,
+        LCID lcid, ITypeInfo **ppTInfo)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode2(iface);
+    return IDispatchEx_GetTypeInfo(&This->element.node.event_target.dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
+}
+
+static HRESULT WINAPI HTMLCommentElement_TextNode2_GetIDsOfNames(IHTMLDOMTextNode2 *iface, REFIID riid,
+        LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode2(iface);
+    return IDispatchEx_GetIDsOfNames(&This->element.node.event_target.dispex.IDispatchEx_iface, riid, rgszNames, cNames,
+            lcid, rgDispId);
+}
+
+static HRESULT WINAPI HTMLCommentElement_TextNode2_Invoke(IHTMLDOMTextNode2 *iface, DISPID dispIdMember,
+        REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult,
+        EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode2(iface);
+    return IDispatchEx_Invoke(&This->element.node.event_target.dispex.IDispatchEx_iface, dispIdMember, riid, lcid,
+            wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI HTMLCommentElement_TextNode2_substringData(IHTMLDOMTextNode2 *iface, LONG offset, LONG count, BSTR *string)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode2(iface);
+    FIXME("(%p)->(%ld %ld %p)\n", This, offset, count, string);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCommentElement_TextNode2_appendData(IHTMLDOMTextNode2 *iface, BSTR string)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode2(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_w(string));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCommentElement_TextNode2_insertData(IHTMLDOMTextNode2 *iface, LONG offset, BSTR string)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode2(iface);
+    FIXME("(%p)->(%ld %s)\n", This, offset, debugstr_w(string));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCommentElement_TextNode2_deleteData(IHTMLDOMTextNode2 *iface, LONG offset, LONG count)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode2(iface);
+    FIXME("(%p)->(%ld %ld)\n", This, offset, count);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCommentElement_TextNode2_replaceData(IHTMLDOMTextNode2 *iface, LONG offset, LONG count, BSTR string)
+{
+    HTMLCommentElement *This = impl_from_IHTMLDOMTextNode2(iface);
+    FIXME("(%p)->(%ld %ld %s)\n", This, offset, count, debugstr_w(string));
+    return E_NOTIMPL;
+}
+
+static const IHTMLDOMTextNode2Vtbl HTMLCommentElement_TextNode2Vtbl = {
+    HTMLCommentElement_TextNode2_QueryInterface,
+    HTMLCommentElement_TextNode2_AddRef,
+    HTMLCommentElement_TextNode2_Release,
+    HTMLCommentElement_TextNode2_GetTypeInfoCount,
+    HTMLCommentElement_TextNode2_GetTypeInfo,
+    HTMLCommentElement_TextNode2_GetIDsOfNames,
+    HTMLCommentElement_TextNode2_Invoke,
+    HTMLCommentElement_TextNode2_substringData,
+    HTMLCommentElement_TextNode2_appendData,
+    HTMLCommentElement_TextNode2_insertData,
+    HTMLCommentElement_TextNode2_deleteData,
+    HTMLCommentElement_TextNode2_replaceData
+};
+
 static inline HTMLCommentElement *impl_from_HTMLDOMNode(HTMLDOMNode *iface)
 {
     return CONTAINING_RECORD(iface, HTMLCommentElement, element.node);
@@ -154,6 +370,10 @@ static HRESULT HTMLCommentElement_QI(HTMLDOMNode *iface, REFIID riid, void **ppv
     if(IsEqualGUID(&IID_IHTMLCommentElement, riid)) {
         TRACE("(%p)->(IID_IHTMLCommentElement %p)\n", This, ppv);
         *ppv = &This->IHTMLCommentElement_iface;
+    }else if(IsEqualGUID(&IID_IHTMLDOMTextNode, riid)) {
+        *ppv = &This->IHTMLDOMTextNode_iface;
+    }else if(IsEqualGUID(&IID_IHTMLDOMTextNode2, riid)) {
+        *ppv = &This->IHTMLDOMTextNode2_iface;
     }else {
         return HTMLElement_QI(&This->element.node, riid, ppv);
     }
@@ -198,9 +418,10 @@ static const tid_t HTMLCommentElement_iface_tids[] = {
     IHTMLCommentElement_tid,
     0
 };
-static dispex_static_data_t HTMLCommentElement_dispex = {
+dispex_static_data_t HTMLCommentElement_dispex = {
     L"Comment",
     NULL,
+    PROTO_ID_HTMLCommentElement,
     DispHTMLCommentElement_tid,
     HTMLCommentElement_iface_tids,
     HTMLElement_init_dispex_info
@@ -216,6 +437,8 @@ HRESULT HTMLCommentElement_Create(HTMLDocumentNode *doc, nsIDOMNode *nsnode, HTM
 
     ret->element.node.vtbl = &HTMLCommentElementImplVtbl;
     ret->IHTMLCommentElement_iface.lpVtbl = &HTMLCommentElementVtbl;
+    ret->IHTMLDOMTextNode_iface.lpVtbl = &HTMLCommentElement_TextNodeVtbl;
+    ret->IHTMLDOMTextNode2_iface.lpVtbl = &HTMLCommentElement_TextNode2Vtbl;
 
     HTMLElement_Init(&ret->element, doc, NULL, &HTMLCommentElement_dispex);
     HTMLDOMNode_Init(doc, &ret->element.node, nsnode, &HTMLCommentElement_dispex);
diff --git a/dlls/mshtml/htmlcurstyle.c b/dlls/mshtml/htmlcurstyle.c
index 852b9059917..acb76b3d312 100644
--- a/dlls/mshtml/htmlcurstyle.c
+++ b/dlls/mshtml/htmlcurstyle.c
@@ -38,6 +38,11 @@ struct HTMLCurrentStyle {
     IHTMLCurrentStyle2 IHTMLCurrentStyle2_iface;
     IHTMLCurrentStyle3 IHTMLCurrentStyle3_iface;
     IHTMLCurrentStyle4 IHTMLCurrentStyle4_iface;
+    IHTMLStyle         IHTMLStyle_iface;
+    IHTMLStyle2        IHTMLStyle2_iface;
+    IHTMLStyle3        IHTMLStyle3_iface;
+    IHTMLStyle5        IHTMLStyle5_iface;
+    IHTMLStyle6        IHTMLStyle6_iface;
 
     HTMLElement *elem;
 };
@@ -72,6 +77,31 @@ static inline HTMLCurrentStyle *impl_from_IHTMLCurrentStyle4(IHTMLCurrentStyle4
     return CONTAINING_RECORD(iface, HTMLCurrentStyle, IHTMLCurrentStyle4_iface);
 }
 
+static inline HTMLCurrentStyle *impl_from_IHTMLStyle(IHTMLStyle *iface)
+{
+    return CONTAINING_RECORD(iface, HTMLCurrentStyle, IHTMLStyle_iface);
+}
+
+static inline HTMLCurrentStyle *impl_from_IHTMLStyle2(IHTMLStyle2 *iface)
+{
+    return CONTAINING_RECORD(iface, HTMLCurrentStyle, IHTMLStyle2_iface);
+}
+
+static inline HTMLCurrentStyle *impl_from_IHTMLStyle3(IHTMLStyle3 *iface)
+{
+    return CONTAINING_RECORD(iface, HTMLCurrentStyle, IHTMLStyle3_iface);
+}
+
+static inline HTMLCurrentStyle *impl_from_IHTMLStyle5(IHTMLStyle5 *iface)
+{
+    return CONTAINING_RECORD(iface, HTMLCurrentStyle, IHTMLStyle5_iface);
+}
+
+static inline HTMLCurrentStyle *impl_from_IHTMLStyle6(IHTMLStyle6 *iface)
+{
+    return CONTAINING_RECORD(iface, HTMLCurrentStyle, IHTMLStyle6_iface);
+}
+
 static void *HTMLCurrentStyle_QI(CSSStyle *css_style, REFIID riid)
 {
     HTMLCurrentStyle *This = CONTAINING_RECORD(css_style, HTMLCurrentStyle, css_style);
@@ -83,6 +113,16 @@ static void *HTMLCurrentStyle_QI(CSSStyle *css_style, REFIID riid)
         return &This->IHTMLCurrentStyle3_iface;
     if(IsEqualGUID(&IID_IHTMLCurrentStyle4, riid))
         return &This->IHTMLCurrentStyle4_iface;
+    if(IsEqualGUID(&IID_IHTMLStyle, riid))
+        return &This->IHTMLStyle_iface;
+    if(IsEqualGUID(&IID_IHTMLStyle2, riid))
+        return &This->IHTMLStyle2_iface;
+    if(IsEqualGUID(&IID_IHTMLStyle3, riid))
+        return &This->IHTMLStyle3_iface;
+    if(IsEqualGUID(&IID_IHTMLStyle5, riid))
+        return &This->IHTMLStyle5_iface;
+    if(IsEqualGUID(&IID_IHTMLStyle6, riid))
+        return &This->IHTMLStyle6_iface;
     return NULL;
 }
 
@@ -1292,6 +1332,2800 @@ static const IHTMLCurrentStyle4Vtbl HTMLCurrentStyle4Vtbl = {
     HTMLCurrentStyle4_get_maxWidth
 };
 
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_QueryInterface(IHTMLStyle *iface, REFIID riid, void **ppv)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    return IHTMLCurrentStyle_QueryInterface(&This->IHTMLCurrentStyle_iface, riid, ppv);
+}
+
+static ULONG WINAPI HTMLCurrentStyle_HTMLStyle_AddRef(IHTMLStyle *iface)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    return IHTMLCurrentStyle_AddRef(&This->IHTMLCurrentStyle_iface);
+}
+
+static ULONG WINAPI HTMLCurrentStyle_HTMLStyle_Release(IHTMLStyle *iface)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    return IHTMLCurrentStyle_Release(&This->IHTMLCurrentStyle_iface);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_GetTypeInfoCount(IHTMLStyle *iface, UINT *pctinfo)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    return IDispatchEx_GetTypeInfoCount(&This->css_style.dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_GetTypeInfo(IHTMLStyle *iface, UINT iTInfo,
+                                              LCID lcid, ITypeInfo **ppTInfo)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    return IDispatchEx_GetTypeInfo(&This->css_style.dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_GetIDsOfNames(IHTMLStyle *iface, REFIID riid,
+                                                LPOLESTR *rgszNames, UINT cNames,
+                                                LCID lcid, DISPID *rgDispId)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    return IDispatchEx_GetIDsOfNames(&This->css_style.dispex.IDispatchEx_iface, riid, rgszNames, cNames,
+            lcid, rgDispId);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_Invoke(IHTMLStyle *iface, DISPID dispIdMember,
+                            REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+                            VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    return IDispatchEx_Invoke(&This->css_style.dispex.IDispatchEx_iface, dispIdMember, riid, lcid,
+            wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_fontFamily(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_fontFamily(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_fontStyle(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_fontStyle(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_fontVariant(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_fontVariant(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_fontWeight(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_fontWeight(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_fontSize(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_fontSize(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_font(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_font(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_color(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_color(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_background(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_background(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_backgroundColor(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_backgroundColor(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_backgroundImage(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_backgroundImage(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_backgroundRepeat(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_backgroundRepeat(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_backgroundAttachment(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_backgroundAttachment(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_backgroundPosition(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_backgroundPosition(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_backgroundPositionX(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_backgroundPositionX(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    TRACE("(%p)->(%p)\n", This, p);
+    return IHTMLCSSStyleDeclaration_get_backgroundPositionX(&This->css_style.IHTMLCSSStyleDeclaration_iface, p);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_backgroundPositionY(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_backgroundPositionY(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    TRACE("(%p)->(%p)\n", This, p);
+    return IHTMLCSSStyleDeclaration_get_backgroundPositionY(&This->css_style.IHTMLCSSStyleDeclaration_iface, p);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_wordSpacing(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_wordSpacing(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_letterSpacing(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_letterSpacing(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_textDecoration(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_textDecoration(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_textDecorationNone(IHTMLStyle *iface, VARIANT_BOOL v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%x)\n", This, v);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_textDecorationNone(IHTMLStyle *iface, VARIANT_BOOL *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_textDecorationUnderline(IHTMLStyle *iface, VARIANT_BOOL v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%x)\n", This, v);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_textDecorationUnderline(IHTMLStyle *iface, VARIANT_BOOL *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_textDecorationOverline(IHTMLStyle *iface, VARIANT_BOOL v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%x)\n", This, v);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_textDecorationOverline(IHTMLStyle *iface, VARIANT_BOOL *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_textDecorationLineThrough(IHTMLStyle *iface, VARIANT_BOOL v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%x)\n", This, v);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_textDecorationLineThrough(IHTMLStyle *iface, VARIANT_BOOL *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_textDecorationBlink(IHTMLStyle *iface, VARIANT_BOOL v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%x)\n", This, v);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_textDecorationBlink(IHTMLStyle *iface, VARIANT_BOOL *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_verticalAlign(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_verticalAlign(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_textTransform(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_textTransform(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_textAlign(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_textAlign(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_textIndent(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_textIndent(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_lineHeight(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_lineHeight(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_marginTop(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_marginTop(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_marginRight(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_marginRight(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_marginBottom(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_marginBottom(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_marginLeft(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_margin(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_margin(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_marginLeft(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_paddingTop(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_paddingTop(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_paddingRight(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_paddingRight(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_paddingBottom(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_paddingBottom(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_paddingLeft(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_paddingLeft(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_padding(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_padding(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_border(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_border(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_borderTop(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_borderTop(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_borderRight(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_borderRight(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_borderBottom(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_borderBottom(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_borderLeft(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_borderLeft(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_borderColor(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_borderColor(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_borderTopColor(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_borderTopColor(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_borderRightColor(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_borderRightColor(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_borderBottomColor(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_borderBottomColor(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_borderLeftColor(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_borderLeftColor(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_borderWidth(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_borderWidth(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_borderTopWidth(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_borderTopWidth(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_borderRightWidth(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_borderRightWidth(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_borderBottomWidth(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_borderBottomWidth(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_borderLeftWidth(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_borderLeftWidth(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_borderStyle(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_borderStyle(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_borderTopStyle(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_borderTopStyle(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_borderRightStyle(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_borderRightStyle(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_borderBottomStyle(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_borderBottomStyle(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_borderLeftStyle(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_borderLeftStyle(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_width(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_width(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_height(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_height(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_styleFloat(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_styleFloat(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    TRACE("(%p)->(%p)\n", This, p);
+    return get_current_style_property(This, STYLEID_FLOAT, p);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_clear(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_clear(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_display(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_display(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_visibility(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_visibility(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_listStyleType(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_listStyleType(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_listStylePosition(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_listStylePosition(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_listStyleImage(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_listStyleImage(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_listStyle(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_listStyle(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_whiteSpace(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_whiteSpace(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_top(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_top(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_left(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_left(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_position(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_zIndex(IHTMLStyle *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_zIndex(IHTMLStyle *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_overflow(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_overflow(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_pageBreakBefore(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_pageBreakBefore(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_pageBreakAfter(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_pageBreakAfter(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_cssText(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_cssText(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_pixelTop(IHTMLStyle *iface, LONG v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%ld)\n", This, v);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_pixelTop(IHTMLStyle *iface, LONG *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_pixelLeft(IHTMLStyle *iface, LONG v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%ld)\n", This, v);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_pixelLeft(IHTMLStyle *iface, LONG *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_pixelWidth(IHTMLStyle *iface, LONG v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->()\n", This);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_pixelWidth(IHTMLStyle *iface, LONG *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_pixelHeight(IHTMLStyle *iface, LONG v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%ld)\n", This, v);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_pixelHeight(IHTMLStyle *iface, LONG *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_posTop(IHTMLStyle *iface, float v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%f)\n", This, v);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_posTop(IHTMLStyle *iface, float *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_posLeft(IHTMLStyle *iface, float v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%f)\n", This, v);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_posLeft(IHTMLStyle *iface, float *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_posWidth(IHTMLStyle *iface, float v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%f)\n", This, v);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_posWidth(IHTMLStyle *iface, float *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_posHeight(IHTMLStyle *iface, float v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%f)\n", This, v);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_posHeight(IHTMLStyle *iface, float *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_cursor(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_cursor(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_clip(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_clip(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_put_filter(IHTMLStyle *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_get_filter(IHTMLStyle *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_setAttribute(IHTMLStyle *iface, BSTR strAttributeName,
+        VARIANT AttributeValue, LONG lFlags)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    FIXME("(%p)->(%s %s %08lx)\n", This, debugstr_w(strAttributeName),
+          debugstr_variant(&AttributeValue), lFlags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_getAttribute(IHTMLStyle *iface, BSTR strAttributeName,
+        LONG lFlags, VARIANT *AttributeValue)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    FIXME("(%p)->(%s v%p %08lx)\n", This, debugstr_w(strAttributeName), AttributeValue, lFlags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_removeAttribute(IHTMLStyle *iface, BSTR strAttributeName,
+                                                LONG lFlags, VARIANT_BOOL *pfSuccess)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    FIXME("(%p)->(%s %08lx %p)\n", This, debugstr_w(strAttributeName), lFlags, pfSuccess);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle_toString(IHTMLStyle *iface, BSTR *String)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle(iface);
+    WARN("(%p)->(%p)\n", This, String);
+    return E_UNEXPECTED;
+}
+
+static const IHTMLStyleVtbl HTMLStyleVtbl = {
+    HTMLCurrentStyle_HTMLStyle_QueryInterface,
+    HTMLCurrentStyle_HTMLStyle_AddRef,
+    HTMLCurrentStyle_HTMLStyle_Release,
+    HTMLCurrentStyle_HTMLStyle_GetTypeInfoCount,
+    HTMLCurrentStyle_HTMLStyle_GetTypeInfo,
+    HTMLCurrentStyle_HTMLStyle_GetIDsOfNames,
+    HTMLCurrentStyle_HTMLStyle_Invoke,
+    HTMLCurrentStyle_HTMLStyle_put_fontFamily,
+    HTMLCurrentStyle_HTMLStyle_get_fontFamily,
+    HTMLCurrentStyle_HTMLStyle_put_fontStyle,
+    HTMLCurrentStyle_HTMLStyle_get_fontStyle,
+    HTMLCurrentStyle_HTMLStyle_put_fontVariant,
+    HTMLCurrentStyle_HTMLStyle_get_fontVariant,
+    HTMLCurrentStyle_HTMLStyle_put_fontWeight,
+    HTMLCurrentStyle_HTMLStyle_get_fontWeight,
+    HTMLCurrentStyle_HTMLStyle_put_fontSize,
+    HTMLCurrentStyle_HTMLStyle_get_fontSize,
+    HTMLCurrentStyle_HTMLStyle_put_font,
+    HTMLCurrentStyle_HTMLStyle_get_font,
+    HTMLCurrentStyle_HTMLStyle_put_color,
+    HTMLCurrentStyle_HTMLStyle_get_color,
+    HTMLCurrentStyle_HTMLStyle_put_background,
+    HTMLCurrentStyle_HTMLStyle_get_background,
+    HTMLCurrentStyle_HTMLStyle_put_backgroundColor,
+    HTMLCurrentStyle_HTMLStyle_get_backgroundColor,
+    HTMLCurrentStyle_HTMLStyle_put_backgroundImage,
+    HTMLCurrentStyle_HTMLStyle_get_backgroundImage,
+    HTMLCurrentStyle_HTMLStyle_put_backgroundRepeat,
+    HTMLCurrentStyle_HTMLStyle_get_backgroundRepeat,
+    HTMLCurrentStyle_HTMLStyle_put_backgroundAttachment,
+    HTMLCurrentStyle_HTMLStyle_get_backgroundAttachment,
+    HTMLCurrentStyle_HTMLStyle_put_backgroundPosition,
+    HTMLCurrentStyle_HTMLStyle_get_backgroundPosition,
+    HTMLCurrentStyle_HTMLStyle_put_backgroundPositionX,
+    HTMLCurrentStyle_HTMLStyle_get_backgroundPositionX,
+    HTMLCurrentStyle_HTMLStyle_put_backgroundPositionY,
+    HTMLCurrentStyle_HTMLStyle_get_backgroundPositionY,
+    HTMLCurrentStyle_HTMLStyle_put_wordSpacing,
+    HTMLCurrentStyle_HTMLStyle_get_wordSpacing,
+    HTMLCurrentStyle_HTMLStyle_put_letterSpacing,
+    HTMLCurrentStyle_HTMLStyle_get_letterSpacing,
+    HTMLCurrentStyle_HTMLStyle_put_textDecoration,
+    HTMLCurrentStyle_HTMLStyle_get_textDecoration,
+    HTMLCurrentStyle_HTMLStyle_put_textDecorationNone,
+    HTMLCurrentStyle_HTMLStyle_get_textDecorationNone,
+    HTMLCurrentStyle_HTMLStyle_put_textDecorationUnderline,
+    HTMLCurrentStyle_HTMLStyle_get_textDecorationUnderline,
+    HTMLCurrentStyle_HTMLStyle_put_textDecorationOverline,
+    HTMLCurrentStyle_HTMLStyle_get_textDecorationOverline,
+    HTMLCurrentStyle_HTMLStyle_put_textDecorationLineThrough,
+    HTMLCurrentStyle_HTMLStyle_get_textDecorationLineThrough,
+    HTMLCurrentStyle_HTMLStyle_put_textDecorationBlink,
+    HTMLCurrentStyle_HTMLStyle_get_textDecorationBlink,
+    HTMLCurrentStyle_HTMLStyle_put_verticalAlign,
+    HTMLCurrentStyle_HTMLStyle_get_verticalAlign,
+    HTMLCurrentStyle_HTMLStyle_put_textTransform,
+    HTMLCurrentStyle_HTMLStyle_get_textTransform,
+    HTMLCurrentStyle_HTMLStyle_put_textAlign,
+    HTMLCurrentStyle_HTMLStyle_get_textAlign,
+    HTMLCurrentStyle_HTMLStyle_put_textIndent,
+    HTMLCurrentStyle_HTMLStyle_get_textIndent,
+    HTMLCurrentStyle_HTMLStyle_put_lineHeight,
+    HTMLCurrentStyle_HTMLStyle_get_lineHeight,
+    HTMLCurrentStyle_HTMLStyle_put_marginTop,
+    HTMLCurrentStyle_HTMLStyle_get_marginTop,
+    HTMLCurrentStyle_HTMLStyle_put_marginRight,
+    HTMLCurrentStyle_HTMLStyle_get_marginRight,
+    HTMLCurrentStyle_HTMLStyle_put_marginBottom,
+    HTMLCurrentStyle_HTMLStyle_get_marginBottom,
+    HTMLCurrentStyle_HTMLStyle_put_marginLeft,
+    HTMLCurrentStyle_HTMLStyle_get_marginLeft,
+    HTMLCurrentStyle_HTMLStyle_put_margin,
+    HTMLCurrentStyle_HTMLStyle_get_margin,
+    HTMLCurrentStyle_HTMLStyle_put_paddingTop,
+    HTMLCurrentStyle_HTMLStyle_get_paddingTop,
+    HTMLCurrentStyle_HTMLStyle_put_paddingRight,
+    HTMLCurrentStyle_HTMLStyle_get_paddingRight,
+    HTMLCurrentStyle_HTMLStyle_put_paddingBottom,
+    HTMLCurrentStyle_HTMLStyle_get_paddingBottom,
+    HTMLCurrentStyle_HTMLStyle_put_paddingLeft,
+    HTMLCurrentStyle_HTMLStyle_get_paddingLeft,
+    HTMLCurrentStyle_HTMLStyle_put_padding,
+    HTMLCurrentStyle_HTMLStyle_get_padding,
+    HTMLCurrentStyle_HTMLStyle_put_border,
+    HTMLCurrentStyle_HTMLStyle_get_border,
+    HTMLCurrentStyle_HTMLStyle_put_borderTop,
+    HTMLCurrentStyle_HTMLStyle_get_borderTop,
+    HTMLCurrentStyle_HTMLStyle_put_borderRight,
+    HTMLCurrentStyle_HTMLStyle_get_borderRight,
+    HTMLCurrentStyle_HTMLStyle_put_borderBottom,
+    HTMLCurrentStyle_HTMLStyle_get_borderBottom,
+    HTMLCurrentStyle_HTMLStyle_put_borderLeft,
+    HTMLCurrentStyle_HTMLStyle_get_borderLeft,
+    HTMLCurrentStyle_HTMLStyle_put_borderColor,
+    HTMLCurrentStyle_HTMLStyle_get_borderColor,
+    HTMLCurrentStyle_HTMLStyle_put_borderTopColor,
+    HTMLCurrentStyle_HTMLStyle_get_borderTopColor,
+    HTMLCurrentStyle_HTMLStyle_put_borderRightColor,
+    HTMLCurrentStyle_HTMLStyle_get_borderRightColor,
+    HTMLCurrentStyle_HTMLStyle_put_borderBottomColor,
+    HTMLCurrentStyle_HTMLStyle_get_borderBottomColor,
+    HTMLCurrentStyle_HTMLStyle_put_borderLeftColor,
+    HTMLCurrentStyle_HTMLStyle_get_borderLeftColor,
+    HTMLCurrentStyle_HTMLStyle_put_borderWidth,
+    HTMLCurrentStyle_HTMLStyle_get_borderWidth,
+    HTMLCurrentStyle_HTMLStyle_put_borderTopWidth,
+    HTMLCurrentStyle_HTMLStyle_get_borderTopWidth,
+    HTMLCurrentStyle_HTMLStyle_put_borderRightWidth,
+    HTMLCurrentStyle_HTMLStyle_get_borderRightWidth,
+    HTMLCurrentStyle_HTMLStyle_put_borderBottomWidth,
+    HTMLCurrentStyle_HTMLStyle_get_borderBottomWidth,
+    HTMLCurrentStyle_HTMLStyle_put_borderLeftWidth,
+    HTMLCurrentStyle_HTMLStyle_get_borderLeftWidth,
+    HTMLCurrentStyle_HTMLStyle_put_borderStyle,
+    HTMLCurrentStyle_HTMLStyle_get_borderStyle,
+    HTMLCurrentStyle_HTMLStyle_put_borderTopStyle,
+    HTMLCurrentStyle_HTMLStyle_get_borderTopStyle,
+    HTMLCurrentStyle_HTMLStyle_put_borderRightStyle,
+    HTMLCurrentStyle_HTMLStyle_get_borderRightStyle,
+    HTMLCurrentStyle_HTMLStyle_put_borderBottomStyle,
+    HTMLCurrentStyle_HTMLStyle_get_borderBottomStyle,
+    HTMLCurrentStyle_HTMLStyle_put_borderLeftStyle,
+    HTMLCurrentStyle_HTMLStyle_get_borderLeftStyle,
+    HTMLCurrentStyle_HTMLStyle_put_width,
+    HTMLCurrentStyle_HTMLStyle_get_width,
+    HTMLCurrentStyle_HTMLStyle_put_height,
+    HTMLCurrentStyle_HTMLStyle_get_height,
+    HTMLCurrentStyle_HTMLStyle_put_styleFloat,
+    HTMLCurrentStyle_HTMLStyle_get_styleFloat,
+    HTMLCurrentStyle_HTMLStyle_put_clear,
+    HTMLCurrentStyle_HTMLStyle_get_clear,
+    HTMLCurrentStyle_HTMLStyle_put_display,
+    HTMLCurrentStyle_HTMLStyle_get_display,
+    HTMLCurrentStyle_HTMLStyle_put_visibility,
+    HTMLCurrentStyle_HTMLStyle_get_visibility,
+    HTMLCurrentStyle_HTMLStyle_put_listStyleType,
+    HTMLCurrentStyle_HTMLStyle_get_listStyleType,
+    HTMLCurrentStyle_HTMLStyle_put_listStylePosition,
+    HTMLCurrentStyle_HTMLStyle_get_listStylePosition,
+    HTMLCurrentStyle_HTMLStyle_put_listStyleImage,
+    HTMLCurrentStyle_HTMLStyle_get_listStyleImage,
+    HTMLCurrentStyle_HTMLStyle_put_listStyle,
+    HTMLCurrentStyle_HTMLStyle_get_listStyle,
+    HTMLCurrentStyle_HTMLStyle_put_whiteSpace,
+    HTMLCurrentStyle_HTMLStyle_get_whiteSpace,
+    HTMLCurrentStyle_HTMLStyle_put_top,
+    HTMLCurrentStyle_HTMLStyle_get_top,
+    HTMLCurrentStyle_HTMLStyle_put_left,
+    HTMLCurrentStyle_HTMLStyle_get_left,
+    HTMLCurrentStyle_HTMLStyle_get_position,
+    HTMLCurrentStyle_HTMLStyle_put_zIndex,
+    HTMLCurrentStyle_HTMLStyle_get_zIndex,
+    HTMLCurrentStyle_HTMLStyle_put_overflow,
+    HTMLCurrentStyle_HTMLStyle_get_overflow,
+    HTMLCurrentStyle_HTMLStyle_put_pageBreakBefore,
+    HTMLCurrentStyle_HTMLStyle_get_pageBreakBefore,
+    HTMLCurrentStyle_HTMLStyle_put_pageBreakAfter,
+    HTMLCurrentStyle_HTMLStyle_get_pageBreakAfter,
+    HTMLCurrentStyle_HTMLStyle_put_cssText,
+    HTMLCurrentStyle_HTMLStyle_get_cssText,
+    HTMLCurrentStyle_HTMLStyle_put_pixelTop,
+    HTMLCurrentStyle_HTMLStyle_get_pixelTop,
+    HTMLCurrentStyle_HTMLStyle_put_pixelLeft,
+    HTMLCurrentStyle_HTMLStyle_get_pixelLeft,
+    HTMLCurrentStyle_HTMLStyle_put_pixelWidth,
+    HTMLCurrentStyle_HTMLStyle_get_pixelWidth,
+    HTMLCurrentStyle_HTMLStyle_put_pixelHeight,
+    HTMLCurrentStyle_HTMLStyle_get_pixelHeight,
+    HTMLCurrentStyle_HTMLStyle_put_posTop,
+    HTMLCurrentStyle_HTMLStyle_get_posTop,
+    HTMLCurrentStyle_HTMLStyle_put_posLeft,
+    HTMLCurrentStyle_HTMLStyle_get_posLeft,
+    HTMLCurrentStyle_HTMLStyle_put_posWidth,
+    HTMLCurrentStyle_HTMLStyle_get_posWidth,
+    HTMLCurrentStyle_HTMLStyle_put_posHeight,
+    HTMLCurrentStyle_HTMLStyle_get_posHeight,
+    HTMLCurrentStyle_HTMLStyle_put_cursor,
+    HTMLCurrentStyle_HTMLStyle_get_cursor,
+    HTMLCurrentStyle_HTMLStyle_put_clip,
+    HTMLCurrentStyle_HTMLStyle_get_clip,
+    HTMLCurrentStyle_HTMLStyle_put_filter,
+    HTMLCurrentStyle_HTMLStyle_get_filter,
+    HTMLCurrentStyle_HTMLStyle_setAttribute,
+    HTMLCurrentStyle_HTMLStyle_getAttribute,
+    HTMLCurrentStyle_HTMLStyle_removeAttribute,
+    HTMLCurrentStyle_HTMLStyle_toString
+};
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_QueryInterface(IHTMLStyle2 *iface, REFIID riid, void **ppv)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    return IHTMLCurrentStyle_QueryInterface(&This->IHTMLCurrentStyle_iface, riid, ppv);
+}
+
+static ULONG WINAPI HTMLCurrentStyle_HTMLStyle2_AddRef(IHTMLStyle2 *iface)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    return IHTMLCurrentStyle_AddRef(&This->IHTMLCurrentStyle_iface);
+}
+
+static ULONG WINAPI HTMLCurrentStyle_HTMLStyle2_Release(IHTMLStyle2 *iface)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    return IHTMLCurrentStyle_Release(&This->IHTMLCurrentStyle_iface);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_GetTypeInfoCount(IHTMLStyle2 *iface, UINT *pctinfo)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    return IDispatchEx_GetTypeInfoCount(&This->css_style.dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_GetTypeInfo(IHTMLStyle2 *iface, UINT iTInfo,
+                                              LCID lcid, ITypeInfo **ppTInfo)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    return IDispatchEx_GetTypeInfo(&This->css_style.dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_GetIDsOfNames(IHTMLStyle2 *iface, REFIID riid,
+                                                LPOLESTR *rgszNames, UINT cNames,
+                                                LCID lcid, DISPID *rgDispId)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    return IDispatchEx_GetIDsOfNames(&This->css_style.dispex.IDispatchEx_iface, riid, rgszNames, cNames,
+            lcid, rgDispId);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_Invoke(IHTMLStyle2 *iface, DISPID dispIdMember,
+                            REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+                            VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    return IDispatchEx_Invoke(&This->css_style.dispex.IDispatchEx_iface, dispIdMember, riid, lcid,
+            wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_tableLayout(IHTMLStyle2 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_tableLayout(IHTMLStyle2 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_borderCollapse(IHTMLStyle2 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_borderCollapse(IHTMLStyle2 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_direction(IHTMLStyle2 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_direction(IHTMLStyle2 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_behavior(IHTMLStyle2 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_behavior(IHTMLStyle2 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_setExpression(IHTMLStyle2 *iface, BSTR propname, BSTR expression, BSTR language)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%s %s %s)\n", This, debugstr_w(propname), debugstr_w(expression), debugstr_w(language));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_getExpression(IHTMLStyle2 *iface, BSTR propname, VARIANT *expression)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%s %p)\n", This, debugstr_w(propname), expression);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_removeExpression(IHTMLStyle2 *iface, BSTR propname, VARIANT_BOOL *pfSuccess)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%s %p)\n", This, debugstr_w(propname), pfSuccess);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_position(IHTMLStyle2 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_position(IHTMLStyle2 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_unicodeBidi(IHTMLStyle2 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_unicodeBidi(IHTMLStyle2 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_bottom(IHTMLStyle2 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_bottom(IHTMLStyle2 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_right(IHTMLStyle2 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_right(IHTMLStyle2 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_pixelBottom(IHTMLStyle2 *iface, LONG v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%ld)\n", This, v);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_pixelBottom(IHTMLStyle2 *iface, LONG *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_pixelRight(IHTMLStyle2 *iface, LONG v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%ld)\n", This, v);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_pixelRight(IHTMLStyle2 *iface, LONG *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_posBottom(IHTMLStyle2 *iface, float v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%f)\n", This, v);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_posBottom(IHTMLStyle2 *iface, float *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_posRight(IHTMLStyle2 *iface, float v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%f)\n", This, v);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_posRight(IHTMLStyle2 *iface, float *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_imeMode(IHTMLStyle2 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_imeMode(IHTMLStyle2 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_rubyAlign(IHTMLStyle2 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_rubyAlign(IHTMLStyle2 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_rubyPosition(IHTMLStyle2 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_rubyPosition(IHTMLStyle2 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_rubyOverhang(IHTMLStyle2 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_rubyOverhang(IHTMLStyle2 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_layoutGridChar(IHTMLStyle2 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_layoutGridChar(IHTMLStyle2 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_layoutGridLine(IHTMLStyle2 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_layoutGridLine(IHTMLStyle2 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_layoutGridMode(IHTMLStyle2 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_layoutGridMode(IHTMLStyle2 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_layoutGridType(IHTMLStyle2 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_layoutGridType(IHTMLStyle2 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_layoutGrid(IHTMLStyle2 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_layoutGrid(IHTMLStyle2 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_wordBreak(IHTMLStyle2 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_wordBreak(IHTMLStyle2 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_lineBreak(IHTMLStyle2 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_lineBreak(IHTMLStyle2 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_textJustify(IHTMLStyle2 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_textJustify(IHTMLStyle2 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_textJustifyTrim(IHTMLStyle2 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_textJustifyTrim(IHTMLStyle2 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_textKashida(IHTMLStyle2 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_textKashida(IHTMLStyle2 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_textAutospace(IHTMLStyle2 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_textAutospace(IHTMLStyle2 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_overflowX(IHTMLStyle2 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_overflowX(IHTMLStyle2 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_overflowY(IHTMLStyle2 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_overflowY(IHTMLStyle2 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_put_accelerator(IHTMLStyle2 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle2_get_accelerator(IHTMLStyle2 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle2(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static const IHTMLStyle2Vtbl HTMLStyle2Vtbl = {
+    HTMLCurrentStyle_HTMLStyle2_QueryInterface,
+    HTMLCurrentStyle_HTMLStyle2_AddRef,
+    HTMLCurrentStyle_HTMLStyle2_Release,
+    HTMLCurrentStyle_HTMLStyle2_GetTypeInfoCount,
+    HTMLCurrentStyle_HTMLStyle2_GetTypeInfo,
+    HTMLCurrentStyle_HTMLStyle2_GetIDsOfNames,
+    HTMLCurrentStyle_HTMLStyle2_Invoke,
+    HTMLCurrentStyle_HTMLStyle2_put_tableLayout,
+    HTMLCurrentStyle_HTMLStyle2_get_tableLayout,
+    HTMLCurrentStyle_HTMLStyle2_put_borderCollapse,
+    HTMLCurrentStyle_HTMLStyle2_get_borderCollapse,
+    HTMLCurrentStyle_HTMLStyle2_put_direction,
+    HTMLCurrentStyle_HTMLStyle2_get_direction,
+    HTMLCurrentStyle_HTMLStyle2_put_behavior,
+    HTMLCurrentStyle_HTMLStyle2_get_behavior,
+    HTMLCurrentStyle_HTMLStyle2_setExpression,
+    HTMLCurrentStyle_HTMLStyle2_getExpression,
+    HTMLCurrentStyle_HTMLStyle2_removeExpression,
+    HTMLCurrentStyle_HTMLStyle2_put_position,
+    HTMLCurrentStyle_HTMLStyle2_get_position,
+    HTMLCurrentStyle_HTMLStyle2_put_unicodeBidi,
+    HTMLCurrentStyle_HTMLStyle2_get_unicodeBidi,
+    HTMLCurrentStyle_HTMLStyle2_put_bottom,
+    HTMLCurrentStyle_HTMLStyle2_get_bottom,
+    HTMLCurrentStyle_HTMLStyle2_put_right,
+    HTMLCurrentStyle_HTMLStyle2_get_right,
+    HTMLCurrentStyle_HTMLStyle2_put_pixelBottom,
+    HTMLCurrentStyle_HTMLStyle2_get_pixelBottom,
+    HTMLCurrentStyle_HTMLStyle2_put_pixelRight,
+    HTMLCurrentStyle_HTMLStyle2_get_pixelRight,
+    HTMLCurrentStyle_HTMLStyle2_put_posBottom,
+    HTMLCurrentStyle_HTMLStyle2_get_posBottom,
+    HTMLCurrentStyle_HTMLStyle2_put_posRight,
+    HTMLCurrentStyle_HTMLStyle2_get_posRight,
+    HTMLCurrentStyle_HTMLStyle2_put_imeMode,
+    HTMLCurrentStyle_HTMLStyle2_get_imeMode,
+    HTMLCurrentStyle_HTMLStyle2_put_rubyAlign,
+    HTMLCurrentStyle_HTMLStyle2_get_rubyAlign,
+    HTMLCurrentStyle_HTMLStyle2_put_rubyPosition,
+    HTMLCurrentStyle_HTMLStyle2_get_rubyPosition,
+    HTMLCurrentStyle_HTMLStyle2_put_rubyOverhang,
+    HTMLCurrentStyle_HTMLStyle2_get_rubyOverhang,
+    HTMLCurrentStyle_HTMLStyle2_put_layoutGridChar,
+    HTMLCurrentStyle_HTMLStyle2_get_layoutGridChar,
+    HTMLCurrentStyle_HTMLStyle2_put_layoutGridLine,
+    HTMLCurrentStyle_HTMLStyle2_get_layoutGridLine,
+    HTMLCurrentStyle_HTMLStyle2_put_layoutGridMode,
+    HTMLCurrentStyle_HTMLStyle2_get_layoutGridMode,
+    HTMLCurrentStyle_HTMLStyle2_put_layoutGridType,
+    HTMLCurrentStyle_HTMLStyle2_get_layoutGridType,
+    HTMLCurrentStyle_HTMLStyle2_put_layoutGrid,
+    HTMLCurrentStyle_HTMLStyle2_get_layoutGrid,
+    HTMLCurrentStyle_HTMLStyle2_put_wordBreak,
+    HTMLCurrentStyle_HTMLStyle2_get_wordBreak,
+    HTMLCurrentStyle_HTMLStyle2_put_lineBreak,
+    HTMLCurrentStyle_HTMLStyle2_get_lineBreak,
+    HTMLCurrentStyle_HTMLStyle2_put_textJustify,
+    HTMLCurrentStyle_HTMLStyle2_get_textJustify,
+    HTMLCurrentStyle_HTMLStyle2_put_textJustifyTrim,
+    HTMLCurrentStyle_HTMLStyle2_get_textJustifyTrim,
+    HTMLCurrentStyle_HTMLStyle2_put_textKashida,
+    HTMLCurrentStyle_HTMLStyle2_get_textKashida,
+    HTMLCurrentStyle_HTMLStyle2_put_textAutospace,
+    HTMLCurrentStyle_HTMLStyle2_get_textAutospace,
+    HTMLCurrentStyle_HTMLStyle2_put_overflowX,
+    HTMLCurrentStyle_HTMLStyle2_get_overflowX,
+    HTMLCurrentStyle_HTMLStyle2_put_overflowY,
+    HTMLCurrentStyle_HTMLStyle2_get_overflowY,
+    HTMLCurrentStyle_HTMLStyle2_put_accelerator,
+    HTMLCurrentStyle_HTMLStyle2_get_accelerator
+};
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_QueryInterface(IHTMLStyle3 *iface, REFIID riid, void **ppv)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    return IHTMLCurrentStyle_QueryInterface(&This->IHTMLCurrentStyle_iface, riid, ppv);
+}
+
+static ULONG WINAPI HTMLCurrentStyle_HTMLStyle3_AddRef(IHTMLStyle3 *iface)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    return IHTMLCurrentStyle_AddRef(&This->IHTMLCurrentStyle_iface);
+}
+
+static ULONG WINAPI HTMLCurrentStyle_HTMLStyle3_Release(IHTMLStyle3 *iface)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    return IHTMLCurrentStyle_Release(&This->IHTMLCurrentStyle_iface);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_GetTypeInfoCount(IHTMLStyle3 *iface, UINT *pctinfo)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    return IDispatchEx_GetTypeInfoCount(&This->css_style.dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_GetTypeInfo(IHTMLStyle3 *iface, UINT iTInfo,
+                                              LCID lcid, ITypeInfo **ppTInfo)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    return IDispatchEx_GetTypeInfo(&This->css_style.dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_GetIDsOfNames(IHTMLStyle3 *iface, REFIID riid,
+                                                LPOLESTR *rgszNames, UINT cNames,
+                                                LCID lcid, DISPID *rgDispId)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    return IDispatchEx_GetIDsOfNames(&This->css_style.dispex.IDispatchEx_iface, riid, rgszNames, cNames,
+            lcid, rgDispId);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_Invoke(IHTMLStyle3 *iface, DISPID dispIdMember,
+                            REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+                            VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    return IDispatchEx_Invoke(&This->css_style.dispex.IDispatchEx_iface, dispIdMember, riid, lcid,
+            wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_put_layoutFlow(IHTMLStyle3 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_get_layoutFlow(IHTMLStyle3 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_put_zoom(IHTMLStyle3 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_get_zoom(IHTMLStyle3 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    TRACE("(%p)->(%p)\n", This, p);
+    return IHTMLCSSStyleDeclaration_get_zoom(&This->css_style.IHTMLCSSStyleDeclaration_iface, p);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_put_wordWrap(IHTMLStyle3 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_get_wordWrap(IHTMLStyle3 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_put_textUnderlinePosition(IHTMLStyle3 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_get_textUnderlinePosition(IHTMLStyle3 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_put_scrollbarBaseColor(IHTMLStyle3 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_get_scrollbarBaseColor(IHTMLStyle3 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_put_scrollbarFaceColor(IHTMLStyle3 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_get_scrollbarFaceColor(IHTMLStyle3 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_put_scrollbar3dLightColor(IHTMLStyle3 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_get_scrollbar3dLightColor(IHTMLStyle3 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_put_scrollbarShadowColor(IHTMLStyle3 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_get_scrollbarShadowColor(IHTMLStyle3 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_put_scrollbarHighlightColor(IHTMLStyle3 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_get_scrollbarHighlightColor(IHTMLStyle3 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_put_scrollbarDarkShadowColor(IHTMLStyle3 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_get_scrollbarDarkShadowColor(IHTMLStyle3 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_put_scrollbarArrowColor(IHTMLStyle3 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_get_scrollbarArrowColor(IHTMLStyle3 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_put_scrollbarTrackColor(IHTMLStyle3 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_get_scrollbarTrackColor(IHTMLStyle3 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_put_writingMode(IHTMLStyle3 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_get_writingMode(IHTMLStyle3 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_put_textAlignLast(IHTMLStyle3 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_get_textAlignLast(IHTMLStyle3 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_put_textKashidaSpace(IHTMLStyle3 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle3_get_textKashidaSpace(IHTMLStyle3 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static const IHTMLStyle3Vtbl HTMLStyle3Vtbl = {
+    HTMLCurrentStyle_HTMLStyle3_QueryInterface,
+    HTMLCurrentStyle_HTMLStyle3_AddRef,
+    HTMLCurrentStyle_HTMLStyle3_Release,
+    HTMLCurrentStyle_HTMLStyle3_GetTypeInfoCount,
+    HTMLCurrentStyle_HTMLStyle3_GetTypeInfo,
+    HTMLCurrentStyle_HTMLStyle3_GetIDsOfNames,
+    HTMLCurrentStyle_HTMLStyle3_Invoke,
+    HTMLCurrentStyle_HTMLStyle3_put_layoutFlow,
+    HTMLCurrentStyle_HTMLStyle3_get_layoutFlow,
+    HTMLCurrentStyle_HTMLStyle3_put_zoom,
+    HTMLCurrentStyle_HTMLStyle3_get_zoom,
+    HTMLCurrentStyle_HTMLStyle3_put_wordWrap,
+    HTMLCurrentStyle_HTMLStyle3_get_wordWrap,
+    HTMLCurrentStyle_HTMLStyle3_put_textUnderlinePosition,
+    HTMLCurrentStyle_HTMLStyle3_get_textUnderlinePosition,
+    HTMLCurrentStyle_HTMLStyle3_put_scrollbarBaseColor,
+    HTMLCurrentStyle_HTMLStyle3_get_scrollbarBaseColor,
+    HTMLCurrentStyle_HTMLStyle3_put_scrollbarFaceColor,
+    HTMLCurrentStyle_HTMLStyle3_get_scrollbarFaceColor,
+    HTMLCurrentStyle_HTMLStyle3_put_scrollbar3dLightColor,
+    HTMLCurrentStyle_HTMLStyle3_get_scrollbar3dLightColor,
+    HTMLCurrentStyle_HTMLStyle3_put_scrollbarShadowColor,
+    HTMLCurrentStyle_HTMLStyle3_get_scrollbarShadowColor,
+    HTMLCurrentStyle_HTMLStyle3_put_scrollbarHighlightColor,
+    HTMLCurrentStyle_HTMLStyle3_get_scrollbarHighlightColor,
+    HTMLCurrentStyle_HTMLStyle3_put_scrollbarDarkShadowColor,
+    HTMLCurrentStyle_HTMLStyle3_get_scrollbarDarkShadowColor,
+    HTMLCurrentStyle_HTMLStyle3_put_scrollbarArrowColor,
+    HTMLCurrentStyle_HTMLStyle3_get_scrollbarArrowColor,
+    HTMLCurrentStyle_HTMLStyle3_put_scrollbarTrackColor,
+    HTMLCurrentStyle_HTMLStyle3_get_scrollbarTrackColor,
+    HTMLCurrentStyle_HTMLStyle3_put_writingMode,
+    HTMLCurrentStyle_HTMLStyle3_get_writingMode,
+    HTMLCurrentStyle_HTMLStyle3_put_textAlignLast,
+    HTMLCurrentStyle_HTMLStyle3_get_textAlignLast,
+    HTMLCurrentStyle_HTMLStyle3_put_textKashidaSpace,
+    HTMLCurrentStyle_HTMLStyle3_get_textKashidaSpace
+};
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle5_QueryInterface(IHTMLStyle5 *iface, REFIID riid, void **ppv)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle5(iface);
+    return IHTMLCurrentStyle_QueryInterface(&This->IHTMLCurrentStyle_iface, riid, ppv);
+}
+
+static ULONG WINAPI HTMLCurrentStyle_HTMLStyle5_AddRef(IHTMLStyle5 *iface)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle5(iface);
+    return IHTMLCurrentStyle_AddRef(&This->IHTMLCurrentStyle_iface);
+}
+
+static ULONG WINAPI HTMLCurrentStyle_HTMLStyle5_Release(IHTMLStyle5 *iface)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle5(iface);
+    return IHTMLCurrentStyle_Release(&This->IHTMLCurrentStyle_iface);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle5_GetTypeInfoCount(IHTMLStyle5 *iface, UINT *pctinfo)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle5(iface);
+    return IDispatchEx_GetTypeInfoCount(&This->css_style.dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle5_GetTypeInfo(IHTMLStyle5 *iface, UINT iTInfo,
+        LCID lcid, ITypeInfo **ppTInfo)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle5(iface);
+    return IDispatchEx_GetTypeInfo(&This->css_style.dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle5_GetIDsOfNames(IHTMLStyle5 *iface, REFIID riid,
+        LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle5(iface);
+    return IDispatchEx_GetIDsOfNames(&This->css_style.dispex.IDispatchEx_iface, riid, rgszNames, cNames,
+            lcid, rgDispId);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle5_Invoke(IHTMLStyle5 *iface, DISPID dispIdMember,
+                            REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+                            VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle5(iface);
+    return IDispatchEx_Invoke(&This->css_style.dispex.IDispatchEx_iface, dispIdMember, riid, lcid,
+            wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle5_put_msInterpolationMode(IHTMLStyle5 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle5(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle5_get_msInterpolationMode(IHTMLStyle5 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle5(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle5_put_maxHeight(IHTMLStyle5 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle5(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle5_get_maxHeight(IHTMLStyle5 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle5(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(p));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle5_put_minWidth(IHTMLStyle5 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle5(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle5_get_minWidth(IHTMLStyle5 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle5(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle5_put_maxWidth(IHTMLStyle5 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle5(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle5_get_maxWidth(IHTMLStyle5 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle5(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static const IHTMLStyle5Vtbl HTMLStyle5Vtbl = {
+    HTMLCurrentStyle_HTMLStyle5_QueryInterface,
+    HTMLCurrentStyle_HTMLStyle5_AddRef,
+    HTMLCurrentStyle_HTMLStyle5_Release,
+    HTMLCurrentStyle_HTMLStyle5_GetTypeInfoCount,
+    HTMLCurrentStyle_HTMLStyle5_GetTypeInfo,
+    HTMLCurrentStyle_HTMLStyle5_GetIDsOfNames,
+    HTMLCurrentStyle_HTMLStyle5_Invoke,
+    HTMLCurrentStyle_HTMLStyle5_put_msInterpolationMode,
+    HTMLCurrentStyle_HTMLStyle5_get_msInterpolationMode,
+    HTMLCurrentStyle_HTMLStyle5_put_maxHeight,
+    HTMLCurrentStyle_HTMLStyle5_get_maxHeight,
+    HTMLCurrentStyle_HTMLStyle5_put_minWidth,
+    HTMLCurrentStyle_HTMLStyle5_get_minWidth,
+    HTMLCurrentStyle_HTMLStyle5_put_maxWidth,
+    HTMLCurrentStyle_HTMLStyle5_get_maxWidth
+};
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_QueryInterface(IHTMLStyle6 *iface, REFIID riid, void **ppv)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    return IHTMLCurrentStyle_QueryInterface(&This->IHTMLCurrentStyle_iface, riid, ppv);
+}
+
+static ULONG WINAPI HTMLCurrentStyle_HTMLStyle6_AddRef(IHTMLStyle6 *iface)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    return IHTMLCurrentStyle_AddRef(&This->IHTMLCurrentStyle_iface);
+}
+
+static ULONG WINAPI HTMLCurrentStyle_HTMLStyle6_Release(IHTMLStyle6 *iface)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    return IHTMLCurrentStyle_Release(&This->IHTMLCurrentStyle_iface);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_GetTypeInfoCount(IHTMLStyle6 *iface, UINT *pctinfo)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    return IDispatchEx_GetTypeInfoCount(&This->css_style.dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_GetTypeInfo(IHTMLStyle6 *iface, UINT iTInfo,
+        LCID lcid, ITypeInfo **ppTInfo)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    return IDispatchEx_GetTypeInfo(&This->css_style.dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_GetIDsOfNames(IHTMLStyle6 *iface, REFIID riid,
+        LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    return IDispatchEx_GetIDsOfNames(&This->css_style.dispex.IDispatchEx_iface, riid, rgszNames, cNames,
+            lcid, rgDispId);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_Invoke(IHTMLStyle6 *iface, DISPID dispIdMember,
+                            REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+                            VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    return IDispatchEx_Invoke(&This->css_style.dispex.IDispatchEx_iface, dispIdMember, riid, lcid,
+            wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_put_content(IHTMLStyle6 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_get_content(IHTMLStyle6 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_put_contentSide(IHTMLStyle6 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_get_contentSide(IHTMLStyle6 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_put_counterIncrement(IHTMLStyle6 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_get_counterIncrement(IHTMLStyle6 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_put_counterReset(IHTMLStyle6 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_get_counterReset(IHTMLStyle6 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_put_outline(IHTMLStyle6 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_get_outline(IHTMLStyle6 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_put_outlineWidth(IHTMLStyle6 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_get_outlineWidth(IHTMLStyle6 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_put_outlineStyle(IHTMLStyle6 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_get_outlineStyle(IHTMLStyle6 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_put_outlineColor(IHTMLStyle6 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_get_outlineColor(IHTMLStyle6 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_put_boxSizing(IHTMLStyle6 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_get_boxSizing(IHTMLStyle6 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_put_borderSpacing(IHTMLStyle6 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_get_borderSpacing(IHTMLStyle6 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_put_orphans(IHTMLStyle6 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_get_orphans(IHTMLStyle6 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_put_windows(IHTMLStyle6 *iface, VARIANT v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_get_windows(IHTMLStyle6 *iface, VARIANT *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_put_pageBreakInside(IHTMLStyle6 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_get_pageBreakInside(IHTMLStyle6 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_put_emptyCells(IHTMLStyle6 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_get_emptyCells(IHTMLStyle6 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_put_msBlockProgression(IHTMLStyle6 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    TRACE("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_FAIL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_get_msBlockProgression(IHTMLStyle6 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_put_quotes(IHTMLStyle6 *iface, BSTR v)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLCurrentStyle_HTMLStyle6_get_quotes(IHTMLStyle6 *iface, BSTR *p)
+{
+    HTMLCurrentStyle *This = impl_from_IHTMLStyle6(iface);
+    WARN("(%p)->(%p)\n", This, p);
+    return E_UNEXPECTED;
+}
+
+static const IHTMLStyle6Vtbl HTMLStyle6Vtbl = {
+    HTMLCurrentStyle_HTMLStyle6_QueryInterface,
+    HTMLCurrentStyle_HTMLStyle6_AddRef,
+    HTMLCurrentStyle_HTMLStyle6_Release,
+    HTMLCurrentStyle_HTMLStyle6_GetTypeInfoCount,
+    HTMLCurrentStyle_HTMLStyle6_GetTypeInfo,
+    HTMLCurrentStyle_HTMLStyle6_GetIDsOfNames,
+    HTMLCurrentStyle_HTMLStyle6_Invoke,
+    HTMLCurrentStyle_HTMLStyle6_put_content,
+    HTMLCurrentStyle_HTMLStyle6_get_content,
+    HTMLCurrentStyle_HTMLStyle6_put_contentSide,
+    HTMLCurrentStyle_HTMLStyle6_get_contentSide,
+    HTMLCurrentStyle_HTMLStyle6_put_counterIncrement,
+    HTMLCurrentStyle_HTMLStyle6_get_counterIncrement,
+    HTMLCurrentStyle_HTMLStyle6_put_counterReset,
+    HTMLCurrentStyle_HTMLStyle6_get_counterReset,
+    HTMLCurrentStyle_HTMLStyle6_put_outline,
+    HTMLCurrentStyle_HTMLStyle6_get_outline,
+    HTMLCurrentStyle_HTMLStyle6_put_outlineWidth,
+    HTMLCurrentStyle_HTMLStyle6_get_outlineWidth,
+    HTMLCurrentStyle_HTMLStyle6_put_outlineStyle,
+    HTMLCurrentStyle_HTMLStyle6_get_outlineStyle,
+    HTMLCurrentStyle_HTMLStyle6_put_outlineColor,
+    HTMLCurrentStyle_HTMLStyle6_get_outlineColor,
+    HTMLCurrentStyle_HTMLStyle6_put_boxSizing,
+    HTMLCurrentStyle_HTMLStyle6_get_boxSizing,
+    HTMLCurrentStyle_HTMLStyle6_put_borderSpacing,
+    HTMLCurrentStyle_HTMLStyle6_get_borderSpacing,
+    HTMLCurrentStyle_HTMLStyle6_put_orphans,
+    HTMLCurrentStyle_HTMLStyle6_get_orphans,
+    HTMLCurrentStyle_HTMLStyle6_put_windows,
+    HTMLCurrentStyle_HTMLStyle6_get_windows,
+    HTMLCurrentStyle_HTMLStyle6_put_pageBreakInside,
+    HTMLCurrentStyle_HTMLStyle6_get_pageBreakInside,
+    HTMLCurrentStyle_HTMLStyle6_put_emptyCells,
+    HTMLCurrentStyle_HTMLStyle6_get_emptyCells,
+    HTMLCurrentStyle_HTMLStyle6_put_msBlockProgression,
+    HTMLCurrentStyle_HTMLStyle6_get_msBlockProgression,
+    HTMLCurrentStyle_HTMLStyle6_put_quotes,
+    HTMLCurrentStyle_HTMLStyle6_get_quotes
+};
+
 static const tid_t HTMLCurrentStyle_iface_tids[] = {
     IHTMLCurrentStyle_tid,
     IHTMLCurrentStyle2_tid,
@@ -1299,9 +4133,10 @@ static const tid_t HTMLCurrentStyle_iface_tids[] = {
     IHTMLCurrentStyle4_tid,
     0
 };
-static dispex_static_data_t HTMLCurrentStyle_dispex = {
+dispex_static_data_t HTMLCurrentStyle_dispex = {
     L"MSCurrentStyleCSSProperties",
     &CSSStyle_dispex_vtbl,
+    PROTO_ID_HTMLCurrentStyle,
     DispHTMLCurrentStyle_tid,
     HTMLCurrentStyle_iface_tids,
     CSSStyle_init_dispex_info
@@ -1321,7 +4156,7 @@ HRESULT HTMLCurrentStyle_Create(HTMLElement *elem, IHTMLCurrentStyle **p)
         return E_UNEXPECTED;
     }
 
-    nsres = nsIDOMHTMLDocument_GetDefaultView(elem->node.doc->nsdoc, &nsview);
+    nsres = nsIDOMDocument_GetDefaultView(elem->node.doc->nsdoc, &nsview);
     if(NS_FAILED(nsres)) {
         ERR("GetDefaultView failed: %08lx\n", nsres);
         return E_FAIL;
@@ -1355,9 +4190,14 @@ HRESULT HTMLCurrentStyle_Create(HTMLElement *elem, IHTMLCurrentStyle **p)
     ret->IHTMLCurrentStyle2_iface.lpVtbl = &HTMLCurrentStyle2Vtbl;
     ret->IHTMLCurrentStyle3_iface.lpVtbl = &HTMLCurrentStyle3Vtbl;
     ret->IHTMLCurrentStyle4_iface.lpVtbl = &HTMLCurrentStyle4Vtbl;
+    ret->IHTMLStyle_iface.lpVtbl         = &HTMLStyleVtbl;
+    ret->IHTMLStyle2_iface.lpVtbl        = &HTMLStyle2Vtbl;
+    ret->IHTMLStyle3_iface.lpVtbl        = &HTMLStyle3Vtbl;
+    ret->IHTMLStyle5_iface.lpVtbl        = &HTMLStyle5Vtbl;
+    ret->IHTMLStyle6_iface.lpVtbl        = &HTMLStyle6Vtbl;
 
     init_css_style(&ret->css_style, nsstyle, HTMLCurrentStyle_QI, &HTMLCurrentStyle_dispex,
-                   dispex_compat_mode(&elem->node.event_target.dispex));
+                   elem->node.doc, dispex_compat_mode(&elem->node.event_target.dispex));
     nsIDOMCSSStyleDeclaration_Release(nsstyle);
 
     IHTMLElement_AddRef(&elem->IHTMLElement_iface);
diff --git a/dlls/mshtml/htmldoc.c b/dlls/mshtml/htmldoc.c
index 3a742a86a1b..0ca23be7868 100644
--- a/dlls/mshtml/htmldoc.c
+++ b/dlls/mshtml/htmldoc.c
@@ -26,9 +26,11 @@
 #include "winuser.h"
 #include "wininet.h"
 #include "ole2.h"
+#include "objsafe.h"
 #include "perhist.h"
 #include "mshtmdid.h"
 #include "mshtmcid.h"
+#include "msxml6.h"
 
 #include "wine/debug.h"
 
@@ -44,8 +46,8 @@ static HRESULT create_document_fragment(nsIDOMNode *nsnode, HTMLDocumentNode *do
 HRESULT get_doc_elem_by_id(HTMLDocumentNode *doc, const WCHAR *id, HTMLElement **ret)
 {
     nsIDOMNodeList *nsnode_list;
+    nsIDOMNode *nsnode = NULL;
     nsIDOMElement *nselem;
-    nsIDOMNode *nsnode;
     nsAString id_str;
     nsresult nsres;
     HRESULT hres;
@@ -57,7 +59,7 @@ HRESULT get_doc_elem_by_id(HTMLDocumentNode *doc, const WCHAR *id, HTMLElement *
 
     nsAString_InitDepend(&id_str, id);
     /* get element by id attribute */
-    nsres = nsIDOMHTMLDocument_GetElementById(doc->nsdoc, &id_str, &nselem);
+    nsres = nsIDOMDocument_GetElementById(doc->nsdoc, &id_str, &nselem);
     if(FAILED(nsres)) {
         ERR("GetElementById failed: %08lx\n", nsres);
         nsAString_Finish(&id_str);
@@ -65,18 +67,20 @@ HRESULT get_doc_elem_by_id(HTMLDocumentNode *doc, const WCHAR *id, HTMLElement *
     }
 
     /* get first element by name attribute */
-    nsres = nsIDOMHTMLDocument_GetElementsByName(doc->nsdoc, &id_str, &nsnode_list);
-    nsAString_Finish(&id_str);
-    if(FAILED(nsres)) {
-        ERR("getElementsByName failed: %08lx\n", nsres);
-        if(nselem)
-            nsIDOMElement_Release(nselem);
-        return E_FAIL;
-    }
+    if(doc->nshtmldoc) {
+        nsres = nsIDOMHTMLDocument_GetElementsByName(doc->nshtmldoc, &id_str, &nsnode_list);
+        nsAString_Finish(&id_str);
+        if(FAILED(nsres)) {
+            ERR("getElementsByName failed: %08lx\n", nsres);
+            if(nselem)
+                nsIDOMElement_Release(nselem);
+            return E_FAIL;
+        }
 
-    nsres = nsIDOMNodeList_Item(nsnode_list, 0, &nsnode);
-    nsIDOMNodeList_Release(nsnode_list);
-    assert(nsres == NS_OK);
+        nsres = nsIDOMNodeList_Item(nsnode_list, 0, &nsnode);
+        nsIDOMNodeList_Release(nsnode_list);
+        assert(nsres == NS_OK);
+    }
 
     if(nsnode && nselem) {
         UINT16 pos;
@@ -124,7 +128,7 @@ UINT get_document_charset(HTMLDocumentNode *doc)
         return doc->charset;
 
     nsAString_Init(&charset_str, NULL);
-    nsres = nsIDOMHTMLDocument_GetCharacterSet(doc->nsdoc, &charset_str);
+    nsres = nsIDOMDocument_GetCharacterSet(doc->nsdoc, &charset_str);
     if(NS_SUCCEEDED(nsres)) {
         const PRUnichar *charset;
 
@@ -233,7 +237,7 @@ static HRESULT WINAPI HTMLDocument_get_all(IHTMLDocument2 *iface, IHTMLElementCo
         return E_UNEXPECTED;
     }
 
-    nsres = nsIDOMHTMLDocument_GetDocumentElement(This->doc_node->nsdoc, &nselem);
+    nsres = nsIDOMDocument_GetDocumentElement(This->doc_node->nsdoc, &nselem);
     if(NS_FAILED(nsres)) {
         ERR("GetDocumentElement failed: %08lx\n", nsres);
         return E_FAIL;
@@ -263,10 +267,10 @@ static HRESULT WINAPI HTMLDocument_get_body(IHTMLDocument2 *iface, IHTMLElement
 
     TRACE("(%p)->(%p)\n", This, p);
 
-    if(This->doc_node->nsdoc) {
+    if(This->doc_node->nshtmldoc) {
         nsresult nsres;
 
-        nsres = nsIDOMHTMLDocument_GetBody(This->doc_node->nsdoc, &nsbody);
+        nsres = nsIDOMHTMLDocument_GetBody(This->doc_node->nshtmldoc, &nsbody);
         if(NS_FAILED(nsres)) {
             TRACE("Could not get body: %08lx\n", nsres);
             return E_UNEXPECTED;
@@ -306,7 +310,7 @@ static HRESULT WINAPI HTMLDocument_get_activeElement(IHTMLDocument2 *iface, IHTM
      * NOTE: Gecko may return an active element even if the document is not visible.
      * IE returns NULL in this case.
      */
-    nsres = nsIDOMHTMLDocument_GetActiveElement(This->doc_node->nsdoc, &nselem);
+    nsres = nsIDOMDocument_GetActiveElement(This->doc_node->nsdoc, &nselem);
     if(NS_FAILED(nsres)) {
         ERR("GetActiveElement failed: %08lx\n", nsres);
         return E_FAIL;
@@ -344,14 +348,19 @@ static HRESULT WINAPI HTMLDocument_get_images(IHTMLDocument2 *iface, IHTMLElemen
         return E_UNEXPECTED;
     }
 
-    nsres = nsIDOMHTMLDocument_GetImages(This->doc_node->nsdoc, &nscoll);
+    if(!This->doc_node->nshtmldoc) {
+        FIXME("Not implemented for XML document\n");
+        return E_NOTIMPL;
+    }
+
+    nsres = nsIDOMHTMLDocument_GetImages(This->doc_node->nshtmldoc, &nscoll);
     if(NS_FAILED(nsres)) {
         ERR("GetImages failed: %08lx\n", nsres);
         return E_FAIL;
     }
 
     if(nscoll) {
-        *p = create_collection_from_htmlcol(nscoll, This->doc_node->document_mode);
+        *p = create_collection_from_htmlcol(nscoll, This->doc_node);
         nsIDOMHTMLCollection_Release(nscoll);
     }
 
@@ -376,14 +385,19 @@ static HRESULT WINAPI HTMLDocument_get_applets(IHTMLDocument2 *iface, IHTMLEleme
         return E_UNEXPECTED;
     }
 
-    nsres = nsIDOMHTMLDocument_GetApplets(This->doc_node->nsdoc, &nscoll);
+    if(!This->doc_node->nshtmldoc) {
+        FIXME("Not implemented for XML document\n");
+        return E_NOTIMPL;
+    }
+
+    nsres = nsIDOMHTMLDocument_GetApplets(This->doc_node->nshtmldoc, &nscoll);
     if(NS_FAILED(nsres)) {
         ERR("GetApplets failed: %08lx\n", nsres);
         return E_FAIL;
     }
 
     if(nscoll) {
-        *p = create_collection_from_htmlcol(nscoll, This->doc_node->document_mode);
+        *p = create_collection_from_htmlcol(nscoll, This->doc_node);
         nsIDOMHTMLCollection_Release(nscoll);
     }
 
@@ -408,14 +422,19 @@ static HRESULT WINAPI HTMLDocument_get_links(IHTMLDocument2 *iface, IHTMLElement
         return E_UNEXPECTED;
     }
 
-    nsres = nsIDOMHTMLDocument_GetLinks(This->doc_node->nsdoc, &nscoll);
+    if(!This->doc_node->nshtmldoc) {
+        FIXME("Not implemented for XML document\n");
+        return E_NOTIMPL;
+    }
+
+    nsres = nsIDOMHTMLDocument_GetLinks(This->doc_node->nshtmldoc, &nscoll);
     if(NS_FAILED(nsres)) {
         ERR("GetLinks failed: %08lx\n", nsres);
         return E_FAIL;
     }
 
     if(nscoll) {
-        *p = create_collection_from_htmlcol(nscoll, This->doc_node->document_mode);
+        *p = create_collection_from_htmlcol(nscoll, This->doc_node);
         nsIDOMHTMLCollection_Release(nscoll);
     }
 
@@ -440,14 +459,19 @@ static HRESULT WINAPI HTMLDocument_get_forms(IHTMLDocument2 *iface, IHTMLElement
         return E_UNEXPECTED;
     }
 
-    nsres = nsIDOMHTMLDocument_GetForms(This->doc_node->nsdoc, &nscoll);
+    if(!This->doc_node->nshtmldoc) {
+        FIXME("Not implemented for XML document\n");
+        return E_NOTIMPL;
+    }
+
+    nsres = nsIDOMHTMLDocument_GetForms(This->doc_node->nshtmldoc, &nscoll);
     if(NS_FAILED(nsres)) {
         ERR("GetForms failed: %08lx\n", nsres);
         return E_FAIL;
     }
 
     if(nscoll) {
-        *p = create_collection_from_htmlcol(nscoll, This->doc_node->document_mode);
+        *p = create_collection_from_htmlcol(nscoll, This->doc_node);
         nsIDOMHTMLCollection_Release(nscoll);
     }
 
@@ -472,16 +496,20 @@ static HRESULT WINAPI HTMLDocument_get_anchors(IHTMLDocument2 *iface, IHTMLEleme
         return E_UNEXPECTED;
     }
 
-    nsres = nsIDOMHTMLDocument_GetAnchors(This->doc_node->nsdoc, &nscoll);
-    if(NS_FAILED(nsres)) {
-        ERR("GetAnchors failed: %08lx\n", nsres);
-        return E_FAIL;
+    if(This->doc_type == DOCTYPE_XHTML)
+        FIXME("Not implemented for XHTML Document, returning empty list\n");
+
+    if(This->doc_node->nshtmldoc) {
+        nsres = nsIDOMHTMLDocument_GetAnchors(This->doc_node->nshtmldoc, &nscoll);
+        if(NS_FAILED(nsres)) {
+            ERR("GetAnchors failed: %08lx\n", nsres);
+            return E_FAIL;
+        }
     }
 
-    if(nscoll) {
-        *p = create_collection_from_htmlcol(nscoll, This->doc_node->document_mode);
+    *p = create_collection_from_htmlcol(nscoll, This->doc_node);
+    if(nscoll)
         nsIDOMHTMLCollection_Release(nscoll);
-    }
 
     return S_OK;
 }
@@ -500,7 +528,7 @@ static HRESULT WINAPI HTMLDocument_put_title(IHTMLDocument2 *iface, BSTR v)
     }
 
     nsAString_InitDepend(&nsstr, v);
-    nsres = nsIDOMHTMLDocument_SetTitle(This->doc_node->nsdoc, &nsstr);
+    nsres = nsIDOMDocument_SetTitle(This->doc_node->nsdoc, &nsstr);
     nsAString_Finish(&nsstr);
     if(NS_FAILED(nsres))
         ERR("SetTitle failed: %08lx\n", nsres);
@@ -524,7 +552,7 @@ static HRESULT WINAPI HTMLDocument_get_title(IHTMLDocument2 *iface, BSTR *p)
 
 
     nsAString_Init(&nsstr, NULL);
-    nsres = nsIDOMHTMLDocument_GetTitle(This->doc_node->nsdoc, &nsstr);
+    nsres = nsIDOMDocument_GetTitle(This->doc_node->nsdoc, &nsstr);
     if (NS_SUCCEEDED(nsres)) {
         nsAString_GetData(&nsstr, &ret);
         *p = SysAllocString(ret);
@@ -557,14 +585,19 @@ static HRESULT WINAPI HTMLDocument_get_scripts(IHTMLDocument2 *iface, IHTMLEleme
         return E_UNEXPECTED;
     }
 
-    nsres = nsIDOMHTMLDocument_GetScripts(This->doc_node->nsdoc, &nscoll);
+    if(!This->doc_node->nshtmldoc) {
+        FIXME("Not implemented for XML document\n");
+        return E_NOTIMPL;
+    }
+
+    nsres = nsIDOMHTMLDocument_GetScripts(This->doc_node->nshtmldoc, &nscoll);
     if(NS_FAILED(nsres)) {
         ERR("GetImages failed: %08lx\n", nsres);
         return E_FAIL;
     }
 
     if(nscoll) {
-        *p = create_collection_from_htmlcol(nscoll, This->doc_node->document_mode);
+        *p = create_collection_from_htmlcol(nscoll, This->doc_node);
         nsIDOMHTMLCollection_Release(nscoll);
     }
 
@@ -612,7 +645,15 @@ static HRESULT WINAPI HTMLDocument_get_selection(IHTMLDocument2 *iface, IHTMLSel
 
     TRACE("(%p)->(%p)\n", This, p);
 
-    nsres = nsIDOMWindow_GetSelection(This->window->nswindow, &nsselection);
+    if(This->window)
+        nsres = nsIDOMWindow_GetSelection(This->window->nswindow, &nsselection);
+    else {
+        if(!This->doc_node->nshtmldoc) {
+            FIXME("Not implemented for XML document\n");
+            return E_NOTIMPL;
+        }
+        nsres = nsIDOMHTMLDocument_GetSelection(This->doc_node->nshtmldoc, &nsselection);
+    }
     if(NS_FAILED(nsres)) {
         ERR("GetSelection failed: %08lx\n", nsres);
         return E_FAIL;
@@ -631,7 +672,7 @@ static HRESULT WINAPI HTMLDocument_get_readyState(IHTMLDocument2 *iface, BSTR *p
     if(!p)
         return E_POINTER;
 
-    return get_readystate_string(This->window->readystate, p);
+    return get_readystate_string(This->window ? This->window->readystate : 0, p);
 }
 
 static HRESULT WINAPI HTMLDocument_get_frames(IHTMLDocument2 *iface, IHTMLFramesCollection2 **p)
@@ -640,6 +681,10 @@ static HRESULT WINAPI HTMLDocument_get_frames(IHTMLDocument2 *iface, IHTMLFrames
 
     TRACE("(%p)->(%p)\n", This, p);
 
+    if(!This->window) {
+        /* Not implemented by IE */
+        return E_NOTIMPL;
+    }
     return IHTMLWindow2_get_frames(&This->window->base.IHTMLWindow2_iface, p);
 }
 
@@ -718,8 +763,13 @@ static HRESULT WINAPI HTMLDocument_get_bgColor(IHTMLDocument2 *iface, VARIANT *p
         return E_UNEXPECTED;
     }
 
+    if(!This->doc_node->nshtmldoc) {
+        FIXME("Not implemented for XML document\n");
+        return E_NOTIMPL;
+    }
+
     nsAString_Init(&nsstr, NULL);
-    nsres = nsIDOMHTMLDocument_GetBgColor(This->doc_node->nsdoc, &nsstr);
+    nsres = nsIDOMHTMLDocument_GetBgColor(This->doc_node->nshtmldoc, &nsstr);
     hres = return_nsstr_variant(nsres, &nsstr, NSSTR_COLOR, p);
     if(hres == S_OK && V_VT(p) == VT_BSTR && !V_BSTR(p)) {
         TRACE("default #ffffff\n");
@@ -774,12 +824,32 @@ static HRESULT WINAPI HTMLDocument_get_vlinkColor(IHTMLDocument2 *iface, VARIANT
 static HRESULT WINAPI HTMLDocument_get_referrer(IHTMLDocument2 *iface, BSTR *p)
 {
     HTMLDocument *This = impl_from_IHTMLDocument2(iface);
+    nsACString spec_str;
+    const char *spec;
+    nsIURI *referrer;
+    WCHAR *specW;
 
-    FIXME("(%p)->(%p)\n", This, p);
+    TRACE("(%p)->(%p)\n", This, p);
 
     *p = NULL;
-    return S_OK;
- }
+    if(!This->window || !This->window->base.inner_window->bscallback ||
+       !(referrer = This->window->base.inner_window->bscallback->nschannel->referrer))
+        return S_OK;
+
+    nsACString_Init(&spec_str, NULL);
+    if(NS_FAILED(nsIURI_GetSpec(referrer, &spec_str))) {
+        WARN("GetSpec failed, returning NULL\n");
+        return S_OK;
+    }
+    nsACString_GetData(&spec_str, &spec);
+    if(spec && (specW = heap_strdupAtoW(spec))) {
+        *p = SysAllocString(specW);
+        heap_free(specW);
+    }
+    nsACString_Finish(&spec_str);
+
+    return *p || !spec ? S_OK : E_OUTOFMEMORY;
+}
 
 static HRESULT WINAPI HTMLDocument_get_location(IHTMLDocument2 *iface, IHTMLLocation **p)
 {
@@ -795,6 +865,17 @@ static HRESULT WINAPI HTMLDocument_get_location(IHTMLDocument2 *iface, IHTMLLoca
     return IHTMLWindow2_get_location(&This->window->base.IHTMLWindow2_iface, p);
 }
 
+static HRESULT IHTMLDocument2_location_hook(HTMLDocument *doc, WORD flags, DISPPARAMS *dp, VARIANT *res,
+        EXCEPINFO *ei, IServiceProvider *caller)
+{
+    if(!(flags & DISPATCH_PROPERTYPUT) || !doc->window)
+        return S_FALSE;
+
+    return dispex_invoke(&doc->window->base.inner_window->event_target.dispex,
+                         (IDispatch*)&doc->window->base.IHTMLWindow2_iface,
+                         DISPID_IHTMLWINDOW2_LOCATION, 0, flags, dp, res, ei, caller);
+}
+
 static HRESULT WINAPI HTMLDocument_get_lastModified(IHTMLDocument2 *iface, BSTR *p)
 {
     HTMLDocument *This = impl_from_IHTMLDocument2(iface);
@@ -822,7 +903,7 @@ static HRESULT WINAPI HTMLDocument_get_URL(IHTMLDocument2 *iface, BSTR *p)
 
     TRACE("(%p)->(%p)\n", iface, p);
 
-    *p = SysAllocString(This->window->url ? This->window->url : L"about:blank");
+    *p = SysAllocString(This->window && This->window->url ? This->window->url : L"about:blank");
     return *p ? S_OK : E_OUTOFMEMORY;
 }
 
@@ -834,8 +915,13 @@ static HRESULT WINAPI HTMLDocument_put_domain(IHTMLDocument2 *iface, BSTR v)
 
     TRACE("(%p)->(%s)\n", This, debugstr_w(v));
 
+    if(!This->doc_node->nshtmldoc) {
+        FIXME("Not implemented for XML document\n");
+        return E_NOTIMPL;
+    }
+
     nsAString_InitDepend(&nsstr, v);
-    nsres = nsIDOMHTMLDocument_SetDomain(This->doc_node->nsdoc, &nsstr);
+    nsres = nsIDOMHTMLDocument_SetDomain(This->doc_node->nshtmldoc, &nsstr);
     nsAString_Finish(&nsstr);
     if(NS_FAILED(nsres)) {
         ERR("SetDomain failed: %08lx\n", nsres);
@@ -853,8 +939,13 @@ static HRESULT WINAPI HTMLDocument_get_domain(IHTMLDocument2 *iface, BSTR *p)
 
     TRACE("(%p)->(%p)\n", This, p);
 
+    if(!This->doc_node->nshtmldoc) {
+        FIXME("Not implemented for XML document\n");
+        return E_NOTIMPL;
+    }
+
     nsAString_Init(&nsstr, NULL);
-    nsres = nsIDOMHTMLDocument_GetDomain(This->doc_node->nsdoc, &nsstr);
+    nsres = nsIDOMHTMLDocument_GetDomain(This->doc_node->nshtmldoc, &nsstr);
     if(NS_SUCCEEDED(nsres) && This->window && This->window->uri) {
         const PRUnichar *str;
         HRESULT hres;
@@ -878,6 +969,9 @@ static HRESULT WINAPI HTMLDocument_put_cookie(IHTMLDocument2 *iface, BSTR v)
 
     TRACE("(%p)->(%s)\n", This, debugstr_w(v));
 
+    if(!This->window)
+        return S_OK;
+
     bret = InternetSetCookieExW(This->window->url, NULL, v, 0, 0);
     if(!bret) {
         FIXME("InternetSetCookieExW failed: %lu\n", GetLastError());
@@ -895,6 +989,11 @@ static HRESULT WINAPI HTMLDocument_get_cookie(IHTMLDocument2 *iface, BSTR *p)
 
     TRACE("(%p)->(%p)\n", This, p);
 
+    if(!This->window) {
+        *p = NULL;
+        return S_OK;
+    }
+
     size = 0;
     bret = InternetGetCookieExW(This->window->url, NULL, NULL, &size, 0, NULL);
     if(!bret && GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
@@ -971,8 +1070,27 @@ static HRESULT WINAPI HTMLDocument_get_defaultCharset(IHTMLDocument2 *iface, BST
 static HRESULT WINAPI HTMLDocument_get_mimeType(IHTMLDocument2 *iface, BSTR *p)
 {
     HTMLDocument *This = impl_from_IHTMLDocument2(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
+    const char *content_type;
+    WCHAR *content_typeW;
+    HRESULT hres;
+
+    TRACE("(%p)->(%p)\n", This, p);
+
+    *p = NULL;
+
+    if(!This->window)
+        return get_mime_type_display_name(content_type_from_document_type[This->doc_type], p);
+
+    if(!This->window->base.inner_window->bscallback ||
+       !(content_type = This->window->base.inner_window->bscallback->nschannel->content_type))
+        return E_FAIL;
+
+    if(!(content_typeW = heap_strdupAtoW(content_type)))
+        return E_OUTOFMEMORY;
+
+    hres = get_mime_type_display_name(content_typeW, p);
+    heap_free(content_typeW);
+    return hres;
 }
 
 static HRESULT WINAPI HTMLDocument_get_fileSize(IHTMLDocument2 *iface, BSTR *p)
@@ -1038,6 +1156,11 @@ static HRESULT document_write(HTMLDocument *This, SAFEARRAY *psarray, BOOL ln)
         return E_UNEXPECTED;
     }
 
+    if(!This->doc_node->nshtmldoc) {
+        FIXME("Not implemented for XML document\n");
+        return E_NOTIMPL;
+    }
+
     if (!psarray)
         return S_OK;
 
@@ -1069,9 +1192,9 @@ static HRESULT document_write(HTMLDocument *This, SAFEARRAY *psarray, BOOL ln)
         }
 
         if(!ln || i != argc-1)
-            nsres = nsIDOMHTMLDocument_Write(This->doc_node->nsdoc, &nsstr, jsctx);
+            nsres = nsIDOMHTMLDocument_Write(This->doc_node->nshtmldoc, &nsstr, jsctx);
         else
-            nsres = nsIDOMHTMLDocument_Writeln(This->doc_node->nsdoc, &nsstr, jsctx);
+            nsres = nsIDOMHTMLDocument_Writeln(This->doc_node->nshtmldoc, &nsstr, jsctx);
         nsAString_Finish(&nsstr);
         if(V_VT(var+i) != VT_BSTR)
             VariantClear(&tmp);
@@ -1115,16 +1238,26 @@ static HRESULT WINAPI HTMLDocument_open(IHTMLDocument2 *iface, BSTR url, VARIANT
     TRACE("(%p)->(%s %s %s %s %p)\n", This, debugstr_w(url), debugstr_variant(&name),
           debugstr_variant(&features), debugstr_variant(&replace), pomWindowResult);
 
+    *pomWindowResult = NULL;
+
+    if(!This->window)
+        return E_FAIL;
+
     if(!This->doc_node->nsdoc) {
         ERR("!nsdoc\n");
         return E_NOTIMPL;
     }
 
+    if(!This->doc_node->nshtmldoc) {
+        FIXME("Not implemented for XML document\n");
+        return E_NOTIMPL;
+    }
+
     if(!url || wcscmp(url, L"text/html") || V_VT(&name) != VT_ERROR
        || V_VT(&features) != VT_ERROR || V_VT(&replace) != VT_ERROR)
         FIXME("unsupported args\n");
 
-    nsres = nsIDOMHTMLDocument_Open(This->doc_node->nsdoc, NULL, NULL, NULL,
+    nsres = nsIDOMHTMLDocument_Open(This->doc_node->nshtmldoc, NULL, NULL, NULL,
             get_context_from_document(This->doc_node->nsdoc), 0, &tmp);
     if(NS_FAILED(nsres)) {
         ERR("Open failed: %08lx\n", nsres);
@@ -1151,7 +1284,12 @@ static HRESULT WINAPI HTMLDocument_close(IHTMLDocument2 *iface)
         return E_NOTIMPL;
     }
 
-    nsres = nsIDOMHTMLDocument_Close(This->doc_node->nsdoc);
+    if(!This->doc_node->nshtmldoc) {
+        FIXME("Not implemented for XML document\n");
+        return E_NOTIMPL;
+    }
+
+    nsres = nsIDOMHTMLDocument_Close(This->doc_node->nshtmldoc);
     if(NS_FAILED(nsres)) {
         ERR("Close failed: %08lx\n", nsres);
         return E_FAIL;
@@ -1167,7 +1305,12 @@ static HRESULT WINAPI HTMLDocument_clear(IHTMLDocument2 *iface)
 
     TRACE("(%p)\n", This);
 
-    nsres = nsIDOMHTMLDocument_Clear(This->doc_node->nsdoc);
+    if(!This->doc_node->nshtmldoc) {
+        FIXME("Not implemented for XML document\n");
+        return E_NOTIMPL;
+    }
+
+    nsres = nsIDOMHTMLDocument_Clear(This->doc_node->nshtmldoc);
     if(NS_FAILED(nsres)) {
         ERR("Clear failed: %08lx\n", nsres);
         return E_FAIL;
@@ -1609,7 +1752,7 @@ static HRESULT WINAPI HTMLDocument_elementFromPoint(IHTMLDocument2 *iface, LONG
 
     TRACE("(%p)->(%ld %ld %p)\n", This, x, y, elementHit);
 
-    nsres = nsIDOMHTMLDocument_ElementFromPoint(This->doc_node->nsdoc, x, y, &nselem);
+    nsres = nsIDOMDocument_ElementFromPoint(This->doc_node->nsdoc, x, y, &nselem);
     if(NS_FAILED(nsres)) {
         ERR("ElementFromPoint failed: %08lx\n", nsres);
         return E_FAIL;
@@ -1657,14 +1800,13 @@ static HRESULT WINAPI HTMLDocument_get_styleSheets(IHTMLDocument2 *iface,
         return E_UNEXPECTED;
     }
 
-    nsres = nsIDOMHTMLDocument_GetStyleSheets(This->doc_node->nsdoc, &nsstylelist);
+    nsres = nsIDOMDocument_GetStyleSheets(This->doc_node->nsdoc, &nsstylelist);
     if(NS_FAILED(nsres)) {
         ERR("GetStyleSheets failed: %08lx\n", nsres);
         return map_nsresult(nsres);
     }
 
-    hres = create_style_sheet_collection(nsstylelist,
-                                         dispex_compat_mode(&This->doc_node->node.event_target.dispex), p);
+    hres = create_style_sheet_collection(nsstylelist, This->doc_node, p);
     nsIDOMStyleSheetList_Release(nsstylelist);
     return hres;
 }
@@ -1723,20 +1865,24 @@ static HRESULT WINAPI HTMLDocument_createStyleSheet(IHTMLDocument2 *iface, BSTR
         return E_NOTIMPL;
     }
 
+    if(!This->doc_node->nshtmldoc) {
+        FIXME("Not implemented for XML document\n");
+        return E_NOTIMPL;
+    }
+
     if(lIndex != -1)
         FIXME("Unsupported lIndex %ld\n", lIndex);
 
     if(bstrHref && *bstrHref) {
         FIXME("semi-stub for href %s\n", debugstr_w(bstrHref));
-        return create_style_sheet(NULL, dispex_compat_mode(&This->doc_node->node.event_target.dispex),
-                                  ppnewStyleSheet);
+        return create_style_sheet(NULL, This->doc_node, ppnewStyleSheet);
     }
 
     hres = create_element(This->doc_node, L"style", &elem);
     if(FAILED(hres))
         return hres;
 
-    nsres = nsIDOMHTMLDocument_GetHead(This->doc_node->nsdoc, &head_elem);
+    nsres = nsIDOMHTMLDocument_GetHead(This->doc_node->nshtmldoc, &head_elem);
     if(NS_SUCCEEDED(nsres)) {
         nsIDOMNode *head_node, *tmp_node;
 
@@ -1972,7 +2118,7 @@ static HRESULT WINAPI HTMLDocument3_createTextNode(IHTMLDocument3 *iface, BSTR t
     }
 
     nsAString_InitDepend(&text_str, text);
-    nsres = nsIDOMHTMLDocument_CreateTextNode(This->doc_node->nsdoc, &text_str, &nstext);
+    nsres = nsIDOMDocument_CreateTextNode(This->doc_node->nsdoc, &text_str, &nstext);
     nsAString_Finish(&text_str);
     if(NS_FAILED(nsres)) {
         ERR("CreateTextNode failed: %08lx\n", nsres);
@@ -1998,7 +2144,7 @@ static HRESULT WINAPI HTMLDocument3_get_documentElement(IHTMLDocument3 *iface, I
 
     TRACE("(%p)->(%p)\n", This, p);
 
-    if(This->window->readystate == READYSTATE_UNINITIALIZED) {
+    if(This->window && This->window->readystate == READYSTATE_UNINITIALIZED) {
         *p = NULL;
         return S_OK;
     }
@@ -2008,7 +2154,7 @@ static HRESULT WINAPI HTMLDocument3_get_documentElement(IHTMLDocument3 *iface, I
         return E_UNEXPECTED;
     }
 
-    nsres = nsIDOMHTMLDocument_GetDocumentElement(This->doc_node->nsdoc, &nselem);
+    nsres = nsIDOMDocument_GetDocumentElement(This->doc_node->nsdoc, &nselem);
     if(NS_FAILED(nsres)) {
         ERR("GetDocumentElement failed: %08lx\n", nsres);
         return E_FAIL;
@@ -2169,7 +2315,7 @@ static HRESULT WINAPI HTMLDocument3_put_dir(IHTMLDocument3 *iface, BSTR v)
     }
 
     nsAString_InitDepend(&dir_str, v);
-    nsres = nsIDOMHTMLDocument_SetDir(This->doc_node->nsdoc, &dir_str);
+    nsres = nsIDOMDocument_SetDir(This->doc_node->nsdoc, &dir_str);
     nsAString_Finish(&dir_str);
     if(NS_FAILED(nsres)) {
         ERR("SetDir failed: %08lx\n", nsres);
@@ -2193,7 +2339,7 @@ static HRESULT WINAPI HTMLDocument3_get_dir(IHTMLDocument3 *iface, BSTR *p)
     }
 
     nsAString_Init(&dir_str, NULL);
-    nsres = nsIDOMHTMLDocument_GetDir(This->doc_node->nsdoc, &dir_str);
+    nsres = nsIDOMDocument_GetDir(This->doc_node->nsdoc, &dir_str);
     return return_nsstr(nsres, &dir_str, p);
 }
 
@@ -2245,7 +2391,7 @@ static HRESULT WINAPI HTMLDocument3_createDocumentFragment(IHTMLDocument3 *iface
         return E_NOTIMPL;
     }
 
-    nsres = nsIDOMHTMLDocument_CreateDocumentFragment(This->doc_node->nsdoc, &doc_frag);
+    nsres = nsIDOMDocument_CreateDocumentFragment(This->doc_node->nsdoc, &doc_frag);
     if(NS_FAILED(nsres)) {
         ERR("CreateDocumentFragment failed: %08lx\n", nsres);
         return E_FAIL;
@@ -2366,7 +2512,7 @@ static HRESULT WINAPI HTMLDocument3_getElementsByName(IHTMLDocument3 *iface, BST
      * types and search should be case insensitive. Those are currently not supported properly.
      */
     nsAString_InitDepend(&selector_str, selector);
-    nsres = nsIDOMHTMLDocument_QuerySelectorAll(This->doc_node->nsdoc, &selector_str, &node_list);
+    nsres = nsIDOMDocument_QuerySelectorAll(This->doc_node->nsdoc, &selector_str, &node_list);
     nsAString_Finish(&selector_str);
     heap_free(selector);
     if(NS_FAILED(nsres)) {
@@ -2374,7 +2520,7 @@ static HRESULT WINAPI HTMLDocument3_getElementsByName(IHTMLDocument3 *iface, BST
         return E_FAIL;
     }
 
-    *ppelColl = create_collection_from_nodelist(node_list, This->doc_node->document_mode);
+    *ppelColl = create_collection_from_nodelist(node_list, This->doc_node);
     nsIDOMNodeList_Release(node_list);
     return S_OK;
 }
@@ -2412,7 +2558,7 @@ static HRESULT WINAPI HTMLDocument3_getElementsByTagName(IHTMLDocument3 *iface,
 
     if(This->doc_node->nsdoc) {
         nsAString_InitDepend(&id_str, v);
-        nsres = nsIDOMHTMLDocument_GetElementsByTagName(This->doc_node->nsdoc, &id_str, &nslist);
+        nsres = nsIDOMDocument_GetElementsByTagName(This->doc_node->nsdoc, &id_str, &nslist);
         nsAString_Finish(&id_str);
         if(FAILED(nsres)) {
             ERR("GetElementByName failed: %08lx\n", nsres);
@@ -2449,7 +2595,7 @@ static HRESULT WINAPI HTMLDocument3_getElementsByTagName(IHTMLDocument3 *iface,
     }
 
 
-    *pelColl = create_collection_from_nodelist(nslist, This->doc_node->document_mode);
+    *pelColl = create_collection_from_nodelist(nslist, This->doc_node);
     nsIDOMNodeList_Release(nslist);
 
     return S_OK;
@@ -2569,7 +2715,12 @@ static HRESULT WINAPI HTMLDocument4_focus(IHTMLDocument4 *iface)
 
     TRACE("(%p)->()\n", This);
 
-    nsres = nsIDOMHTMLDocument_GetBody(This->doc_node->nsdoc, &nsbody);
+    if(!This->doc_node->nshtmldoc) {
+        FIXME("Not implemented for XML document\n");
+        return E_NOTIMPL;
+    }
+
+    nsres = nsIDOMHTMLDocument_GetBody(This->doc_node->nshtmldoc, &nsbody);
     if(NS_FAILED(nsres) || !nsbody) {
         ERR("GetBody failed: %08lx\n", nsres);
         return E_FAIL;
@@ -2598,7 +2749,7 @@ static HRESULT WINAPI HTMLDocument4_hasFocus(IHTMLDocument4 *iface, VARIANT_BOOL
         return E_NOTIMPL;
     }
 
-    nsres = nsIDOMHTMLDocument_HasFocus(This->doc_node->nsdoc, &has_focus);
+    nsres = nsIDOMDocument_HasFocus(This->doc_node->nsdoc, &has_focus);
     assert(nsres == NS_OK);
 
     *pfFocus = variant_bool(has_focus);
@@ -2632,8 +2783,7 @@ static HRESULT WINAPI HTMLDocument4_get_namespaces(IHTMLDocument4 *iface, IDispa
     if(!This->doc_node->namespaces) {
         HRESULT hres;
 
-        hres = create_namespace_collection(dispex_compat_mode(&This->doc_node->node.event_target.dispex),
-                                           &This->doc_node->namespaces);
+        hres = create_namespace_collection(This->doc_node, &This->doc_node->namespaces);
         if(FAILED(hres))
             return hres;
     }
@@ -2677,7 +2827,7 @@ static HRESULT WINAPI HTMLDocument4_createEventObject(IHTMLDocument4 *iface,
         return E_NOTIMPL;
     }
 
-    return create_event_obj(dispex_compat_mode(&This->doc_node->node.event_target.dispex), ppEventObj);
+    return create_event_obj(This->doc_node, ppEventObj);
 }
 
 static HRESULT WINAPI HTMLDocument4_fireEvent(IHTMLDocument4 *iface, BSTR bstrEventName,
@@ -2846,12 +2996,28 @@ static HRESULT WINAPI HTMLDocument5_createAttribute(IHTMLDocument5 *iface, BSTR
         IHTMLDOMAttribute **ppattribute)
 {
     HTMLDocument *This = impl_from_IHTMLDocument5(iface);
+    compat_mode_t compat_mode = dispex_compat_mode(&This->doc_node->node.event_target.dispex);
+    nsIDOMAttr *nsattr = NULL;
     HTMLDOMAttribute *attr;
+    nsresult nsres;
+    nsAString str;
     HRESULT hres;
 
     TRACE("(%p)->(%s %p)\n", This, debugstr_w(bstrattrName), ppattribute);
 
-    hres = HTMLDOMAttribute_Create(bstrattrName, NULL, 0, dispex_compat_mode(&This->doc_node->node.event_target.dispex), &attr);
+    if(compat_mode >= COMPAT_MODE_IE9) {
+        nsAString_InitDepend(&str, bstrattrName);
+        nsres = nsIDOMDocument_CreateAttribute(This->doc_node->nsdoc, &str, &nsattr);
+        nsAString_Finish(&str);
+        if(NS_FAILED(nsres)) {
+            ERR("CreateAttribute failed: %08lx\n", nsres);
+            return E_FAIL;
+        }
+    }
+
+    hres = HTMLDOMAttribute_Create(bstrattrName, This->doc_node, NULL, 0, nsattr, compat_mode, &attr);
+    if(nsattr)
+        nsIDOMAttr_Release(nsattr);
     if(FAILED(hres))
         return hres;
 
@@ -2877,7 +3043,7 @@ static HRESULT WINAPI HTMLDocument5_createComment(IHTMLDocument5 *iface, BSTR bs
     }
 
     nsAString_InitDepend(&str, bstrdata);
-    nsres = nsIDOMHTMLDocument_CreateComment(This->doc_node->nsdoc, &str, &nscomment);
+    nsres = nsIDOMDocument_CreateComment(This->doc_node->nsdoc, &str, &nscomment);
     nsAString_Finish(&str);
     if(NS_FAILED(nsres)) {
         ERR("CreateTextNode failed: %08lx\n", nsres);
@@ -3155,7 +3321,7 @@ static HRESULT WINAPI HTMLDocument6_getElementById(IHTMLDocument6 *iface,
     }
 
     nsAString_InitDepend(&nsstr, bstrId);
-    nsres = nsIDOMHTMLDocument_GetElementById(This->doc_node->nsdoc, &nsstr, &nselem);
+    nsres = nsIDOMDocument_GetElementById(This->doc_node->nsdoc, &nsstr, &nselem);
     nsAString_Finish(&nsstr);
     if(NS_FAILED(nsres)) {
         ERR("GetElementById failed: %08lx\n", nsres);
@@ -3312,7 +3478,7 @@ static HRESULT WINAPI HTMLDocument7_createElementNS(IHTMLDocument7 *iface, VARIA
 
     nsAString_InitDepend(&ns, pvarNS && V_VT(pvarNS) == VT_BSTR ? V_BSTR(pvarNS) : NULL);
     nsAString_InitDepend(&tag, bstrTag);
-    nsres = nsIDOMHTMLDocument_CreateElementNS(This->doc_node->nsdoc, &ns, &tag, &dom_element);
+    nsres = nsIDOMDocument_CreateElementNS(This->doc_node->nsdoc, &ns, &tag, &dom_element);
     nsAString_Finish(&ns);
     nsAString_Finish(&tag);
     if(NS_FAILED(nsres)) {
@@ -3367,7 +3533,7 @@ static HRESULT WINAPI HTMLDocument7_get_characterSet(IHTMLDocument7 *iface, BSTR
     }
 
     nsAString_Init(&charset_str, NULL);
-    nsres = nsIDOMHTMLDocument_GetCharacterSet(This->doc_node->nsdoc, &charset_str);
+    nsres = nsIDOMDocument_GetCharacterSet(This->doc_node->nsdoc, &charset_str);
     return return_nsstr(nsres, &charset_str, p);
 }
 
@@ -3404,7 +3570,7 @@ static HRESULT WINAPI HTMLDocument7_getElementsByClassName(IHTMLDocument7 *iface
     }
 
     nsAString_InitDepend(&nsstr, v);
-    nsres = nsIDOMHTMLDocument_GetElementsByClassName(This->doc_node->nsdoc, &nsstr, &nslist);
+    nsres = nsIDOMDocument_GetElementsByClassName(This->doc_node->nsdoc, &nsstr, &nslist);
     nsAString_Finish(&nsstr);
     if(FAILED(nsres)) {
         ERR("GetElementByClassName failed: %08lx\n", nsres);
@@ -3412,7 +3578,7 @@ static HRESULT WINAPI HTMLDocument7_getElementsByClassName(IHTMLDocument7 *iface
     }
 
 
-    *pel = create_collection_from_nodelist(nslist, This->doc_node->document_mode);
+    *pel = create_collection_from_nodelist(nslist, This->doc_node);
     nsIDOMNodeList_Release(nslist);
     return S_OK;
 }
@@ -4073,8 +4239,41 @@ static HRESULT WINAPI HTMLDocument7_importNode(IHTMLDocument7 *iface, IHTMLDOMNo
         VARIANT_BOOL fDeep, IHTMLDOMNode3 **ppNodeDest)
 {
     HTMLDocument *This = impl_from_IHTMLDocument7(iface);
-    FIXME("(%p)->(%p %x %p)\n", This, pNodeSource, fDeep, ppNodeDest);
-    return E_NOTIMPL;
+    nsIDOMNode *nsnode;
+    HTMLDOMNode *node;
+    nsresult nsres;
+    HRESULT hres;
+
+    TRACE("(%p)->(%p %x %p)\n", This, pNodeSource, fDeep, ppNodeDest);
+
+    if(!This->doc_node->nsdoc) {
+        WARN("NULL nsdoc\n");
+        return E_UNEXPECTED;
+    }
+
+    if(!(node = unsafe_impl_from_IHTMLDOMNode(pNodeSource))) {
+        ERR("not our node\n");
+        return E_FAIL;
+    }
+
+    nsres = nsIDOMDocument_ImportNode(This->doc_node->nsdoc, node->nsnode, !!fDeep, 1, &nsnode);
+    if(NS_FAILED(nsres)) {
+        ERR("ImportNode failed: %08lx\n", nsres);
+        return map_nsresult(nsres);
+    }
+
+    if(!nsnode) {
+        *ppNodeDest = NULL;
+        return S_OK;
+    }
+
+    hres = get_node(nsnode, TRUE, &node);
+    nsIDOMNode_Release(nsnode);
+    if(FAILED(hres))
+        return hres;
+
+    *ppNodeDest = &node->IHTMLDOMNode3_iface;
+    return hres;
 }
 
 static HRESULT WINAPI HTMLDocument7_get_parentWindow(IHTMLDocument7 *iface, IHTMLWindow2 **p)
@@ -4118,7 +4317,12 @@ static HRESULT WINAPI HTMLDocument7_get_head(IHTMLDocument7 *iface, IHTMLElement
         return E_FAIL;
     }
 
-    nsres = nsIDOMHTMLDocument_GetHead(This->doc_node->nsdoc, &nshead);
+    if(!This->doc_node->nshtmldoc) {
+        FIXME("Not implemented for XML document\n");
+        return E_NOTIMPL;
+    }
+
+    nsres = nsIDOMHTMLDocument_GetHead(This->doc_node->nshtmldoc, &nshead);
     assert(nsres == NS_OK);
 
     if(!nshead) {
@@ -4317,7 +4521,7 @@ static HRESULT WINAPI DocumentSelector_querySelector(IDocumentSelector *iface, B
     TRACE("(%p)->(%s %p)\n", This, debugstr_w(v), pel);
 
     nsAString_InitDepend(&nsstr, v);
-    nsres = nsIDOMHTMLDocument_QuerySelector(This->doc_node->nsdoc, &nsstr, &nselem);
+    nsres = nsIDOMDocument_QuerySelector(This->doc_node->nsdoc, &nsstr, &nselem);
     nsAString_Finish(&nsstr);
     if(NS_FAILED(nsres)) {
         ERR("QuerySelector failed: %08lx\n", nsres);
@@ -4348,14 +4552,14 @@ static HRESULT WINAPI DocumentSelector_querySelectorAll(IDocumentSelector *iface
     TRACE("(%p)->(%s %p)\n", This, debugstr_w(v), pel);
 
     nsAString_InitDepend(&nsstr, v);
-    hres = map_nsresult(nsIDOMHTMLDocument_QuerySelectorAll(This->doc_node->nsdoc, &nsstr, &node_list));
+    hres = map_nsresult(nsIDOMDocument_QuerySelectorAll(This->doc_node->nsdoc, &nsstr, &node_list));
     nsAString_Finish(&nsstr);
     if(FAILED(hres)) {
         ERR("QuerySelectorAll failed: %08lx\n", hres);
         return hres;
     }
 
-    hres = create_child_collection(node_list, dispex_compat_mode(&This->doc_node->node.event_target.dispex), pel);
+    hres = create_child_collection(node_list, This->doc_node, pel);
     nsIDOMNodeList_Release(node_list);
     return hres;
 }
@@ -4501,11 +4705,11 @@ static HRESULT dispid_from_elem_name(HTMLDocumentNode *This, BSTR name, DISPID *
     unsigned i;
     nsresult nsres;
 
-    if(!This->nsdoc)
+    if(!This->nshtmldoc)
         return DISP_E_UNKNOWNNAME;
 
     nsAString_InitDepend(&name_str, name);
-    nsres = nsIDOMHTMLDocument_GetElementsByName(This->nsdoc, &name_str, &node_list);
+    nsres = nsIDOMHTMLDocument_GetElementsByName(This->nshtmldoc, &name_str, &node_list);
     nsAString_Finish(&name_str);
     if(NS_FAILED(nsres))
         return E_FAIL;
@@ -4551,6 +4755,28 @@ static HRESULT dispid_from_elem_name(HTMLDocumentNode *This, BSTR name, DISPID *
     return S_OK;
 }
 
+static HRESULT document_invoke(HTMLDocument *doc, IDispatch *this_obj, DISPID id, LCID lcid, WORD wFlags,
+        DISPPARAMS *pdp, VARIANT *res, EXCEPINFO *pei, IServiceProvider *caller)
+{
+    if(doc->window) {
+        switch(id) {
+        case DISPID_READYSTATE:
+            TRACE("DISPID_READYSTATE\n");
+
+            if(!(wFlags & DISPATCH_PROPERTYGET))
+                return E_INVALIDARG;
+
+            V_VT(res) = VT_I4;
+            V_I4(res) = doc->window->readystate;
+            return S_OK;
+        default:
+            break;
+        }
+    }
+
+    return dispex_invoke(doc->dispex, this_obj, id, lcid, wFlags, pdp, res, pei, caller);
+}
+
 static HRESULT WINAPI DocDispatchEx_QueryInterface(IDispatchEx *iface, REFIID riid, void **ppv)
 {
     HTMLDocument *This = impl_from_IDispatchEx(iface);
@@ -4576,7 +4802,7 @@ static HRESULT WINAPI DocDispatchEx_GetTypeInfoCount(IDispatchEx *iface, UINT *p
 {
     HTMLDocument *This = impl_from_IDispatchEx(iface);
 
-    return IDispatchEx_GetTypeInfoCount(This->dispex, pctinfo);
+    return IDispatchEx_GetTypeInfoCount(&This->dispex->IDispatchEx_iface, pctinfo);
 }
 
 static HRESULT WINAPI DocDispatchEx_GetTypeInfo(IDispatchEx *iface, UINT iTInfo,
@@ -4584,7 +4810,7 @@ static HRESULT WINAPI DocDispatchEx_GetTypeInfo(IDispatchEx *iface, UINT iTInfo,
 {
     HTMLDocument *This = impl_from_IDispatchEx(iface);
 
-    return IDispatchEx_GetTypeInfo(This->dispex, iTInfo, lcid, ppTInfo);
+    return IDispatchEx_GetTypeInfo(&This->dispex->IDispatchEx_iface, iTInfo, lcid, ppTInfo);
 }
 
 static HRESULT WINAPI DocDispatchEx_GetIDsOfNames(IDispatchEx *iface, REFIID riid,
@@ -4592,8 +4818,12 @@ static HRESULT WINAPI DocDispatchEx_GetIDsOfNames(IDispatchEx *iface, REFIID rii
                                                  LCID lcid, DISPID *rgDispId)
 {
     HTMLDocument *This = impl_from_IDispatchEx(iface);
+    IWineDispatchProxyCbPrivate *proxy = This->dispex->proxy;
+
+    if(proxy)
+        return IDispatchEx_GetIDsOfNames((IDispatchEx*)proxy, riid, rgszNames, cNames, lcid, rgDispId);
 
-    return IDispatchEx_GetIDsOfNames(This->dispex, riid, rgszNames, cNames, lcid, rgDispId);
+    return IDispatchEx_GetIDsOfNames(&This->dispex->IDispatchEx_iface, riid, rgszNames, cNames, lcid, rgDispId);
 }
 
 static HRESULT WINAPI DocDispatchEx_Invoke(IDispatchEx *iface, DISPID dispIdMember,
@@ -4601,32 +4831,29 @@ static HRESULT WINAPI DocDispatchEx_Invoke(IDispatchEx *iface, DISPID dispIdMemb
                             VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
 {
     HTMLDocument *This = impl_from_IDispatchEx(iface);
+    IWineDispatchProxyCbPrivate *proxy = This->dispex->proxy;
+
+    if(proxy)
+        return IDispatchEx_Invoke((IDispatchEx*)proxy, dispIdMember, riid, lcid, wFlags,
+                                  pDispParams, pVarResult, pExcepInfo, puArgErr);
 
     TRACE("(%p)->(%ld %s %ld %d %p %p %p %p)\n", This, dispIdMember, debugstr_guid(riid),
           lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
 
-    switch(dispIdMember) {
-    case DISPID_READYSTATE:
-        TRACE("DISPID_READYSTATE\n");
-
-        if(!(wFlags & DISPATCH_PROPERTYGET))
-            return E_INVALIDARG;
-
-        V_VT(pVarResult) = VT_I4;
-        V_I4(pVarResult) = This->window->readystate;
-        return S_OK;
-    }
-
-    return IDispatchEx_Invoke(This->dispex, dispIdMember, riid, lcid, wFlags, pDispParams,
-                              pVarResult, pExcepInfo, puArgErr);
+    return document_invoke(This, (IDispatch*)&This->IHTMLDocument2_iface, dispIdMember, lcid, wFlags,
+                           pDispParams, pVarResult, pExcepInfo, NULL);
 }
 
 static HRESULT WINAPI DocDispatchEx_GetDispID(IDispatchEx *iface, BSTR bstrName, DWORD grfdex, DISPID *pid)
 {
     HTMLDocument *This = impl_from_IDispatchEx(iface);
+    IWineDispatchProxyCbPrivate *proxy = This->dispex->proxy;
     HRESULT hres;
 
-    hres = IDispatchEx_GetDispID(This->dispex, bstrName, grfdex, pid);
+    if(proxy)
+        return IDispatchEx_GetDispID((IDispatchEx*)proxy, bstrName, grfdex, pid);
+
+    hres = IDispatchEx_GetDispID(&This->dispex->IDispatchEx_iface, bstrName, grfdex, pid);
     if(hres != DISP_E_UNKNOWNNAME)
         return hres;
 
@@ -4637,58 +4864,183 @@ static HRESULT WINAPI DocDispatchEx_InvokeEx(IDispatchEx *iface, DISPID id, LCID
         VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
 {
     HTMLDocument *This = impl_from_IDispatchEx(iface);
+    IWineDispatchProxyCbPrivate *proxy = This->dispex->proxy;
 
-    if(This->window && id == DISPID_IHTMLDOCUMENT2_LOCATION && (wFlags & DISPATCH_PROPERTYPUT))
-        return IDispatchEx_InvokeEx(&This->window->base.IDispatchEx_iface, DISPID_IHTMLWINDOW2_LOCATION,
-                lcid, wFlags, pdp, pvarRes, pei, pspCaller);
-
+    if(proxy)
+        return IDispatchEx_InvokeEx((IDispatchEx*)proxy, id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
 
-    return IDispatchEx_InvokeEx(This->dispex, id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
+    return document_invoke(This, (IDispatch*)&This->IHTMLDocument2_iface, id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
 }
 
 static HRESULT WINAPI DocDispatchEx_DeleteMemberByName(IDispatchEx *iface, BSTR bstrName, DWORD grfdex)
 {
     HTMLDocument *This = impl_from_IDispatchEx(iface);
 
-    return IDispatchEx_DeleteMemberByName(This->dispex, bstrName, grfdex);
+    return IDispatchEx_DeleteMemberByName(&This->dispex->IDispatchEx_iface, bstrName, grfdex);
 }
 
 static HRESULT WINAPI DocDispatchEx_DeleteMemberByDispID(IDispatchEx *iface, DISPID id)
 {
     HTMLDocument *This = impl_from_IDispatchEx(iface);
 
-    return IDispatchEx_DeleteMemberByDispID(This->dispex, id);
+    return IDispatchEx_DeleteMemberByDispID(&This->dispex->IDispatchEx_iface, id);
 }
 
 static HRESULT WINAPI DocDispatchEx_GetMemberProperties(IDispatchEx *iface, DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
 {
     HTMLDocument *This = impl_from_IDispatchEx(iface);
 
-    return IDispatchEx_GetMemberProperties(This->dispex, id, grfdexFetch, pgrfdex);
+    return IDispatchEx_GetMemberProperties(&This->dispex->IDispatchEx_iface, id, grfdexFetch, pgrfdex);
 }
 
 static HRESULT WINAPI DocDispatchEx_GetMemberName(IDispatchEx *iface, DISPID id, BSTR *pbstrName)
 {
     HTMLDocument *This = impl_from_IDispatchEx(iface);
 
-    return IDispatchEx_GetMemberName(This->dispex, id, pbstrName);
+    return IDispatchEx_GetMemberName(&This->dispex->IDispatchEx_iface, id, pbstrName);
 }
 
 static HRESULT WINAPI DocDispatchEx_GetNextDispID(IDispatchEx *iface, DWORD grfdex, DISPID id, DISPID *pid)
 {
     HTMLDocument *This = impl_from_IDispatchEx(iface);
 
-    return IDispatchEx_GetNextDispID(This->dispex, grfdex, id, pid);
+    return IDispatchEx_GetNextDispID(&This->dispex->IDispatchEx_iface, grfdex, id, pid);
 }
 
 static HRESULT WINAPI DocDispatchEx_GetNameSpaceParent(IDispatchEx *iface, IUnknown **ppunk)
 {
     HTMLDocument *This = impl_from_IDispatchEx(iface);
 
-    return IDispatchEx_GetNameSpaceParent(This->dispex, ppunk);
+    return IDispatchEx_GetNameSpaceParent(&This->dispex->IDispatchEx_iface, ppunk);
+}
+
+static inline HTMLDocument *impl_from_IWineDispatchProxyPrivate(IWineDispatchProxyPrivate *iface)
+{
+    return impl_from_IDispatchEx((IDispatchEx*)iface);
+}
+
+static IWineDispatchProxyCbPrivate** WINAPI DocWineDispProxyPrivate_GetProxyFieldRef(IWineDispatchProxyPrivate *iface)
+{
+    HTMLDocument *This = impl_from_IWineDispatchProxyPrivate(iface);
+    return &This->dispex->proxy;
 }
 
-static const IDispatchExVtbl DocDispatchExVtbl = {
+static IDispatch* WINAPI DocWineDispProxyPrivate_GetDefaultPrototype(IWineDispatchProxyPrivate *iface, struct proxy_prototypes **prots_ref)
+{
+    HTMLDocument *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->dispex->IDispatchEx_iface;
+
+    return itf->lpVtbl->GetDefaultPrototype(itf, prots_ref);
+}
+
+static IDispatch* WINAPI DocWineDispProxyPrivate_GetDefaultConstructor(IWineDispatchProxyPrivate *iface, struct proxy_prototypes *prots)
+{
+    HTMLDocument *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->dispex->IDispatchEx_iface;
+
+    return itf->lpVtbl->GetDefaultConstructor(itf, prots);
+}
+
+static HRESULT WINAPI DocWineDispProxyPrivate_DefineConstructors(IWineDispatchProxyPrivate *iface, struct proxy_prototypes **prots_ref)
+{
+    HTMLDocument *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->dispex->IDispatchEx_iface;
+
+    return itf->lpVtbl->DefineConstructors(itf, prots_ref);
+}
+
+static BOOL WINAPI DocWineDispProxyPrivate_IsPrototype(IWineDispatchProxyPrivate *iface)
+{
+    HTMLDocument *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->dispex->IDispatchEx_iface;
+
+    return itf->lpVtbl->IsPrototype(itf);
+}
+
+static BOOL WINAPI DocWineDispProxyPrivate_IsConstructor(IWineDispatchProxyPrivate *iface)
+{
+    HTMLDocument *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->dispex->IDispatchEx_iface;
+
+    return itf->lpVtbl->IsConstructor(itf);
+}
+
+static DWORD WINAPI DocWineDispProxyPrivate_PropFlags(IWineDispatchProxyPrivate *iface, DISPID id)
+{
+    HTMLDocument *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->dispex->IDispatchEx_iface;
+
+    if(This->window && id == DISPID_IHTMLDOCUMENT2_LOCATION)
+        return PROPF_PROXY_ACCESSOR | PROPF_WRITABLE | PROPF_ENUMERABLE;
+
+    return itf->lpVtbl->PropFlags(itf, id);
+}
+
+static HRESULT WINAPI DocWineDispProxyPrivate_PropGetID(IWineDispatchProxyPrivate *iface, WCHAR *name, DISPID *id)
+{
+    HTMLDocument *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->dispex->IDispatchEx_iface;
+    HRESULT hres;
+
+    hres = itf->lpVtbl->PropGetID(itf, name, id);
+    if(hres != DISP_E_UNKNOWNNAME)
+        return hres;
+
+    return dispid_from_elem_name(This->doc_node, name, id);
+}
+
+static HRESULT WINAPI DocWineDispProxyPrivate_PropInvoke(IWineDispatchProxyPrivate *iface, IDispatch *this_obj, DISPID id,
+        LCID lcid, DWORD flags, DISPPARAMS *dp, VARIANT *ret, EXCEPINFO *ei, IServiceProvider *caller)
+{
+    HTMLDocument *This = impl_from_IWineDispatchProxyPrivate(iface);
+
+    return document_invoke(This, this_obj, id, lcid, flags, dp, ret, ei, caller);
+}
+
+static HRESULT WINAPI DocWineDispProxyPrivate_PropDelete(IWineDispatchProxyPrivate *iface, DISPID id)
+{
+    HTMLDocument *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->dispex->IDispatchEx_iface;
+
+    return itf->lpVtbl->PropDelete(itf, id);
+}
+
+static HRESULT WINAPI DocWineDispProxyPrivate_FuncInfo(IWineDispatchProxyPrivate *iface, DISPID id, struct proxy_func_invoker *ret)
+{
+    HTMLDocument *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->dispex->IDispatchEx_iface;
+
+    return itf->lpVtbl->FuncInfo(itf, id, ret);
+}
+
+static HRESULT WINAPI DocWineDispProxyPrivate_AccessorInfo(IWineDispatchProxyPrivate *iface, DISPID id, struct proxy_func_invoker *ret)
+{
+    HTMLDocument *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->dispex->IDispatchEx_iface;
+
+    return itf->lpVtbl->AccessorInfo(itf, id, ret);
+}
+
+static HRESULT WINAPI DocWineDispProxyPrivate_ToString(IWineDispatchProxyPrivate *iface, BSTR *string)
+{
+    HTMLDocument *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->dispex->IDispatchEx_iface;
+
+    return itf->lpVtbl->ToString(itf, string);
+}
+
+static BOOL WINAPI DocWineDispProxyPrivate_CanGC(IWineDispatchProxyPrivate *iface)
+{
+    HTMLDocument *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IUnknown *outer = This->outer_unk;
+
+    /* Allow garbage collection only if the proxy is the only one holding a ref to us */
+    IUnknown_AddRef(outer);
+    return IUnknown_Release(outer) == 1;
+}
+
+static const IWineDispatchProxyPrivateVtbl DocDispatchExVtbl = {
+    {
     DocDispatchEx_QueryInterface,
     DocDispatchEx_AddRef,
     DocDispatchEx_Release,
@@ -4704,6 +5056,23 @@ static const IDispatchExVtbl DocDispatchExVtbl = {
     DocDispatchEx_GetMemberName,
     DocDispatchEx_GetNextDispID,
     DocDispatchEx_GetNameSpaceParent
+    },
+
+    /* IWineDispatchProxyPrivate extension */
+    DocWineDispProxyPrivate_GetProxyFieldRef,
+    DocWineDispProxyPrivate_GetDefaultPrototype,
+    DocWineDispProxyPrivate_GetDefaultConstructor,
+    DocWineDispProxyPrivate_DefineConstructors,
+    DocWineDispProxyPrivate_IsPrototype,
+    DocWineDispProxyPrivate_IsConstructor,
+    DocWineDispProxyPrivate_PropFlags,
+    DocWineDispProxyPrivate_PropGetID,
+    DocWineDispProxyPrivate_PropInvoke,
+    DocWineDispProxyPrivate_PropDelete,
+    DocWineDispProxyPrivate_FuncInfo,
+    DocWineDispProxyPrivate_AccessorInfo,
+    DocWineDispProxyPrivate_ToString,
+    DocWineDispProxyPrivate_CanGC
 };
 
 static inline HTMLDocument *impl_from_IProvideMultipleClassInfo(IProvideMultipleClassInfo *iface)
@@ -5191,7 +5560,7 @@ static HRESULT WINAPI DocumentRange_createRange(IDocumentRange *iface, IHTMLDOMR
         return E_UNEXPECTED;
     }
 
-    if(NS_FAILED(nsIDOMHTMLDocument_CreateRange(This->doc_node->nsdoc, &nsrange)))
+    if(NS_FAILED(nsIDOMDocument_CreateRange(This->doc_node->nsdoc, &nsrange)))
         return E_FAIL;
 
     hres = create_dom_range(nsrange, dispex_compat_mode(&This->doc_node->node.event_target.dispex), p);
@@ -5220,6 +5589,8 @@ static BOOL htmldoc_qi(HTMLDocument *This, REFIID riid, void **ppv)
         *ppv = &This->IDispatchEx_iface;
     else if(IsEqualGUID(&IID_IDispatchEx, riid))
         *ppv = &This->IDispatchEx_iface;
+    else if(IsEqualGUID(&IID_IWineDispatchProxyPrivate, riid))
+        *ppv = &This->IDispatchEx_iface;
     else if(IsEqualGUID(&IID_IHTMLDocument, riid))
         *ppv = &This->IHTMLDocument2_iface;
     else if(IsEqualGUID(&IID_IHTMLDocument2, riid))
@@ -5331,7 +5702,7 @@ static const cpc_entry_t HTMLDocument_cpc[] = {
     {NULL}
 };
 
-static void init_doc(HTMLDocument *doc, IUnknown *outer, IDispatchEx *dispex)
+static void init_doc(HTMLDocument *doc, IUnknown *outer, DispatchEx *dispex)
 {
     doc->IHTMLDocument2_iface.lpVtbl = &HTMLDocumentVtbl;
     doc->IHTMLDocument3_iface.lpVtbl = &HTMLDocument3Vtbl;
@@ -5339,7 +5710,7 @@ static void init_doc(HTMLDocument *doc, IUnknown *outer, IDispatchEx *dispex)
     doc->IHTMLDocument5_iface.lpVtbl = &HTMLDocument5Vtbl;
     doc->IHTMLDocument6_iface.lpVtbl = &HTMLDocument6Vtbl;
     doc->IHTMLDocument7_iface.lpVtbl = &HTMLDocument7Vtbl;
-    doc->IDispatchEx_iface.lpVtbl = &DocDispatchExVtbl;
+    doc->IDispatchEx_iface.lpVtbl = (const IDispatchExVtbl*)&DocDispatchExVtbl;
     doc->IDocumentSelector_iface.lpVtbl = &DocumentSelectorVtbl;
     doc->IDocumentEvent_iface.lpVtbl = &DocumentEventVtbl;
     doc->ISupportErrorInfo_iface.lpVtbl = &SupportErrorInfoVtbl;
@@ -5458,12 +5829,13 @@ static void HTMLDocumentNode_unlink(HTMLDOMNode *iface)
     HTMLDocumentNode *This = impl_from_HTMLDOMNode(iface);
 
     if(This->nsdoc) {
-        nsIDOMHTMLDocument *nsdoc = This->nsdoc;
+        nsIDOMDocument *nsdoc = This->nsdoc;
 
         release_document_mutation(This);
         detach_document_node(This);
         This->nsdoc = NULL;
-        nsIDOMHTMLDocument_Release(nsdoc);
+        This->nshtmldoc = NULL;
+        nsIDOMDocument_Release(nsdoc);
         This->window = NULL;
     }
 }
@@ -5507,8 +5879,8 @@ static inline HTMLDocumentNode *impl_from_DispatchEx(DispatchEx *iface)
     return CONTAINING_RECORD(iface, HTMLDocumentNode, node.event_target.dispex);
 }
 
-static HRESULT HTMLDocumentNode_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
-        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+static HRESULT HTMLDocumentNode_invoke(DispatchEx *dispex, IDispatch *this_obj, DISPID id, LCID lcid, WORD flags,
+        DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
     HTMLDocumentNode *This = impl_from_DispatchEx(dispex);
     nsIDOMNodeList *node_list;
@@ -5526,11 +5898,11 @@ static HRESULT HTMLDocumentNode_invoke(DispatchEx *dispex, DISPID id, LCID lcid,
 
     i = id - MSHTML_DISPID_CUSTOM_MIN;
 
-    if(!This->nsdoc || i >= This->elem_vars_cnt)
+    if(!This->nshtmldoc || i >= This->elem_vars_cnt)
         return DISP_E_UNKNOWNNAME;
 
     nsAString_InitDepend(&name_str, This->elem_vars[i]);
-    nsres = nsIDOMHTMLDocument_GetElementsByName(This->nsdoc, &name_str, &node_list);
+    nsres = nsIDOMHTMLDocument_GetElementsByName(This->nshtmldoc, &name_str, &node_list);
     nsAString_Finish(&name_str);
     if(NS_FAILED(nsres))
         return E_FAIL;
@@ -5594,11 +5966,19 @@ static IHTMLEventObj *HTMLDocumentNode_set_current_event(DispatchEx *dispex, IHT
     return default_set_current_event(This->window, event);
 }
 
+static HRESULT HTMLDocumentNode_location_hook(DispatchEx *dispex, WORD flags, DISPPARAMS *dp, VARIANT *res,
+        EXCEPINFO *ei, IServiceProvider *caller)
+{
+    return IHTMLDocument2_location_hook(&impl_from_DispatchEx(dispex)->basedoc, flags, dp, res, ei, caller);
+}
+
 static const event_target_vtbl_t HTMLDocumentNode_event_target_vtbl = {
     {
         NULL,
         NULL,
         HTMLDocumentNode_invoke,
+        NULL,
+        NULL,
         HTMLDocumentNode_get_compat_mode,
         NULL
     },
@@ -5621,7 +6001,6 @@ static const NodeImplVtbl HTMLDocumentFragmentImplVtbl = {
 static const tid_t HTMLDocumentNode_iface_tids[] = {
     IHTMLDOMNode_tid,
     IHTMLDOMNode2_tid,
-    IHTMLDocument2_tid,
     IHTMLDocument4_tid,
     IHTMLDocument5_tid,
     IDocumentSelector_tid,
@@ -5630,6 +6009,11 @@ static const tid_t HTMLDocumentNode_iface_tids[] = {
 
 static void HTMLDocumentNode_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
 {
+    static const dispex_hook_t document2_hooks[] = {
+        {DISPID_IHTMLDOCUMENT2_LOCATION, HTMLDocumentNode_location_hook},
+        {DISPID_UNKNOWN}
+    };
+
     HTMLDOMNode_init_dispex_info(info, mode);
 
     if(mode >= COMPAT_MODE_IE9) {
@@ -5646,11 +6030,31 @@ static void HTMLDocumentNode_init_dispex_info(dispex_data_t *info, compat_mode_t
         dispex_info_add_interface(info, IHTMLDocument6_tid, NULL);
         dispex_info_add_interface(info, IHTMLDocument3_tid, NULL);
     }
+    dispex_info_add_interface(info, IHTMLDocument2_tid, document2_hooks);
 }
 
-static dispex_static_data_t HTMLDocumentNode_dispex = {
+dispex_static_data_t HTMLDocumentNode_dispex = {
     L"HTMLDocument",
     &HTMLDocumentNode_event_target_vtbl.dispex_vtbl,
+    PROTO_ID_HTMLDocument,
+    DispHTMLDocument_tid,
+    HTMLDocumentNode_iface_tids,
+    HTMLDocumentNode_init_dispex_info
+};
+
+dispex_static_data_t XMLDocumentNode_dispex = {
+    L"XMLDocument",
+    &HTMLDocumentNode_event_target_vtbl.dispex_vtbl,
+    PROTO_ID_XMLDocument,
+    DispHTMLDocument_tid,
+    HTMLDocumentNode_iface_tids,
+    HTMLDocumentNode_init_dispex_info
+};
+
+dispex_static_data_t DocumentNode_dispex = {
+    L"Document",
+    &HTMLDocumentNode_event_target_vtbl.dispex_vtbl,
+    PROTO_ID_Document,
     DispHTMLDocument_tid,
     HTMLDocumentNode_iface_tids,
     HTMLDocumentNode_init_dispex_info
@@ -5671,7 +6075,7 @@ static HTMLDocumentNode *alloc_doc_node(HTMLDocumentObj *doc_obj, HTMLInnerWindo
     doc->window = window;
 
     init_doc(&doc->basedoc, (IUnknown*)&doc->node.IHTMLDOMNode_iface,
-            &doc->node.event_target.dispex.IDispatchEx_iface);
+             &doc->node.event_target.dispex);
     HTMLDocumentNode_SecMgr_Init(doc);
 
     list_init(&doc->selection_list);
@@ -5681,29 +6085,39 @@ static HTMLDocumentNode *alloc_doc_node(HTMLDocumentObj *doc_obj, HTMLInnerWindo
     return doc;
 }
 
-HRESULT create_document_node(nsIDOMHTMLDocument *nsdoc, GeckoBrowser *browser, HTMLInnerWindow *window,
-                             compat_mode_t parent_mode, HTMLDocumentNode **ret)
+HRESULT create_document_node(nsIDOMDocument *nsdoc, GeckoBrowser *browser, HTMLInnerWindow *window,
+                             document_type_t doc_type, compat_mode_t parent_mode, HTMLDocumentNode **ret)
 {
+    dispex_static_data_t *dispex_data = dispex_from_document_type[doc_type];
     HTMLDocumentObj *doc_obj = browser->doc;
     HTMLDocumentNode *doc;
 
     doc = alloc_doc_node(doc_obj, window);
     if(!doc)
         return E_OUTOFMEMORY;
+    doc->basedoc.doc_type = doc_type;
 
     if(parent_mode >= COMPAT_MODE_IE9) {
         TRACE("using parent mode %u\n", parent_mode);
         doc->document_mode = parent_mode;
         lock_document_mode(doc);
+
+        if(parent_mode < COMPAT_MODE_IE11)
+            dispex_data = &DocumentNode_dispex;
     }
 
     if(!doc_obj->basedoc.window || (window && is_main_content_window(window->base.outer_window)))
         doc->basedoc.cp_container.forward_container = &doc_obj->basedoc.cp_container;
 
-    HTMLDOMNode_Init(doc, &doc->node, (nsIDOMNode*)nsdoc, &HTMLDocumentNode_dispex);
+    if(NS_SUCCEEDED(nsIDOMDocument_QueryInterface(nsdoc, &IID_nsIDOMHTMLDocument, (void**)&doc->nshtmldoc)))
+        doc->nsdoc = (nsIDOMDocument*)doc->nshtmldoc;
+    else {
+        nsIDOMDocument_AddRef(nsdoc);
+        doc->nsdoc = nsdoc;
+        doc->nshtmldoc = NULL;
+    }
 
-    nsIDOMHTMLDocument_AddRef(nsdoc);
-    doc->nsdoc = nsdoc;
+    HTMLDOMNode_Init(doc, &doc->node, (nsIDOMNode*)doc->nsdoc, dispex_data);
 
     init_document_mutation(doc);
     doc_init_events(doc);
@@ -5713,12 +6127,12 @@ HRESULT create_document_node(nsIDOMHTMLDocument *nsdoc, GeckoBrowser *browser, H
     list_add_head(&browser->document_nodes, &doc->browser_entry);
     doc->browser = browser;
 
-    if(browser->usermode == EDITMODE) {
+    if(browser->usermode == EDITMODE && doc->nshtmldoc) {
         nsAString mode_str;
         nsresult nsres;
 
         nsAString_InitDepend(&mode_str, L"on");
-        nsres = nsIDOMHTMLDocument_SetDesignMode(doc->nsdoc, &mode_str);
+        nsres = nsIDOMHTMLDocument_SetDesignMode(doc->nshtmldoc, &mode_str);
         nsAString_Finish(&mode_str);
         if(NS_FAILED(nsres))
             ERR("SetDesignMode failed: %08lx\n", nsres);
@@ -5730,6 +6144,7 @@ HRESULT create_document_node(nsIDOMHTMLDocument *nsdoc, GeckoBrowser *browser, H
 
 static HRESULT create_document_fragment(nsIDOMNode *nsnode, HTMLDocumentNode *doc_node, HTMLDocumentNode **ret)
 {
+    dispex_static_data_t *dispex_data = dispex_from_document_type[doc_node->basedoc.doc_type];
     HTMLDocumentNode *doc_frag;
 
     doc_frag = alloc_doc_node(doc_node->basedoc.doc_obj, doc_node->window);
@@ -5738,7 +6153,10 @@ static HRESULT create_document_fragment(nsIDOMNode *nsnode, HTMLDocumentNode *do
 
     IHTMLWindow2_AddRef(&doc_frag->window->base.IHTMLWindow2_iface);
 
-    HTMLDOMNode_Init(doc_node, &doc_frag->node, nsnode, &HTMLDocumentNode_dispex);
+    if(COMPAT_MODE_IE9 <= doc_node->document_mode && doc_node->document_mode < COMPAT_MODE_IE11)
+        dispex_data = &DocumentNode_dispex;
+
+    HTMLDOMNode_Init(doc_node, &doc_frag->node, nsnode, dispex_data);
     doc_frag->node.vtbl = &HTMLDocumentFragmentImplVtbl;
     doc_frag->document_mode = lock_document_mode(doc_node);
 
@@ -5765,6 +6183,83 @@ HRESULT get_document_node(nsIDOMDocument *dom_document, HTMLDocumentNode **ret)
     return S_OK;
 }
 
+HRESULT create_xml_document(BSTR content, HTMLDocumentNode *doc_node, document_type_t doc_type,
+        BOOL use_htmldoc_iface, IDispatch **ret)
+{
+    IXMLDOMDocument *xmldoc;
+    IObjectSafety *safety;
+    VARIANT_BOOL vbool;
+    HRESULT hres;
+
+    if(use_htmldoc_iface) {
+        nsAString errns, errtag;
+        HTMLDocumentNode *doc;
+        nsIDOMDocument *nsdoc;
+        nsIDOMNodeList *nodes;
+        nsIDOMParser *parser;
+        nsresult nsres;
+
+        if(!(parser = create_nsdomparser(doc_node)))
+            return E_FAIL;
+        nsres = nsIDOMParser_ParseFromString(parser, content ? content : L"",
+                doc_type == DOCTYPE_SVG   ? "image/svg+xml" :
+                doc_type == DOCTYPE_XHTML ? "application/xhtml+xml" :
+                                            "text/xml", &nsdoc);
+        nsIDOMParser_Release(parser);
+        if(NS_FAILED(nsres)) {
+            ERR("ParseFromString failed: 0x%08lx\n", nsres);
+            return map_nsresult(nsres);
+        }
+
+        nsAString_InitDepend(&errns, L"http://www.mozilla.org/newlayout/xml/parsererror.xml");
+        nsAString_InitDepend(&errtag, L"parsererror");
+        nsres = nsIDOMDocument_GetElementsByTagNameNS(nsdoc, &errns, &errtag, &nodes);
+        nsAString_Finish(&errtag);
+        nsAString_Finish(&errns);
+        if(NS_SUCCEEDED(nsres)) {
+            UINT32 length;
+            nsres = nsIDOMNodeList_GetLength(nodes, &length);
+            nsIDOMNodeList_Release(nodes);
+            if(NS_SUCCEEDED(nsres) && length) {
+                nsIDOMDocument_Release(nsdoc);
+                return MSHTML_E_SYNTAX;
+            }
+        }
+
+        hres = create_document_node(nsdoc, doc_node->browser, NULL, doc_type, doc_node->document_mode, &doc);
+        /* FIXME HACK: in FFXIV launcher, cycle collector crashes due to some bad refcount somewhere (gecko bug?) */
+        /* nsIDOMDocument_Release(nsdoc); */
+        if(FAILED(hres))
+            return hres;
+
+        *ret = (IDispatch*)&doc->basedoc.IHTMLDocument2_iface;
+        return S_OK;
+    }
+
+    hres = CoCreateInstance(&CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, &IID_IXMLDOMDocument, (void**)&xmldoc);
+    if(FAILED(hres)) {
+        ERR("CoCreateInstance failed: %08lx\n", hres);
+        return hres;
+    }
+
+    if(content) {
+        hres = IXMLDOMDocument_loadXML(xmldoc, content, &vbool);
+        if(hres != S_OK || vbool != VARIANT_TRUE)
+            WARN("loadXML failed: %08lx, returning an empty xmldoc\n", hres);
+    }
+
+    hres = IXMLDOMDocument_QueryInterface(xmldoc, &IID_IObjectSafety, (void**)&safety);
+    if(SUCCEEDED(hres)) {
+        IObjectSafety_SetInterfaceSafetyOptions(safety, NULL,
+            INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA | INTERFACE_USES_SECURITY_MANAGER,
+            INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA | INTERFACE_USES_SECURITY_MANAGER);
+        IObjectSafety_Release(safety);
+    }
+
+    *ret = (IDispatch*)xmldoc;
+    return S_OK;
+}
+
 static inline HTMLDocumentObj *impl_from_IUnknown(IUnknown *iface)
 {
     return CONTAINING_RECORD(iface, HTMLDocumentObj, IUnknown_inner);
@@ -5937,30 +6432,128 @@ static const ICustomDocVtbl CustomDocVtbl = {
     CustomDoc_SetUIHandler
 };
 
+static HRESULT HTMLDocumentObj_location_hook(DispatchEx *dispex, WORD flags, DISPPARAMS *dp, VARIANT *res,
+        EXCEPINFO *ei, IServiceProvider *caller)
+{
+    return IHTMLDocument2_location_hook(&CONTAINING_RECORD(dispex, HTMLDocumentObj, dispex)->basedoc, flags, dp, res, ei, caller);
+}
+
 static const tid_t HTMLDocumentObj_iface_tids[] = {
-    IHTMLDocument2_tid,
     IHTMLDocument3_tid,
     IHTMLDocument4_tid,
     IHTMLDocument5_tid,
     0
 };
+
+static void HTMLDocumentObj_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
+{
+    static const dispex_hook_t document2_hooks[] = {
+        {DISPID_IHTMLDOCUMENT2_LOCATION, HTMLDocumentObj_location_hook},
+        {DISPID_UNKNOWN}
+    };
+    dispex_info_add_interface(info, IHTMLDocument2_tid, document2_hooks);
+}
+
 static dispex_static_data_t HTMLDocumentObj_dispex = {
     L"HTMLDocumentObj",
     NULL,
+    PROTO_ID_NULL,
     DispHTMLDocument_tid,
-    HTMLDocumentObj_iface_tids
+    HTMLDocumentObj_iface_tids,
+    HTMLDocumentObj_init_dispex_info
 };
 
+/* TRUE if we create a dedicated thread for all HTML documents */
+static BOOL gecko_main_thread_config;
+
+static LONG gecko_main_thread;
+static HWND gecko_main_thread_hwnd;
+static HANDLE gecko_main_thread_event;
+
+static DWORD WINAPI gecko_main_thread_proc(void *arg)
+{
+    MSG msg;
+
+    TRACE("\n");
+
+    CoInitialize(NULL);
+
+    gecko_main_thread_hwnd = get_thread_hwnd();
+    if(!gecko_main_thread_hwnd) {
+        ERR("Could not create thread window\n");
+        SetEvent(gecko_main_thread_event);
+        CoUninitialize();
+        return 0;
+    }
+
+    gecko_main_thread = GetCurrentThreadId();
+    SetEvent(gecko_main_thread_event);
+
+    while(GetMessageW(&msg, NULL, 0, 0)) {
+        DispatchMessageW(&msg);
+        TranslateMessage(&msg);
+    }
+
+    CoUninitialize();
+    return 0;
+}
+
+static BOOL WINAPI read_thread_config(INIT_ONCE *once, void *param, void **context)
+{
+    char str[64];
+
+    if((GetEnvironmentVariableA("SteamGameId", str, sizeof(str)) && (!strcmp(str, "491540") || !strcmp(str,"47890")))
+            || (GetEnvironmentVariableA("WINE_GECKO_MAIN_THREAD", str, sizeof(str)) && *str != '0'))
+    {
+        FIXME("HACK: Using separated main thread.\n");
+        gecko_main_thread_config = TRUE;
+    }
+
+    return TRUE;
+}
+
 static HRESULT create_document_object(BOOL is_mhtml, IUnknown *outer, REFIID riid, void **ppv)
 {
     HTMLDocumentObj *doc;
     HRESULT hres;
 
+    static INIT_ONCE init_once = INIT_ONCE_STATIC_INIT;
+
     if(outer && !IsEqualGUID(&IID_IUnknown, riid)) {
         *ppv = NULL;
         return E_INVALIDARG;
     }
 
+    /* CXHACK 15579 */
+    InitOnceExecuteOnce(&init_once, read_thread_config, NULL, NULL);
+    if(gecko_main_thread_config && !gecko_main_thread) {
+        HANDLE thread, event;
+
+        event = CreateEventW(NULL, TRUE, FALSE, NULL);
+        if(InterlockedCompareExchangePointer(&gecko_main_thread_event, event, NULL))
+            CloseHandle(event);
+
+        thread = CreateThread(NULL, 0, gecko_main_thread_proc, NULL, 0, NULL);
+        if(thread) {
+            WaitForSingleObject(gecko_main_thread_event, INFINITE);
+            CloseHandle(thread);
+        }else {
+            ERR("Could not create a thread\n");
+        }
+    }
+
+    if(!gecko_main_thread) {
+        gecko_main_thread = GetCurrentThreadId();
+        gecko_main_thread_hwnd = get_thread_hwnd();
+    }else if(GetCurrentThreadId() != gecko_main_thread) {
+        FIXME("HACK: Creating HTMLDocument outside Gecko main thread\n");
+        if(!gecko_main_thread_config) {
+            FIXME("HACK: Dedicated main thread not configured\n");
+            FIXME("HACK: Create HKCU\\Software\\Wine\\MSHTML\\MainThreadHack key\n");
+        }
+        return create_marshaled_doc(gecko_main_thread_hwnd, riid, ppv);
+    }
+
     /* ensure that security manager is initialized */
     if(!get_security_manager())
         return E_OUTOFMEMORY;
@@ -5975,8 +6568,8 @@ static HRESULT create_document_object(BOOL is_mhtml, IUnknown *outer, REFIID rii
 
     doc->basedoc.doc_obj = doc;
 
-    init_dispatch(&doc->dispex, (IUnknown*)&doc->ICustomDoc_iface, &HTMLDocumentObj_dispex, COMPAT_MODE_QUIRKS);
-    init_doc(&doc->basedoc, outer ? outer : &doc->IUnknown_inner, &doc->dispex.IDispatchEx_iface);
+    init_dispatch(&doc->dispex, (IUnknown*)&doc->ICustomDoc_iface, &HTMLDocumentObj_dispex, NULL, COMPAT_MODE_QUIRKS);
+    init_doc(&doc->basedoc, outer ? outer : &doc->IUnknown_inner, &doc->dispex);
     TargetContainer_Init(doc);
     doc->is_mhtml = is_mhtml;
 
diff --git a/dlls/mshtml/htmlelem.c b/dlls/mshtml/htmlelem.c
index d911d0a0433..ae2191fa60f 100644
--- a/dlls/mshtml/htmlelem.c
+++ b/dlls/mshtml/htmlelem.c
@@ -181,7 +181,7 @@ static const tag_desc_t *get_tag_desc(const WCHAR *tag_name)
     return NULL;
 }
 
-HRESULT replace_node_by_html(nsIDOMHTMLDocument *nsdoc, nsIDOMNode *nsnode, const WCHAR *html)
+HRESULT replace_node_by_html(nsIDOMDocument *nsdoc, nsIDOMNode *nsnode, const WCHAR *html)
 {
     nsIDOMDocumentFragment *nsfragment;
     nsIDOMNode *nsparent;
@@ -190,7 +190,7 @@ HRESULT replace_node_by_html(nsIDOMHTMLDocument *nsdoc, nsIDOMNode *nsnode, cons
     nsresult nsres;
     HRESULT hres = S_OK;
 
-    nsres = nsIDOMHTMLDocument_CreateRange(nsdoc, &range);
+    nsres = nsIDOMDocument_CreateRange(nsdoc, &range);
     if(NS_FAILED(nsres)) {
         ERR("CreateRange failed: %08lx\n", nsres);
         return E_FAIL;
@@ -430,7 +430,7 @@ static HRESULT create_nselem_parse(HTMLDocumentNode *doc, const WCHAR *tag, nsID
     size = (p + 2 - (tag + 1 + name_len)) * sizeof(WCHAR);
 
     /* Parse the input via a contextual fragment, using a dummy unknown tag */
-    nsres = nsIDOMHTMLDocument_CreateRange(doc->nsdoc, &nsrange);
+    nsres = nsIDOMDocument_CreateRange(doc->nsdoc, &nsrange);
     if(NS_FAILED(nsres))
         return map_nsresult(nsres);
 
@@ -467,7 +467,7 @@ static HRESULT create_nselem_parse(HTMLDocumentNode *doc, const WCHAR *tag, nsID
         p[name_len] = '\0';
 
         nsAString_InitDepend(&str, p);
-        nsres = nsIDOMHTMLDocument_CreateElement(doc->nsdoc, &str, ret);
+        nsres = nsIDOMDocument_CreateElement(doc->nsdoc, &str, ret);
         nsAString_Finish(&str);
         heap_free(p);
 
@@ -494,7 +494,7 @@ HRESULT create_nselem(HTMLDocumentNode *doc, const WCHAR *tag, nsIDOMElement **r
     }
 
     nsAString_InitDepend(&tag_str, tag);
-    nsres = nsIDOMHTMLDocument_CreateElement(doc->nsdoc, &tag_str, ret);
+    nsres = nsIDOMDocument_CreateElement(doc->nsdoc, &tag_str, ret);
     nsAString_Finish(&tag_str);
     if(NS_FAILED(nsres)) {
         ERR("CreateElement failed: %08lx\n", nsres);
@@ -526,6 +526,51 @@ HRESULT create_element(HTMLDocumentNode *doc, const WCHAR *tag, HTMLElement **re
     return hres;
 }
 
+static HTMLDOMAttribute *find_attr_in_list(HTMLAttributeCollection *attrs, DISPID dispid, nsIDOMAttr *nsattr, LONG *pos)
+{
+    HTMLDOMAttribute *iter, *ret = NULL;
+    struct list *list = &attrs->attrs;
+    unsigned i = 0;
+
+    if(nsattr) {
+        LIST_FOR_EACH_ENTRY(iter, list, HTMLDOMAttribute, entry) {
+            if(iter->node.nsnode == (nsIDOMNode*)nsattr) {
+                ret = iter;
+                break;
+            }
+            i++;
+        }
+    }else {
+        LIST_FOR_EACH_ENTRY(iter, list, HTMLDOMAttribute, entry) {
+            if(iter->dispid == dispid) {
+                ret = iter;
+                break;
+            }
+            i++;
+        }
+    }
+    if(pos)
+        *pos = i;
+    return ret;
+}
+
+static DISPID get_dispid_for_nsattr(HTMLElement *elem, nsIDOMAttr *nsattr)
+{
+    DISPID dispid = 0;
+    nsAString nsstr;
+
+    if(SUCCEEDED(nsIDOMAttr_GetName(nsattr, &nsstr))) {
+        const PRUnichar *name;
+        nsAString_GetData(&nsstr, &name);
+
+        /* Supply a dummy non-builtin dispid so it can be checked for expando */
+        if(is_custom_attribute(&elem->node.event_target.dispex, name))
+            dispid = MSHTML_DISPID_CUSTOM_MIN;
+        nsAString_Finish(&nsstr);
+    }
+    return dispid;
+}
+
 typedef struct {
     DispatchEx dispex;
     IHTMLRect IHTMLRect_iface;
@@ -745,14 +790,16 @@ static const tid_t HTMLRect_iface_tids[] = {
     IHTMLRect_tid,
     0
 };
-static dispex_static_data_t HTMLRect_dispex = {
+dispex_static_data_t HTMLRect_dispex = {
     L"ClientRect",
     NULL,
+    PROTO_ID_HTMLRect,
     IHTMLRect_tid,
     HTMLRect_iface_tids
 };
 
-static HRESULT create_html_rect(nsIDOMClientRect *nsrect, compat_mode_t compat_mode, IHTMLRect **ret)
+static HRESULT create_html_rect(nsIDOMClientRect *nsrect, HTMLDocumentNode *doc, compat_mode_t compat_mode,
+        IHTMLRect **ret)
 {
     HTMLRect *rect;
 
@@ -763,7 +810,7 @@ static HRESULT create_html_rect(nsIDOMClientRect *nsrect, compat_mode_t compat_m
     rect->IHTMLRect_iface.lpVtbl = &HTMLRectVtbl;
     rect->ref = 1;
 
-    init_dispatch(&rect->dispex, (IUnknown*)&rect->IHTMLRect_iface, &HTMLRect_dispex, compat_mode);
+    init_dispatch(&rect->dispex, (IUnknown*)&rect->IHTMLRect_iface, &HTMLRect_dispex, doc, compat_mode);
 
     nsIDOMClientRect_AddRef(nsrect);
     rect->nsrect = nsrect;
@@ -778,6 +825,7 @@ typedef struct {
 
     LONG ref;
 
+    HTMLDocumentNode *doc;
     nsIDOMClientRectList *rect_list;
 } HTMLRectCollection;
 
@@ -961,6 +1009,7 @@ static ULONG WINAPI HTMLRectCollection_Release(IHTMLRectCollection *iface)
     if(!ref) {
         if(This->rect_list)
             nsIDOMClientRectList_Release(This->rect_list);
+        htmldoc_release(&This->doc->basedoc);
         release_dispex(&This->dispex);
         heap_free(This);
     }
@@ -1058,7 +1107,7 @@ static HRESULT WINAPI HTMLRectCollection_item(IHTMLRectCollection *iface, VARIAN
         return S_OK;
     }
 
-    hres = create_html_rect(nsrect, dispex_compat_mode(&This->dispex), &rect);
+    hres = create_html_rect(nsrect, This->doc, dispex_compat_mode(&This->dispex), &rect);
     nsIDOMClientRect_Release(nsrect);
     if(FAILED(hres))
         return hres;
@@ -1107,8 +1156,8 @@ static HRESULT HTMLRectCollection_get_dispid(DispatchEx *dispex, BSTR name, DWOR
     return S_OK;
 }
 
-static HRESULT HTMLRectCollection_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
-        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+static HRESULT HTMLRectCollection_invoke(DispatchEx *dispex, IDispatch *this_obj, DISPID id, LCID lcid, WORD flags,
+        DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
     HTMLRectCollection *This = HTMLRectCollection_from_DispatchEx(dispex);
 
@@ -1127,7 +1176,7 @@ static HRESULT HTMLRectCollection_invoke(DispatchEx *dispex, DISPID id, LCID lci
             return DISP_E_UNKNOWNNAME;
         }
 
-        hres = create_html_rect(rect, dispex_compat_mode(&This->dispex), &html_rect);
+        hres = create_html_rect(rect, This->doc, dispex_compat_mode(&This->dispex), &html_rect);
         nsIDOMClientRect_Release(rect);
         if(FAILED(hres))
             return hres;
@@ -1155,9 +1204,10 @@ static const tid_t HTMLRectCollection_iface_tids[] = {
     IHTMLRectCollection_tid,
     0
 };
-static dispex_static_data_t HTMLRectCollection_dispex = {
+dispex_static_data_t HTMLRectCollection_dispex = {
     L"ClientRectList",
     &HTMLRectCollection_dispex_vtbl,
+    PROTO_ID_HTMLRectCollection,
     IHTMLRectCollection_tid,
     HTMLRectCollection_iface_tids
 };
@@ -2207,7 +2257,7 @@ static HRESULT WINAPI HTMLElement_put_innerText(IHTMLElement *iface, BSTR v)
     }
 
     nsAString_InitDepend(&text_str, v);
-    nsres = nsIDOMHTMLDocument_CreateTextNode(This->node.doc->nsdoc, &text_str, &text_node);
+    nsres = nsIDOMDocument_CreateTextNode(This->node.doc->nsdoc, &text_str, &text_node);
     nsAString_Finish(&text_str);
     if(NS_FAILED(nsres)) {
         ERR("CreateTextNode failed: %08lx\n", nsres);
@@ -2288,14 +2338,14 @@ static HRESULT WINAPI HTMLElement_put_outerText(IHTMLElement *iface, BSTR v)
     }
 
     nsAString_InitDepend(&nsstr, v);
-    nsres = nsIDOMHTMLDocument_CreateTextNode(This->node.doc->nsdoc, &nsstr, &text_node);
+    nsres = nsIDOMDocument_CreateTextNode(This->node.doc->nsdoc, &nsstr, &text_node);
     nsAString_Finish(&nsstr);
     if(NS_FAILED(nsres)) {
         ERR("CreateTextNode failed\n");
         return E_FAIL;
     }
 
-    nsres = nsIDOMHTMLDocument_CreateRange(This->node.doc->nsdoc, &range);
+    nsres = nsIDOMDocument_CreateRange(This->node.doc->nsdoc, &range);
     if(NS_SUCCEEDED(nsres)) {
         nsres = nsIDOMRange_SelectNode(range, This->node.nsnode);
         if(NS_SUCCEEDED(nsres))
@@ -2411,7 +2461,7 @@ static HRESULT WINAPI HTMLElement_insertAdjacentHTML(IHTMLElement *iface, BSTR w
         return E_UNEXPECTED;
     }
 
-    nsres = nsIDOMHTMLDocument_CreateRange(This->node.doc->nsdoc, &range);
+    nsres = nsIDOMDocument_CreateRange(This->node.doc->nsdoc, &range);
     if(NS_FAILED(nsres))
     {
         ERR("CreateRange failed: %08lx\n", nsres);
@@ -2454,7 +2504,7 @@ static HRESULT WINAPI HTMLElement_insertAdjacentText(IHTMLElement *iface, BSTR w
 
 
     nsAString_InitDepend(&ns_text, text);
-    nsres = nsIDOMHTMLDocument_CreateTextNode(This->node.doc->nsdoc, &ns_text, (nsIDOMText **)&nsnode);
+    nsres = nsIDOMDocument_CreateTextNode(This->node.doc->nsdoc, &ns_text, (nsIDOMText **)&nsnode);
     nsAString_Finish(&ns_text);
 
     if(NS_FAILED(nsres) || !nsnode)
@@ -2548,8 +2598,8 @@ static HRESULT WINAPI HTMLElement_toString(IHTMLElement *iface, BSTR *String)
     if(!String)
         return E_INVALIDARG;
 
-    hres = IDispatchEx_InvokeEx(&This->node.event_target.dispex.IDispatchEx_iface, DISPID_VALUE,
-                                LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYGET, NULL, &var, NULL, NULL);
+    hres = dispex_invoke(&This->node.event_target.dispex, (IDispatch*)&This->node.event_target.dispex.IDispatchEx_iface,
+                         DISPID_VALUE, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYGET, NULL, &var, NULL, NULL);
     if(SUCCEEDED(hres)) {
         assert(V_VT(&var) == VT_BSTR);
         *String = V_BSTR(&var);
@@ -2701,7 +2751,7 @@ static HRESULT WINAPI HTMLElement_get_children(IHTMLElement *iface, IDispatch **
         return E_FAIL;
     }
 
-    *p = (IDispatch*)create_collection_from_nodelist(nsnode_list, This->node.doc->document_mode);
+    *p = (IDispatch*)create_collection_from_nodelist(nsnode_list, This->node.doc);
 
     nsIDOMNodeList_Release(nsnode_list);
     return S_OK;
@@ -3177,8 +3227,12 @@ static HRESULT WINAPI HTMLElement2_getClientRects(IHTMLElement2 *iface, IHTMLRec
     rects->IHTMLRectCollection_iface.lpVtbl = &HTMLRectCollectionVtbl;
     rects->ref = 1;
     rects->rect_list = rect_list;
-    init_dispatch(&rects->dispex, (IUnknown*)&rects->IHTMLRectCollection_iface,
-                  &HTMLRectCollection_dispex, dispex_compat_mode(&This->node.event_target.dispex));
+    rects->doc = This->node.doc;
+    if(rects->doc)
+        htmldoc_addref(&rects->doc->basedoc);
+
+    init_dispatch(&rects->dispex, (IUnknown*)&rects->IHTMLRectCollection_iface, &HTMLRectCollection_dispex,
+                  rects->doc, dispex_compat_mode(&This->node.event_target.dispex));
 
     *pRectCol = &rects->IHTMLRectCollection_iface;
     return S_OK;
@@ -3204,7 +3258,7 @@ static HRESULT WINAPI HTMLElement2_getBoundingClientRect(IHTMLElement2 *iface, I
         return E_FAIL;
     }
 
-    hres = create_html_rect(nsrect, dispex_compat_mode(&This->node.event_target.dispex), pRect);
+    hres = create_html_rect(nsrect, This->node.doc, dispex_compat_mode(&This->node.event_target.dispex), pRect);
 
     nsIDOMClientRect_Release(nsrect);
     return hres;
@@ -3931,7 +3985,7 @@ static HRESULT WINAPI HTMLElement2_getElementsByTagName(IHTMLElement2 *iface, BS
     TRACE("(%p)->(%s %p)\n", This, debugstr_w(v), pelColl);
 
     if(!This->dom_element) {
-        *pelColl = create_collection_from_htmlcol(NULL, This->node.doc->document_mode);
+        *pelColl = create_collection_from_htmlcol(NULL, This->node.doc);
         return S_OK;
     }
 
@@ -3943,7 +3997,7 @@ static HRESULT WINAPI HTMLElement2_getElementsByTagName(IHTMLElement2 *iface, BS
         return E_FAIL;
     }
 
-    *pelColl = create_collection_from_htmlcol(nscol, dispex_compat_mode(&This->node.event_target.dispex));
+    *pelColl = create_collection_from_htmlcol(nscol, This->node.doc);
     nsIDOMHTMLCollection_Release(nscol);
     return S_OK;
 }
@@ -4241,8 +4295,19 @@ static HRESULT WINAPI HTMLElement3_get_contentEditable(IHTMLElement3 *iface, BST
 static HRESULT WINAPI HTMLElement3_get_isContentEditable(IHTMLElement3 *iface, VARIANT_BOOL *p)
 {
     HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
+    nsresult nsres;
+    cpp_bool r;
+
+    TRACE("(%p)->(%p)\n", This, p);
+
+    if(!This->html_element) {
+        FIXME("non-HTML element\n");
+        return E_NOTIMPL;
+    }
+
+    nsres = nsIDOMHTMLElement_GetIsContentEditable(This->html_element, &r);
+    *p = variant_bool(NS_SUCCEEDED(nsres) && r);
+    return S_OK;
 }
 
 static HRESULT WINAPI HTMLElement3_put_hideFocus(IHTMLElement3 *iface, VARIANT_BOOL v)
@@ -4609,8 +4674,9 @@ static HRESULT WINAPI HTMLElement4_setAttributeNode(IHTMLElement4 *iface, IHTMLD
         IHTMLDOMAttribute **ppretAttribute)
 {
     HTMLElement *This = impl_from_IHTMLElement4(iface);
-    HTMLDOMAttribute *attr, *iter, *replace = NULL;
+    HTMLDOMAttribute *attr, *replace;
     HTMLAttributeCollection *attrs;
+    nsIDOMAttr *nsattr, *oldnsattr;
     DISPID dispid;
     HRESULT hres;
 
@@ -4625,31 +4691,49 @@ static HRESULT WINAPI HTMLElement4_setAttributeNode(IHTMLElement4 *iface, IHTMLD
         return E_INVALIDARG;
     }
 
-    hres = IDispatchEx_GetDispID(&This->node.event_target.dispex.IDispatchEx_iface,
-            attr->name, fdexNameCaseInsensitive|fdexNameEnsure, &dispid);
-    if(FAILED(hres))
-        return hres;
-
     hres = HTMLElement_get_attr_col(&This->node, &attrs);
     if(FAILED(hres))
         return hres;
 
-    LIST_FOR_EACH_ENTRY(iter, &attrs->attrs, HTMLDOMAttribute, entry) {
-        if(iter->dispid == dispid) {
-            replace = iter;
-            break;
-        }
+    nsattr = (nsIDOMAttr*)attr->node.nsnode;
+    if(nsattr && !attrs->nsattrs) {
+        FIXME("Attribute has proper node but no NS collection for it.\n");
+        IHTMLAttributeCollection_Release(&attrs->IHTMLAttributeCollection_iface);
+        return E_NOTIMPL;
     }
 
-    if(replace) {
-        hres = get_elem_attr_value_by_dispid(This, dispid, &replace->value);
+    if(nsattr) {
+        if(NS_FAILED(nsIDOMMozNamedAttrMap_SetNamedItem(attrs->nsattrs, nsattr, &oldnsattr))) {
+            IHTMLAttributeCollection_Release(&attrs->IHTMLAttributeCollection_iface);
+            return E_FAIL;
+        }
+        dispid = get_dispid_for_nsattr(This, nsattr);
+        replace = NULL;
+        if(oldnsattr) {
+            replace = find_attr_in_list(attrs, 0, oldnsattr, NULL);
+            nsIDOMAttr_Release(oldnsattr);
+        }
+    }else {
+        hres = IDispatchEx_GetDispID(&This->node.event_target.dispex.IDispatchEx_iface,
+                attr->name, fdexNameCaseInsensitive|fdexNameEnsure, &dispid);
         if(FAILED(hres)) {
-            WARN("could not get attr value: %08lx\n", hres);
-            V_VT(&replace->value) = VT_EMPTY;
+            IHTMLAttributeCollection_Release(&attrs->IHTMLAttributeCollection_iface);
+            return hres;
         }
-        if(!replace->name) {
-            replace->name = attr->name;
-            attr->name = NULL;
+        replace = find_attr_in_list(attrs, dispid, NULL, NULL);
+    }
+
+    if(replace) {
+        if(!nsattr) {
+            hres = get_elem_attr_value_by_dispid(This, dispid, &replace->value);
+            if(FAILED(hres)) {
+                WARN("could not get attr value: %08lx\n", hres);
+                V_VT(&replace->value) = VT_EMPTY;
+            }
+            if(!replace->name) {
+                replace->name = attr->name;
+                attr->name = NULL;
+            }
         }
         list_add_head(&replace->entry, &attr->entry);
         list_remove(&replace->entry);
@@ -4664,10 +4748,12 @@ static HRESULT WINAPI HTMLElement4_setAttributeNode(IHTMLElement4 *iface, IHTMLD
 
     IHTMLAttributeCollection_Release(&attrs->IHTMLAttributeCollection_iface);
 
-    hres = set_elem_attr_value_by_dispid(This, dispid, &attr->value);
-    if(FAILED(hres))
-        WARN("Could not set attribute value: %08lx\n", hres);
-    VariantClear(&attr->value);
+    if(!nsattr) {
+        hres = set_elem_attr_value_by_dispid(This, dispid, &attr->value);
+        if(FAILED(hres))
+            WARN("Could not set attribute value: %08lx\n", hres);
+        VariantClear(&attr->value);
+    }
 
     *ppretAttribute = replace ? &replace->IHTMLDOMAttribute_iface : NULL;
     return S_OK;
@@ -4813,22 +4899,133 @@ static HRESULT WINAPI HTMLElement6_Invoke(IHTMLElement6 *iface, DISPID dispIdMem
 static HRESULT WINAPI HTMLElement6_getAttributeNS(IHTMLElement6 *iface, VARIANT *pvarNS, BSTR strAttributeName, VARIANT *AttributeValue)
 {
     HTMLElement *This = impl_from_IHTMLElement6(iface);
-    FIXME("(%p)->(%s %s %p)\n", This, debugstr_variant(pvarNS), debugstr_w(strAttributeName), AttributeValue);
-    return E_NOTIMPL;
+    nsAString ns_str, name_str, value_str;
+    const PRUnichar *ns;
+    nsresult nsres;
+    HRESULT hres;
+
+    TRACE("(%p)->(%s %s %p)\n", This, debugstr_variant(pvarNS), debugstr_w(strAttributeName), AttributeValue);
+
+    if(V_VT(pvarNS) == VT_EMPTY || V_VT(pvarNS) == VT_NULL)
+        nsAString_InitDepend(&ns_str, NULL);
+    else {
+        hres = variant_to_nsstr(pvarNS, FALSE, &ns_str);
+        if(FAILED(hres))
+            return hres;
+        nsAString_GetData(&ns_str, &ns);
+        if(!ns[0]) {
+            nsAString_Finish(&ns_str);
+            nsAString_InitDepend(&ns_str, NULL);
+        }
+    }
+
+    if(!This->dom_element) {
+        FIXME("No dom_element\n");
+        nsAString_Finish(&ns_str);
+        return E_NOTIMPL;
+    }
+
+    nsAString_InitDepend(&name_str, strAttributeName);
+    nsAString_InitDepend(&value_str, NULL);
+    nsres = nsIDOMElement_GetAttributeNS(This->dom_element, &ns_str, &name_str, &value_str);
+    nsAString_Finish(&ns_str);
+    nsAString_Finish(&name_str);
+
+    hres = return_nsstr_variant(nsres, &value_str, 0, AttributeValue);
+    if(FAILED(hres) || V_VT(AttributeValue) != VT_NULL)
+        return hres;
+    V_VT(AttributeValue) = VT_BSTR;
+    V_BSTR(AttributeValue) = SysAllocString(L"");
+    return V_BSTR(AttributeValue) ? S_OK : E_OUTOFMEMORY;
 }
 
 static HRESULT WINAPI HTMLElement6_setAttributeNS(IHTMLElement6 *iface, VARIANT *pvarNS, BSTR strAttributeName, VARIANT *pvarAttributeValue)
 {
     HTMLElement *This = impl_from_IHTMLElement6(iface);
-    FIXME("(%p)->(%s %s %s)\n", This, debugstr_variant(pvarNS), debugstr_w(strAttributeName), debugstr_variant(pvarAttributeValue));
-    return E_NOTIMPL;
+    nsAString ns_str, name_str, value_str;
+    BOOL null_ns = FALSE;
+    const PRUnichar *ns;
+    nsresult nsres;
+    HRESULT hres;
+
+    TRACE("(%p)->(%s %s %s)\n", This, debugstr_variant(pvarNS), debugstr_w(strAttributeName), debugstr_variant(pvarAttributeValue));
+
+    if(V_VT(pvarNS) == VT_EMPTY || V_VT(pvarNS) == VT_NULL) {
+        nsAString_InitDepend(&ns_str, NULL);
+        null_ns = TRUE;
+    }else {
+        hres = variant_to_nsstr(pvarNS, FALSE, &ns_str);
+        if(FAILED(hres))
+            return hres;
+        nsAString_GetData(&ns_str, &ns);
+        if(!ns[0]) {
+            nsAString_Finish(&ns_str);
+            nsAString_InitDepend(&ns_str, NULL);
+            null_ns = TRUE;
+        }
+    }
+
+    if(null_ns && wcschr(strAttributeName, ':')) {
+        /* FIXME: Return NamespaceError */
+        return E_FAIL;
+    }
+
+    if(!This->dom_element) {
+        FIXME("No dom_element\n");
+        nsAString_Finish(&ns_str);
+        return E_NOTIMPL;
+    }
+
+    hres = variant_to_nsstr(pvarAttributeValue, FALSE, &value_str);
+    if(FAILED(hres)) {
+        nsAString_Finish(&ns_str);
+        return hres;
+    }
+
+    nsAString_InitDepend(&name_str, strAttributeName);
+    nsres = nsIDOMElement_SetAttributeNS(This->dom_element, &ns_str, &name_str, &value_str);
+    nsAString_Finish(&ns_str);
+    nsAString_Finish(&name_str);
+    nsAString_Finish(&value_str);
+    if(NS_FAILED(nsres))
+        WARN("SetAttributeNS failed: %08lx\n", nsres);
+    return map_nsresult(nsres);
 }
 
 static HRESULT WINAPI HTMLElement6_removeAttributeNS(IHTMLElement6 *iface, VARIANT *pvarNS, BSTR strAttributeName)
 {
     HTMLElement *This = impl_from_IHTMLElement6(iface);
-    FIXME("(%p)->(%s %s)\n", This, debugstr_variant(pvarNS), debugstr_w(strAttributeName));
-    return E_NOTIMPL;
+    nsAString ns_str, name_str;
+    const PRUnichar *ns;
+    nsresult nsres;
+    HRESULT hres;
+
+    TRACE("(%p)->(%s %s)\n", This, debugstr_variant(pvarNS), debugstr_w(strAttributeName));
+
+    if(V_VT(pvarNS) == VT_EMPTY || V_VT(pvarNS) == VT_NULL)
+        nsAString_InitDepend(&ns_str, NULL);
+    else {
+        hres = variant_to_nsstr(pvarNS, FALSE, &ns_str);
+        if(FAILED(hres))
+            return hres;
+        nsAString_GetData(&ns_str, &ns);
+        if(!ns[0]) {
+            nsAString_Finish(&ns_str);
+            nsAString_InitDepend(&ns_str, NULL);
+        }
+    }
+
+    if(!This->dom_element) {
+        FIXME("No dom_element\n");
+        nsAString_Finish(&ns_str);
+        return E_NOTIMPL;
+    }
+
+    nsAString_InitDepend(&name_str, strAttributeName);
+    nsres = nsIDOMElement_RemoveAttributeNS(This->dom_element, &ns_str, &name_str);
+    nsAString_Finish(&ns_str);
+    nsAString_Finish(&name_str);
+    return map_nsresult(nsres);
 }
 
 static HRESULT WINAPI HTMLElement6_getAttributeNodeNS(IHTMLElement6 *iface, VARIANT *pvarNS, BSTR name, IHTMLDOMAttribute2 **ppretAttribute)
@@ -4848,8 +5045,39 @@ static HRESULT WINAPI HTMLElement6_setAttributeNodeNS(IHTMLElement6 *iface, IHTM
 static HRESULT WINAPI HTMLElement6_hasAttributeNS(IHTMLElement6 *iface, VARIANT *pvarNS, BSTR name, VARIANT_BOOL *pfHasAttribute)
 {
     HTMLElement *This = impl_from_IHTMLElement6(iface);
-    FIXME("(%p)->(%s %s %p)\n", This, debugstr_variant(pvarNS), debugstr_w(name), pfHasAttribute);
-    return E_NOTIMPL;
+    nsAString ns_str, name_str;
+    const PRUnichar *ns;
+    nsresult nsres;
+    HRESULT hres;
+    cpp_bool r;
+
+    TRACE("(%p)->(%s %s %p)\n", This, debugstr_variant(pvarNS), debugstr_w(name), pfHasAttribute);
+
+    if(V_VT(pvarNS) == VT_EMPTY || V_VT(pvarNS) == VT_NULL)
+        nsAString_InitDepend(&ns_str, NULL);
+    else {
+        hres = variant_to_nsstr(pvarNS, FALSE, &ns_str);
+        if(FAILED(hres))
+            return hres;
+        nsAString_GetData(&ns_str, &ns);
+        if(!ns[0]) {
+            nsAString_Finish(&ns_str);
+            nsAString_InitDepend(&ns_str, NULL);
+        }
+    }
+
+    if(!This->dom_element) {
+        FIXME("No dom_element\n");
+        nsAString_Finish(&ns_str);
+        return E_NOTIMPL;
+    }
+
+    nsAString_InitDepend(&name_str, name);
+    nsres = nsIDOMElement_HasAttributeNS(This->dom_element, &ns_str, &name_str, &r);
+    nsAString_Finish(&ns_str);
+    nsAString_Finish(&name_str);
+    *pfHasAttribute = variant_bool(NS_SUCCEEDED(nsres) && r);
+    return S_OK;
 }
 
 static HRESULT WINAPI HTMLElement6_getAttribute(IHTMLElement6 *iface, BSTR strAttributeName, VARIANT *AttributeValue)
@@ -4987,7 +5215,7 @@ static HRESULT WINAPI HTMLElement6_getElementsByClassName(IHTMLElement6 *iface,
         }
     }
 
-    *pel = create_collection_from_htmlcol(nscol, dispex_compat_mode(&This->node.event_target.dispex));
+    *pel = create_collection_from_htmlcol(nscol, This->node.doc);
     nsIDOMHTMLCollection_Release(nscol);
     return S_OK;
 }
@@ -6260,7 +6488,7 @@ static HRESULT WINAPI ElementSelector_querySelectorAll(IElementSelector *iface,
         return hres;
     }
 
-    hres = create_child_collection(node_list, dispex_compat_mode(&This->node.event_target.dispex), pel);
+    hres = create_child_collection(node_list, This->node.doc, pel);
     nsIDOMNodeList_Release(node_list);
     return hres;
 }
@@ -6427,29 +6655,102 @@ static HRESULT WINAPI ElementTraversal_get_firstElementChild(IElementTraversal *
 static HRESULT WINAPI ElementTraversal_get_lastElementChild(IElementTraversal *iface, IHTMLElement **p)
 {
     HTMLElement *This = impl_from_IElementTraversal(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
+    nsIDOMElement *nselem = NULL;
+    HTMLElement *elem;
+    HRESULT hres;
+
+    TRACE("(%p)->(%p)\n", This, p);
+
+    if(!This->dom_element) {
+        *p = NULL;
+        return S_OK;
+    }
+
+    nsIDOMElement_GetLastElementChild(This->dom_element, &nselem);
+    if(!nselem) {
+        *p = NULL;
+        return S_OK;
+    }
+
+    hres = get_element(nselem, &elem);
+    nsIDOMElement_Release(nselem);
+    if(FAILED(hres))
+        return hres;
+
+    *p = &elem->IHTMLElement_iface;
+    return S_OK;
 }
 
 static HRESULT WINAPI ElementTraversal_get_previousElementSibling(IElementTraversal *iface, IHTMLElement **p)
 {
     HTMLElement *This = impl_from_IElementTraversal(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
+    nsIDOMElement *nselem = NULL;
+    HTMLElement *elem;
+    HRESULT hres;
+
+    TRACE("(%p)->(%p)\n", This, p);
+
+    if(!This->dom_element) {
+        *p = NULL;
+        return S_OK;
+    }
+
+    nsIDOMElement_GetPreviousElementSibling(This->dom_element, &nselem);
+    if(!nselem) {
+        *p = NULL;
+        return S_OK;
+    }
+
+    hres = get_element(nselem, &elem);
+    nsIDOMElement_Release(nselem);
+    if(FAILED(hres))
+        return hres;
+
+    *p = &elem->IHTMLElement_iface;
+    return S_OK;
 }
 
 static HRESULT WINAPI ElementTraversal_get_nextElementSibling(IElementTraversal *iface, IHTMLElement **p)
 {
     HTMLElement *This = impl_from_IElementTraversal(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
+    nsIDOMElement *nselem = NULL;
+    HTMLElement *elem;
+    HRESULT hres;
+
+    TRACE("(%p)->(%p)\n", This, p);
+
+    if(!This->dom_element) {
+        *p = NULL;
+        return S_OK;
+    }
+
+    nsIDOMElement_GetNextElementSibling(This->dom_element, &nselem);
+    if(!nselem) {
+        *p = NULL;
+        return S_OK;
+    }
+
+    hres = get_element(nselem, &elem);
+    nsIDOMElement_Release(nselem);
+    if(FAILED(hres))
+        return hres;
+
+    *p = &elem->IHTMLElement_iface;
+    return S_OK;
 }
 
 static HRESULT WINAPI ElementTraversal_get_childElementCount(IElementTraversal *iface, LONG *p)
 {
     HTMLElement *This = impl_from_IElementTraversal(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
+    UINT32 count = 0;
+
+    TRACE("(%p)->(%p)\n", This, p);
+
+    if(This->dom_element)
+        nsIDOMElement_GetChildElementCount(This->dom_element, &count);
+
+    *p = count;
+    return S_OK;
 }
 
 static const IElementTraversalVtbl ElementTraversalVtbl = {
@@ -6637,14 +6938,13 @@ static HRESULT HTMLElement_get_dispid(DispatchEx *dispex, BSTR name,
     return DISP_E_UNKNOWNNAME;
 }
 
-static HRESULT HTMLElement_invoke(DispatchEx *dispex, DISPID id, LCID lcid,
-        WORD flags, DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei,
-        IServiceProvider *caller)
+static HRESULT HTMLElement_invoke(DispatchEx *dispex, IDispatch *this_obj, DISPID id, LCID lcid,
+        WORD flags, DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
     HTMLElement *This = impl_from_DispatchEx(dispex);
 
     if(This->node.vtbl->invoke)
-        return This->node.vtbl->invoke(&This->node, id, lcid, flags,
+        return This->node.vtbl->invoke(&This->node, this_obj, id, lcid, flags,
                 params, res, ei, caller);
 
     ERR("(%p): element has no invoke method\n", This);
@@ -6791,6 +7091,148 @@ static IHTMLEventObj *HTMLElement_set_current_event(DispatchEx *dispex, IHTMLEve
     return default_set_current_event(This->node.doc->window, event);
 }
 
+static HRESULT IHTMLElement6_hasAttributeNS_hook(DispatchEx *dispex, WORD flags, DISPPARAMS *dp,
+        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+{
+    VARIANT args[2];
+    HRESULT hres;
+    DISPPARAMS new_dp = { args, NULL, 2, 0 };
+
+    if(!(flags & DISPATCH_METHOD) || dp->cArgs < 2 || dp->cNamedArgs)
+        return S_FALSE;
+
+    switch(V_VT(&dp->rgvarg[dp->cArgs - 1])) {
+    case VT_EMPTY:
+    case VT_BSTR:
+    case VT_NULL:
+        return S_FALSE;
+    default:
+        break;
+    }
+
+    hres = change_type(&args[1], &dp->rgvarg[dp->cArgs - 1], VT_BSTR, caller);
+    if(FAILED(hres))
+        return hres;
+    args[0] = dp->rgvarg[dp->cArgs - 2];
+
+    hres = dispex_call_builtin(dispex, DISPID_IHTMLELEMENT6_HASATTRIBUTENS, &new_dp, res, ei, caller);
+    VariantClear(&args[1]);
+    return hres;
+}
+
+static HRESULT IHTMLElement6_getAttributeNS_hook(DispatchEx *dispex, WORD flags, DISPPARAMS *dp,
+        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+{
+    VARIANT args[2];
+    HRESULT hres;
+    DISPPARAMS new_dp = { args, NULL, 2, 0 };
+
+    if(!(flags & DISPATCH_METHOD) || dp->cArgs < 2 || dp->cNamedArgs)
+        return S_FALSE;
+
+    switch(V_VT(&dp->rgvarg[dp->cArgs - 1])) {
+    case VT_EMPTY:
+    case VT_BSTR:
+    case VT_NULL:
+        return S_FALSE;
+    default:
+        break;
+    }
+
+    hres = change_type(&args[1], &dp->rgvarg[dp->cArgs - 1], VT_BSTR, caller);
+    if(FAILED(hres))
+        return hres;
+    args[0] = dp->rgvarg[dp->cArgs - 2];
+
+    hres = dispex_call_builtin(dispex, DISPID_IHTMLELEMENT6_GETATTRIBUTENS, &new_dp, res, ei, caller);
+    VariantClear(&args[1]);
+    return hres;
+}
+
+static HRESULT IHTMLElement6_setAttributeNS_hook(DispatchEx *dispex, WORD flags, DISPPARAMS *dp,
+        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+{
+    BOOL ns_conv = FALSE, val_conv = FALSE;
+    VARIANT args[3];
+    HRESULT hres;
+    DISPPARAMS new_dp = { args, NULL, 3, 0 };
+
+    if(!(flags & DISPATCH_METHOD) || dp->cArgs < 3 || dp->cNamedArgs)
+        return S_FALSE;
+
+    if(dispex_compat_mode(dispex) < COMPAT_MODE_IE10)
+        args[2] = dp->rgvarg[dp->cArgs - 1];
+    else {
+        switch(V_VT(&dp->rgvarg[dp->cArgs - 1])) {
+        case VT_EMPTY:
+        case VT_BSTR:
+        case VT_NULL:
+            args[2] = dp->rgvarg[dp->cArgs - 1];
+            break;
+        default:
+            hres = change_type(&args[2], &dp->rgvarg[dp->cArgs - 1], VT_BSTR, caller);
+            if(FAILED(hres))
+                return hres;
+            ns_conv = TRUE;
+            break;
+        }
+    }
+
+    switch(V_VT(&dp->rgvarg[dp->cArgs - 3])) {
+    case VT_EMPTY:
+    case VT_BSTR:
+    case VT_NULL:
+        if(!ns_conv)
+            return S_FALSE;
+        args[0] = dp->rgvarg[dp->cArgs - 3];
+        break;
+    default:
+        hres = change_type(&args[0], &dp->rgvarg[dp->cArgs - 3], VT_BSTR, caller);
+        if(FAILED(hres)) {
+            if(ns_conv)
+                VariantClear(&args[2]);
+            return hres;
+        }
+        val_conv = TRUE;
+        break;
+    }
+
+    args[1] = dp->rgvarg[dp->cArgs - 2];
+    hres = dispex_call_builtin(dispex, DISPID_IHTMLELEMENT6_SETATTRIBUTENS, &new_dp, res, ei, caller);
+    if(ns_conv)  VariantClear(&args[2]);
+    if(val_conv) VariantClear(&args[0]);
+    return hres;
+}
+
+static HRESULT IHTMLElement6_removeAttributeNS_hook(DispatchEx *dispex, WORD flags, DISPPARAMS *dp,
+        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+{
+    VARIANT args[2];
+    HRESULT hres;
+    DISPPARAMS new_dp = { args, NULL, 2, 0 };
+
+    if(!(flags & DISPATCH_METHOD) || dp->cArgs < 2 || dp->cNamedArgs)
+        return S_FALSE;
+
+    switch(V_VT(&dp->rgvarg[dp->cArgs - 1])) {
+    case VT_EMPTY:
+    case VT_BSTR:
+    case VT_NULL:
+        return S_FALSE;
+    default:
+        break;
+    }
+
+    hres = change_type(&args[1], &dp->rgvarg[dp->cArgs - 1], VT_BSTR, caller);
+    if(FAILED(hres))
+        return hres;
+    args[0] = dp->rgvarg[dp->cArgs - 2];
+
+    hres = dispex_call_builtin(dispex, DISPID_IHTMLELEMENT6_REMOVEATTRIBUTENS, &new_dp, res, ei, caller);
+    VariantClear(&args[1]);
+    return hres;
+}
+
 static HRESULT IHTMLElement6_setAttribute_hook(DispatchEx *dispex, WORD flags, DISPPARAMS *dp,
         VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
@@ -6822,7 +7264,15 @@ static HRESULT IHTMLElement6_setAttribute_hook(DispatchEx *dispex, WORD flags, D
 
 void HTMLElement_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
 {
+    static const dispex_hook_t elem6_ie9_hooks[] = {
+        {DISPID_IHTMLELEMENT6_SETATTRIBUTENS, IHTMLElement6_setAttributeNS_hook},
+        {DISPID_UNKNOWN}
+    };
     static const dispex_hook_t elem6_ie10_hooks[] = {
+        {DISPID_IHTMLELEMENT6_HASATTRIBUTENS, IHTMLElement6_hasAttributeNS_hook},
+        {DISPID_IHTMLELEMENT6_GETATTRIBUTENS, IHTMLElement6_getAttributeNS_hook},
+        {DISPID_IHTMLELEMENT6_SETATTRIBUTENS, IHTMLElement6_setAttributeNS_hook},
+        {DISPID_IHTMLELEMENT6_REMOVEATTRIBUTENS, IHTMLElement6_removeAttributeNS_hook},
         {DISPID_IHTMLELEMENT6_IE9_SETATTRIBUTE, IHTMLElement6_setAttribute_hook},
         {DISPID_UNKNOWN}
     };
@@ -6840,7 +7290,7 @@ void HTMLElement_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
         dispex_info_add_interface(info, IElementSelector_tid, NULL);
 
     if(mode >= COMPAT_MODE_IE9) {
-        dispex_info_add_interface(info, IHTMLElement6_tid, mode >= COMPAT_MODE_IE10 ? elem6_ie10_hooks : NULL);
+        dispex_info_add_interface(info, IHTMLElement6_tid, mode >= COMPAT_MODE_IE10 ? elem6_ie10_hooks : elem6_ie9_hooks);
         dispex_info_add_interface(info, IElementTraversal_tid, NULL);
     }
 
@@ -6862,6 +7312,8 @@ static event_target_vtbl_t HTMLElement_event_target_vtbl = {
         HTMLElement_get_dispid,
         HTMLElement_invoke,
         NULL,
+        NULL,
+        NULL,
         HTMLElement_populate_props
     },
     HTMLElement_get_gecko_target,
@@ -6872,6 +7324,246 @@ static event_target_vtbl_t HTMLElement_event_target_vtbl = {
     HTMLElement_set_current_event
 };
 
+static void DOMElement_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
+{
+    static const dispex_hook_t elem_hooks[] = {
+        {DISPID_IHTMLELEMENT_CLASSNAME},
+        {DISPID_IHTMLELEMENT_ID},
+        {DISPID_IHTMLELEMENT_PARENTELEMENT},
+        {DISPID_IHTMLELEMENT_STYLE},
+        {DISPID_IHTMLELEMENT_ONHELP},
+        {DISPID_IHTMLELEMENT_ONCLICK},
+        {DISPID_IHTMLELEMENT_ONDBLCLICK},
+        {DISPID_IHTMLELEMENT_ONKEYDOWN},
+        {DISPID_IHTMLELEMENT_ONKEYUP},
+        {DISPID_IHTMLELEMENT_ONKEYPRESS},
+        {DISPID_IHTMLELEMENT_ONMOUSEOUT},
+        {DISPID_IHTMLELEMENT_ONMOUSEOVER},
+        {DISPID_IHTMLELEMENT_ONMOUSEMOVE},
+        {DISPID_IHTMLELEMENT_ONMOUSEDOWN},
+        {DISPID_IHTMLELEMENT_ONMOUSEUP},
+        {DISPID_IHTMLELEMENT_DOCUMENT},
+        {DISPID_IHTMLELEMENT_TITLE},
+        {DISPID_IHTMLELEMENT_LANGUAGE},
+        {DISPID_IHTMLELEMENT_ONSELECTSTART},
+        {DISPID_IHTMLELEMENT_SCROLLINTOVIEW},
+        {DISPID_IHTMLELEMENT_CONTAINS},
+        {DISPID_IHTMLELEMENT_SOURCEINDEX},
+        {DISPID_IHTMLELEMENT_RECORDNUMBER},
+        {DISPID_IHTMLELEMENT_LANG},
+        {DISPID_IHTMLELEMENT_OFFSETLEFT},
+        {DISPID_IHTMLELEMENT_OFFSETTOP},
+        {DISPID_IHTMLELEMENT_OFFSETWIDTH},
+        {DISPID_IHTMLELEMENT_OFFSETHEIGHT},
+        {DISPID_IHTMLELEMENT_OFFSETPARENT},
+        {DISPID_IHTMLELEMENT_INNERHTML},
+        {DISPID_IHTMLELEMENT_INNERTEXT},
+        {DISPID_IHTMLELEMENT_OUTERHTML},
+        {DISPID_IHTMLELEMENT_OUTERTEXT},
+        {DISPID_IHTMLELEMENT_INSERTADJACENTHTML},
+        {DISPID_IHTMLELEMENT_INSERTADJACENTTEXT},
+        {DISPID_IHTMLELEMENT_PARENTTEXTEDIT},
+        {DISPID_IHTMLELEMENT_ISTEXTEDIT},
+        {DISPID_IHTMLELEMENT_CLICK},
+        {DISPID_IHTMLELEMENT_FILTERS},
+        {DISPID_IHTMLELEMENT_ONDRAGSTART},
+        {DISPID_IHTMLELEMENT_TOSTRING},
+        {DISPID_IHTMLELEMENT_ONBEFOREUPDATE},
+        {DISPID_IHTMLELEMENT_ONAFTERUPDATE},
+        {DISPID_IHTMLELEMENT_ONERRORUPDATE},
+        {DISPID_IHTMLELEMENT_ONROWEXIT},
+        {DISPID_IHTMLELEMENT_ONROWENTER},
+        {DISPID_IHTMLELEMENT_ONDATASETCHANGED},
+        {DISPID_IHTMLELEMENT_ONDATAAVAILABLE},
+        {DISPID_IHTMLELEMENT_ONDATASETCOMPLETE},
+        {DISPID_IHTMLELEMENT_ONFILTERCHANGE},
+        {DISPID_IHTMLELEMENT_CHILDREN},
+        {DISPID_IHTMLELEMENT_ALL},
+        {DISPID_UNKNOWN}
+    };
+    static const dispex_hook_t elem2_hooks[] = {
+        {DISPID_IHTMLELEMENT2_SCOPENAME},
+        {DISPID_IHTMLELEMENT2_SETCAPTURE},
+        {DISPID_IHTMLELEMENT2_RELEASECAPTURE},
+        {DISPID_IHTMLELEMENT2_ONLOSECAPTURE},
+        {DISPID_IHTMLELEMENT2_COMPONENTFROMPOINT},
+        {DISPID_IHTMLELEMENT2_DOSCROLL},
+        {DISPID_IHTMLELEMENT2_ONSCROLL},
+        {DISPID_IHTMLELEMENT2_ONDRAG},
+        {DISPID_IHTMLELEMENT2_ONDRAGEND},
+        {DISPID_IHTMLELEMENT2_ONDRAGENTER},
+        {DISPID_IHTMLELEMENT2_ONDRAGOVER},
+        {DISPID_IHTMLELEMENT2_ONDRAGLEAVE},
+        {DISPID_IHTMLELEMENT2_ONDROP},
+        {DISPID_IHTMLELEMENT2_ONBEFORECUT},
+        {DISPID_IHTMLELEMENT2_ONCUT},
+        {DISPID_IHTMLELEMENT2_ONBEFORECOPY},
+        {DISPID_IHTMLELEMENT2_ONCOPY},
+        {DISPID_IHTMLELEMENT2_ONBEFOREPASTE},
+        {DISPID_IHTMLELEMENT2_ONPASTE},
+        {DISPID_IHTMLELEMENT2_CURRENTSTYLE},
+        {DISPID_IHTMLELEMENT2_ONPROPERTYCHANGE},
+        {DISPID_IHTMLELEMENT2_SETEXPRESSION},
+        {DISPID_IHTMLELEMENT2_GETEXPRESSION},
+        {DISPID_IHTMLELEMENT2_REMOVEEXPRESSION},
+        {DISPID_IHTMLELEMENT2_TABINDEX},
+        {DISPID_IHTMLELEMENT2_FOCUS},
+        {DISPID_IHTMLELEMENT2_ACCESSKEY},
+        {DISPID_IHTMLELEMENT2_ONBLUR},
+        {DISPID_IHTMLELEMENT2_ONFOCUS},
+        {DISPID_IHTMLELEMENT2_ONRESIZE},
+        {DISPID_IHTMLELEMENT2_BLUR},
+        {DISPID_IHTMLELEMENT2_ADDFILTER},
+        {DISPID_IHTMLELEMENT2_REMOVEFILTER},
+        {DISPID_IHTMLELEMENT2_ATTACHEVENT},
+        {DISPID_IHTMLELEMENT2_DETACHEVENT},
+        {DISPID_IHTMLELEMENT2_READYSTATE},
+        {DISPID_IHTMLELEMENT2_ONREADYSTATECHANGE},
+        {DISPID_IHTMLELEMENT2_ONROWSDELETE},
+        {DISPID_IHTMLELEMENT2_ONROWSINSERTED},
+        {DISPID_IHTMLELEMENT2_ONCELLCHANGE},
+        {DISPID_IHTMLELEMENT2_DIR},
+        {DISPID_IHTMLELEMENT2_CREATECONTROLRANGE},
+        {DISPID_IHTMLELEMENT2_CLEARATTRIBUTES},
+        {DISPID_IHTMLELEMENT2_MERGEATTRIBUTES},
+        {DISPID_IHTMLELEMENT2_ONCONTEXTMENU},
+        {DISPID_IHTMLELEMENT2_INSERTADJACENTELEMENT},
+        {DISPID_IHTMLELEMENT2_APPLYELEMENT},
+        {DISPID_IHTMLELEMENT2_GETADJACENTTEXT},
+        {DISPID_IHTMLELEMENT2_REPLACEADJACENTTEXT},
+        {DISPID_IHTMLELEMENT2_CANHAVECHILDREN},
+        {DISPID_IHTMLELEMENT2_ADDBEHAVIOR},
+        {DISPID_IHTMLELEMENT2_REMOVEBEHAVIOR},
+        {DISPID_IHTMLELEMENT2_RUNTIMESTYLE},
+        {DISPID_IHTMLELEMENT2_BEHAVIORURNS},
+        {DISPID_IHTMLELEMENT2_TAGURN},
+        {DISPID_IHTMLELEMENT2_ONBEFOREEDITFOCUS},
+        {DISPID_IHTMLELEMENT2_READYSTATEVALUE},
+        {DISPID_UNKNOWN}
+    };
+    static const dispex_hook_t elem3_hooks[] = {
+        {DISPID_IHTMLELEMENT3_MERGEATTRIBUTES},
+        {DISPID_IHTMLELEMENT3_ISMULTILINE},
+        {DISPID_IHTMLELEMENT3_CANHAVEHTML},
+        {DISPID_IHTMLELEMENT3_ONLAYOUTCOMPLETE},
+        {DISPID_IHTMLELEMENT3_ONPAGE},
+        {DISPID_IHTMLELEMENT3_INFLATEBLOCK},
+        {DISPID_IHTMLELEMENT3_ONBEFOREDEACTIVATE},
+        {DISPID_IHTMLELEMENT3_SETACTIVE},
+        {DISPID_IHTMLELEMENT3_CONTENTEDITABLE},
+        {DISPID_IHTMLELEMENT3_ISCONTENTEDITABLE},
+        {DISPID_IHTMLELEMENT3_HIDEFOCUS},
+        {DISPID_IHTMLELEMENT3_DISABLED},
+        {DISPID_IHTMLELEMENT3_ISDISABLED},
+        {DISPID_IHTMLELEMENT3_ONMOVE},
+        {DISPID_IHTMLELEMENT3_ONCONTROLSELECT},
+        {DISPID_IHTMLELEMENT3_FIREEVENT},
+        {DISPID_IHTMLELEMENT3_ONRESIZESTART},
+        {DISPID_IHTMLELEMENT3_ONRESIZEEND},
+        {DISPID_IHTMLELEMENT3_ONMOVESTART},
+        {DISPID_IHTMLELEMENT3_ONMOVEEND},
+        {DISPID_IHTMLELEMENT3_ONMOUSEENTER},
+        {DISPID_IHTMLELEMENT3_ONMOUSELEAVE},
+        {DISPID_IHTMLELEMENT3_ONACTIVATE},
+        {DISPID_IHTMLELEMENT3_ONDEACTIVATE},
+        {DISPID_IHTMLELEMENT3_DRAGDROP},
+        {DISPID_IHTMLELEMENT3_GLYPHMODE},
+        {DISPID_UNKNOWN}
+    };
+    static const dispex_hook_t elem4_hooks[] = {
+        {DISPID_IHTMLELEMENT4_ONMOUSEWHEEL},
+        {DISPID_IHTMLELEMENT4_NORMALIZE},
+        {DISPID_IHTMLELEMENT4_ONBEFOREACTIVATE},
+        {DISPID_IHTMLELEMENT4_ONFOCUSIN},
+        {DISPID_IHTMLELEMENT4_ONFOCUSOUT},
+        {DISPID_UNKNOWN}
+    };
+    static const dispex_hook_t elem6_ie10_hooks[] = {
+        {DISPID_IHTMLELEMENT6_HASATTRIBUTENS, IHTMLElement6_hasAttributeNS_hook},
+        {DISPID_IHTMLELEMENT6_GETATTRIBUTENS, IHTMLElement6_getAttributeNS_hook},
+        {DISPID_IHTMLELEMENT6_REMOVEATTRIBUTENS, IHTMLElement6_removeAttributeNS_hook},
+        {DISPID_IHTMLELEMENT6_IE9_SETATTRIBUTE, IHTMLElement6_setAttribute_hook},
+
+        /* common for all supported modes */
+        {DISPID_IHTMLELEMENT6_SETATTRIBUTENS, IHTMLElement6_setAttributeNS_hook},
+
+        {DISPID_IHTMLELEMENT6_IE9_NODENAME},
+        {DISPID_IHTMLELEMENT6_GETELEMENTSBYCLASSNAME},
+        {DISPID_IHTMLELEMENT6_ONABORT},
+        {DISPID_IHTMLELEMENT6_ONCANPLAY},
+        {DISPID_IHTMLELEMENT6_ONCANPLAYTHROUGH},
+        {DISPID_IHTMLELEMENT6_ONCHANGE},
+        {DISPID_IHTMLELEMENT6_ONDURATIONCHANGE},
+        {DISPID_IHTMLELEMENT6_ONEMPTIED},
+        {DISPID_IHTMLELEMENT6_ONENDED},
+        {DISPID_IHTMLELEMENT6_ONERROR},
+        {DISPID_IHTMLELEMENT6_ONINPUT},
+        {DISPID_IHTMLELEMENT6_ONLOAD},
+        {DISPID_IHTMLELEMENT6_ONLOADEDDATA},
+        {DISPID_IHTMLELEMENT6_ONLOADEDMETADATA},
+        {DISPID_IHTMLELEMENT6_ONLOADSTART},
+        {DISPID_IHTMLELEMENT6_ONPAUSE},
+        {DISPID_IHTMLELEMENT6_ONPLAY},
+        {DISPID_IHTMLELEMENT6_ONPLAYING},
+        {DISPID_IHTMLELEMENT6_ONPROGRESS},
+        {DISPID_IHTMLELEMENT6_ONRATECHANGE},
+        {DISPID_IHTMLELEMENT6_ONRESET},
+        {DISPID_IHTMLELEMENT6_ONSEEKED},
+        {DISPID_IHTMLELEMENT6_ONSEEKING},
+        {DISPID_IHTMLELEMENT6_ONSELECT},
+        {DISPID_IHTMLELEMENT6_ONSTALLED},
+        {DISPID_IHTMLELEMENT6_ONSUBMIT},
+        {DISPID_IHTMLELEMENT6_ONSUSPEND},
+        {DISPID_IHTMLELEMENT6_ONTIMEUPDATE},
+        {DISPID_IHTMLELEMENT6_ONVOLUMECHANGE},
+        {DISPID_IHTMLELEMENT6_ONWAITING},
+        {DISPID_IHTMLELEMENT6_IE9_HASATTRIBUTES},
+        {DISPID_UNKNOWN}
+    };
+    const dispex_hook_t *const elem6_hooks = elem6_ie10_hooks + 4;
+    static const dispex_hook_t elem7_hooks[] = {
+        {DISPID_IHTMLELEMENT7_ONMSPOINTERHOVER},
+        {DISPID_IHTMLELEMENT7_ONMSTRANSITIONSTART},
+        {DISPID_IHTMLELEMENT7_ONMSTRANSITIONEND},
+        {DISPID_IHTMLELEMENT7_ONMSANIMATIONSTART},
+        {DISPID_IHTMLELEMENT7_ONMSANIMATIONEND},
+        {DISPID_IHTMLELEMENT7_ONMSANIMATIONITERATION},
+        {DISPID_IHTMLELEMENT7_ONINVALID},
+        {DISPID_IHTMLELEMENT7_XMSACCELERATORKEY},
+        {DISPID_IHTMLELEMENT7_SPELLCHECK},
+        {DISPID_IHTMLELEMENT7_ONMSMANIPULATIONSTATECHANGED},
+        {DISPID_IHTMLELEMENT7_ONCUECHANGE},
+        {DISPID_UNKNOWN}
+    };
+    static const tid_t hookless_tids[] = {
+        IHTMLDOMNode_tid,
+        IHTMLDOMNode2_tid,
+        IElementSelector_tid,
+        IElementTraversal_tid,
+        0
+    };
+    unsigned i;
+
+    dispex_info_add_interface(info, IHTMLElement2_tid, elem2_hooks);
+    dispex_info_add_interface(info, IHTMLElement6_tid, mode >= COMPAT_MODE_IE10 ? elem6_ie10_hooks : elem6_hooks);
+    if(mode >= COMPAT_MODE_IE10)
+        dispex_info_add_interface(info, IHTMLElement7_tid, elem7_hooks);
+    dispex_info_add_interface(info, IHTMLElement_tid, elem_hooks);
+    dispex_info_add_interface(info, IHTMLElement3_tid, elem3_hooks);
+    dispex_info_add_interface(info, IHTMLElement4_tid, elem4_hooks);
+    for(i = 0; i < ARRAY_SIZE(hookless_tids); i++)
+        dispex_info_add_interface(info, hookless_tids[i], NULL);
+}
+
+dispex_static_data_t DOMElement_dispex = {
+    L"Element",
+    NULL,
+    PROTO_ID_DOMElement,
+    NULL_tid,
+    no_iface_tids,
+    DOMElement_init_dispex_info
+};
+
 struct token_list {
     DispatchEx dispex;
     IWineDOMTokenList IWineDOMTokenList_iface;
@@ -7145,9 +7837,10 @@ static const tid_t token_list_iface_tids[] = {
     IWineDOMTokenList_tid,
     0
 };
-static dispex_static_data_t token_list_dispex = {
+dispex_static_data_t DOMTokenList_dispex = {
     L"DOMTokenList",
     &token_list_dispex_vtbl,
+    PROTO_ID_DOMTokenList,
     IWineDOMTokenList_tid,
     token_list_iface_tids
 };
@@ -7165,7 +7858,7 @@ static HRESULT create_token_list(compat_mode_t compat_mode, IHTMLElement *elemen
 
     obj->IWineDOMTokenList_iface.lpVtbl = &WineDOMTokenListVtbl;
     obj->ref = 1;
-    init_dispatch(&obj->dispex, (IUnknown*)&obj->IWineDOMTokenList_iface, &token_list_dispex, compat_mode);
+    init_dispatch(&obj->dispex, (IUnknown*)&obj->IWineDOMTokenList_iface, &DOMTokenList_dispex, NULL, compat_mode);
     IHTMLElement_AddRef(element);
     obj->element = element;
 
@@ -7256,17 +7949,19 @@ static const IWineHTMLElementPrivateVtbl WineHTMLElementPrivateVtbl = {
     htmlelement_private_get_classList,
 };
 
-static dispex_static_data_t HTMLElement_dispex = {
+dispex_static_data_t HTMLElement_dispex = {
     L"HTMLElement",
     &HTMLElement_event_target_vtbl.dispex_vtbl,
+    PROTO_ID_HTMLElement,
     DispHTMLUnknownElement_tid,
     HTMLElement_iface_tids,
     HTMLElement_init_dispex_info
 };
 
-static dispex_static_data_t HTMLUnknownElement_dispex = {
+dispex_static_data_t HTMLUnknownElement_dispex = {
     L"HTMLUnknownElement",
     &HTMLElement_event_target_vtbl.dispex_vtbl,
+    PROTO_ID_HTMLUnknownElement,
     DispHTMLUnknownElement_tid,
     HTMLElement_iface_tids,
     HTMLElement_init_dispex_info
@@ -7293,7 +7988,10 @@ void HTMLElement_Init(HTMLElement *This, HTMLDocumentNode *doc, nsIDOMElement *n
         nsIDOMHTMLElement *html_element;
         nsresult nsres;
 
-        HTMLDOMNode_Init(doc, &This->node, (nsIDOMNode*)nselem, dispex_data ? dispex_data : &HTMLUnknownElement_dispex);
+        if(!dispex_data)
+            dispex_data = (doc->document_mode >= COMPAT_MODE_IE9) ? &HTMLGenericElement_dispex : &HTMLUnknownElement_dispex;
+
+        HTMLDOMNode_Init(doc, &This->node, (nsIDOMNode*)nselem, dispex_data);
 
         /* No AddRef, share reference with HTMLDOMNode */
         assert((nsIDOMNode*)nselem == This->node.nsnode);
@@ -7313,6 +8011,8 @@ void HTMLElement_Init(HTMLElement *This, HTMLDocumentNode *doc, nsIDOMElement *n
 
 HRESULT HTMLElement_Create(HTMLDocumentNode *doc, nsIDOMNode *nsnode, BOOL use_generic, HTMLElement **ret)
 {
+    nsIDOMHTMLElement *nshtmlelem;
+    nsIDOMSVGElement *svg_element;
     nsIDOMElement *nselem;
     nsAString tag_name_str;
     const PRUnichar *tag_name;
@@ -7332,17 +8032,32 @@ HRESULT HTMLElement_Create(HTMLDocumentNode *doc, nsIDOMNode *nsnode, BOOL use_g
 
     nsAString_GetData(&tag_name_str, &tag_name);
 
+    /* Check this first, as Gecko treats svg elements as non-HTML */
+    nsres = nsIDOMElement_QueryInterface(nselem, &IID_nsIDOMSVGElement, (void**)&svg_element);
+    if(NS_SUCCEEDED(nsres)) {
+        hres = create_svg_element(doc, svg_element, tag_name, &elem);
+        nsIDOMSVGElement_Release(svg_element);
+        goto done;
+    }
+
+    nsres = nsIDOMElement_QueryInterface(nselem, &IID_nsIDOMHTMLElement, (void**)&nshtmlelem);
+    if(NS_FAILED(nsres)) {
+        if(!(elem = heap_alloc_zero(sizeof(HTMLElement))))
+            hres = E_OUTOFMEMORY;
+        else {
+            elem->node.vtbl = &HTMLElementImplVtbl;
+            HTMLElement_Init(elem, doc, nselem, &DOMElement_dispex);
+            hres = S_OK;
+        }
+        goto done;
+    }
+    nsIDOMHTMLElement_Release(nshtmlelem);
+
     tag = get_tag_desc(tag_name);
     if(tag) {
         hres = tag->constructor(doc, nselem, &elem);
     }else {
-        nsIDOMSVGElement *svg_element;
-
-        nsres = nsIDOMElement_QueryInterface(nselem, &IID_nsIDOMSVGElement, (void**)&svg_element);
-        if(NS_SUCCEEDED(nsres)) {
-            hres = create_svg_element(doc, svg_element, tag_name, &elem);
-            nsIDOMSVGElement_Release(svg_element);
-        }else if(use_generic) {
+        if(use_generic || doc->document_mode >= COMPAT_MODE_IE9) {
             hres = HTMLGenericElement_Create(doc, nselem, &elem);
         }else {
             elem = heap_alloc_zero(sizeof(HTMLElement));
@@ -7356,6 +8071,7 @@ HRESULT HTMLElement_Create(HTMLDocumentNode *doc, nsIDOMNode *nsnode, BOOL use_g
         }
     }
 
+done:
     TRACE("%s ret %p\n", debugstr_w(tag_name), elem);
 
     nsIDOMElement_Release(nselem);
@@ -7530,8 +8246,8 @@ static HRESULT HTMLFiltersCollection_get_dispid(DispatchEx *dispex, BSTR name, D
     return S_OK;
 }
 
-static HRESULT HTMLFiltersCollection_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
-        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+static HRESULT HTMLFiltersCollection_invoke(DispatchEx *dispex, IDispatch *this_obj, DISPID id, LCID lcid, WORD flags,
+        DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
     TRACE("(%p)->(%lx %lx %x %p %p %p)\n", dispex, id, lcid, flags, params, res, ei);
 
@@ -7554,9 +8270,10 @@ static const tid_t HTMLFiltersCollection_iface_tids[] = {
     IHTMLFiltersCollection_tid,
     0
 };
-static dispex_static_data_t HTMLFiltersCollection_dispex = {
+dispex_static_data_t HTMLFiltersCollection_dispex = {
     L"FiltersCollection",
     &HTMLFiltersCollection_dispex_vtbl,
+    PROTO_ID_HTMLFiltersCollection,
     IHTMLFiltersCollection_tid,
     HTMLFiltersCollection_iface_tids
 };
@@ -7572,19 +8289,36 @@ static HRESULT create_filters_collection(compat_mode_t compat_mode, IHTMLFilters
     collection->ref = 1;
 
     init_dispatch(&collection->dispex, (IUnknown*)&collection->IHTMLFiltersCollection_iface,
-                  &HTMLFiltersCollection_dispex, min(compat_mode, COMPAT_MODE_IE8));
+                  &HTMLFiltersCollection_dispex, NULL, min(compat_mode, COMPAT_MODE_IE8));
 
     *ret = &collection->IHTMLFiltersCollection_iface;
     return S_OK;
 }
 
-static HRESULT get_attr_dispid_by_relative_idx(HTMLAttributeCollection *This, LONG *idx, DISPID start, DISPID *dispid)
+static HRESULT get_attr_dispid_by_relative_idx(HTMLAttributeCollection *This, LONG *idx, DISPID start,
+        DISPID *dispid, nsIDOMAttr **nsattr)
 {
     IDispatchEx *dispex = &This->elem->node.event_target.dispex.IDispatchEx_iface;
     DISPID id = start;
+    UINT32 length;
     LONG len = -1;
     HRESULT hres;
 
+    if(This->nsattrs) {
+        id++;
+        if(dispid) {
+            *dispid = id + *idx;
+            if(!nsattr)
+                return S_OK;
+            if(NS_FAILED(nsIDOMMozNamedAttrMap_Item(This->nsattrs, *dispid, nsattr)))
+                return E_FAIL;
+            return *nsattr ? S_OK : DISP_E_UNKNOWNNAME;
+        }
+        nsIDOMMozNamedAttrMap_GetLength(This->nsattrs, &length);
+        *idx = (length > id) ? length - id : 0;
+        return S_OK;
+    }
+
     FIXME("filter non-enumerable attributes out\n");
 
     while(1) {
@@ -7608,13 +8342,15 @@ static HRESULT get_attr_dispid_by_relative_idx(HTMLAttributeCollection *This, LO
     return S_OK;
 }
 
-static HRESULT get_attr_dispid_by_idx(HTMLAttributeCollection *This, LONG *idx, DISPID *dispid)
+static HRESULT get_attr_dispid_by_idx(HTMLAttributeCollection *This, LONG *idx, DISPID *dispid, nsIDOMAttr **nsattr)
 {
-    return get_attr_dispid_by_relative_idx(This, idx, DISPID_STARTENUM, dispid);
+    return get_attr_dispid_by_relative_idx(This, idx, DISPID_STARTENUM, dispid, nsattr);
 }
 
-static inline HRESULT get_attr_dispid_by_name(HTMLAttributeCollection *This, BSTR name, DISPID *id)
+static inline HRESULT get_attr_dispid_by_name(HTMLAttributeCollection *This, BSTR name, DISPID *id, nsIDOMAttr **nsattr)
 {
+    nsAString nsstr;
+    nsresult nsres;
     HRESULT hres;
 
     if(name[0]>='0' && name[0]<='9') {
@@ -7623,12 +8359,21 @@ static inline HRESULT get_attr_dispid_by_name(HTMLAttributeCollection *This, BST
 
         idx = wcstoul(name, &end_ptr, 10);
         if(!*end_ptr) {
-            hres = get_attr_dispid_by_idx(This, &idx, id);
+            hres = get_attr_dispid_by_idx(This, &idx, id, nsattr);
             if(SUCCEEDED(hres))
                 return hres;
         }
     }
 
+    if(This->nsattrs) {
+        nsAString_InitDepend(&nsstr, name);
+        nsres = nsIDOMMozNamedAttrMap_GetNamedItem(This->nsattrs, &nsstr, nsattr);
+        nsAString_Finish(&nsstr);
+        if(NS_FAILED(nsres))
+            return E_FAIL;
+        return *nsattr ? S_OK : DISP_E_UNKNOWNNAME;
+    }
+
     if(!This->elem) {
         WARN("NULL elem\n");
         return E_UNEXPECTED;
@@ -7636,38 +8381,31 @@ static inline HRESULT get_attr_dispid_by_name(HTMLAttributeCollection *This, BST
 
     hres = IDispatchEx_GetDispID(&This->elem->node.event_target.dispex.IDispatchEx_iface,
             name, fdexNameCaseInsensitive, id);
-    return hres;
+    if(FAILED(hres))
+        return hres;
+    return dispex_is_builtin_method(&This->elem->node.event_target.dispex, *id) ? DISP_E_UNKNOWNNAME : S_OK;
 }
 
-static inline HRESULT get_domattr(HTMLAttributeCollection *This, DISPID id, LONG *list_pos, HTMLDOMAttribute **attr)
+static inline HRESULT get_domattr(HTMLAttributeCollection *This, DISPID id, nsIDOMAttr *nsattr,
+        LONG *list_pos, HTMLDOMAttribute **attr)
 {
-    HTMLDOMAttribute *iter;
-    LONG pos = 0;
     HRESULT hres;
 
-    *attr = NULL;
-    LIST_FOR_EACH_ENTRY(iter, &This->attrs, HTMLDOMAttribute, entry) {
-        if(iter->dispid == id) {
-            *attr = iter;
-            break;
-        }
-        pos++;
-    }
-
-    if(!*attr) {
+    if(!(*attr = find_attr_in_list(This, id, nsattr, list_pos))) {
         if(!This->elem) {
             WARN("NULL elem\n");
             return E_UNEXPECTED;
         }
 
-        hres = HTMLDOMAttribute_Create(NULL, This->elem, id, dispex_compat_mode(&This->elem->node.event_target.dispex), attr);
+        if(nsattr)
+            id = get_dispid_for_nsattr(This->elem, nsattr);
+        hres = HTMLDOMAttribute_Create(NULL, This->elem->node.doc, This->elem, id, nsattr,
+                                       dispex_compat_mode(&This->elem->node.event_target.dispex), attr);
         if(FAILED(hres))
             return hres;
     }
 
     IHTMLDOMAttribute_AddRef(&(*attr)->IHTMLDOMAttribute_iface);
-    if(list_pos)
-        *list_pos = pos;
     return S_OK;
 }
 
@@ -7736,6 +8474,7 @@ static HRESULT WINAPI HTMLAttributeCollectionEnum_Next(IEnumVARIANT *iface, ULON
     HTMLAttributeCollectionEnum *This = HTMLAttributeCollectionEnum_from_IEnumVARIANT(iface);
     DISPID tmp, dispid = This->iter_dispid;
     HTMLDOMAttribute *attr;
+    nsIDOMAttr *nsattr;
     LONG rel_index = 0;
     HRESULT hres;
     ULONG i;
@@ -7743,10 +8482,13 @@ static HRESULT WINAPI HTMLAttributeCollectionEnum_Next(IEnumVARIANT *iface, ULON
     TRACE("(%p)->(%lu %p %p)\n", This, celt, rgVar, pCeltFetched);
 
     for(i = 0; i < celt; i++) {
-        hres = get_attr_dispid_by_relative_idx(This->col, &rel_index, dispid, &tmp);
+        nsattr = NULL;
+        hres = get_attr_dispid_by_relative_idx(This->col, &rel_index, dispid, &tmp, &nsattr);
         if(SUCCEEDED(hres)) {
             dispid = tmp;
-            hres = get_domattr(This->col, dispid, NULL, &attr);
+            hres = get_domattr(This->col, dispid, nsattr, NULL, &attr);
+            if(nsattr)
+                nsIDOMAttr_Release(nsattr);
         }
         else if(hres == DISP_E_UNKNOWNNAME)
             break;
@@ -7781,14 +8523,14 @@ static HRESULT WINAPI HTMLAttributeCollectionEnum_Skip(IEnumVARIANT *iface, ULON
         return S_OK;
 
     rel_index = -1;
-    hres = get_attr_dispid_by_relative_idx(This->col, &rel_index, This->iter_dispid, NULL);
+    hres = get_attr_dispid_by_relative_idx(This->col, &rel_index, This->iter_dispid, NULL, NULL);
     if(FAILED(hres))
         return hres;
     remaining = min(celt, rel_index);
 
     if(remaining) {
         rel_index = remaining - 1;
-        hres = get_attr_dispid_by_relative_idx(This->col, &rel_index, This->iter_dispid, &dispid);
+        hres = get_attr_dispid_by_relative_idx(This->col, &rel_index, This->iter_dispid, &dispid, NULL);
         if(FAILED(hres))
             return hres;
         This->iter += remaining;
@@ -7927,7 +8669,7 @@ static HRESULT WINAPI HTMLAttributeCollection_get_length(IHTMLAttributeCollectio
     TRACE("(%p)->(%p)\n", This, p);
 
     *p = -1;
-    hres = get_attr_dispid_by_idx(This, p, NULL);
+    hres = get_attr_dispid_by_idx(This, p, NULL, NULL);
     return hres;
 }
 
@@ -7957,6 +8699,7 @@ static HRESULT WINAPI HTMLAttributeCollection__newEnum(IHTMLAttributeCollection
 static HRESULT WINAPI HTMLAttributeCollection_item(IHTMLAttributeCollection *iface, VARIANT *name, IDispatch **ppItem)
 {
     HTMLAttributeCollection *This = impl_from_IHTMLAttributeCollection(iface);
+    nsIDOMAttr *nsattr = NULL;
     HTMLDOMAttribute *attr;
     DISPID id;
     HRESULT hres;
@@ -7965,10 +8708,10 @@ static HRESULT WINAPI HTMLAttributeCollection_item(IHTMLAttributeCollection *ifa
 
     switch(V_VT(name)) {
     case VT_I4:
-        hres = get_attr_dispid_by_idx(This, &V_I4(name), &id);
+        hres = get_attr_dispid_by_idx(This, &V_I4(name), &id, &nsattr);
         break;
     case VT_BSTR:
-        hres = get_attr_dispid_by_name(This, V_BSTR(name), &id);
+        hres = get_attr_dispid_by_name(This, V_BSTR(name), &id, &nsattr);
         break;
     default:
         FIXME("unsupported name %s\n", debugstr_variant(name));
@@ -7979,7 +8722,9 @@ static HRESULT WINAPI HTMLAttributeCollection_item(IHTMLAttributeCollection *ifa
     if(FAILED(hres))
         return hres;
 
-    hres = get_domattr(This, id, NULL, &attr);
+    hres = get_domattr(This, id, nsattr, NULL, &attr);
+    if(nsattr)
+        nsIDOMAttr_Release(nsattr);
     if(FAILED(hres))
         return hres;
 
@@ -8057,13 +8802,14 @@ static HRESULT WINAPI HTMLAttributeCollection2_getNamedItem(IHTMLAttributeCollec
         IHTMLDOMAttribute **newretNode)
 {
     HTMLAttributeCollection *This = impl_from_IHTMLAttributeCollection2(iface);
+    nsIDOMAttr *nsattr = NULL;
     HTMLDOMAttribute *attr;
     DISPID id;
     HRESULT hres;
 
     TRACE("(%p)->(%s %p)\n", This, debugstr_w(bstrName), newretNode);
 
-    hres = get_attr_dispid_by_name(This, bstrName, &id);
+    hres = get_attr_dispid_by_name(This, bstrName, &id, &nsattr);
     if(hres == DISP_E_UNKNOWNNAME) {
         *newretNode = NULL;
         return S_OK;
@@ -8071,7 +8817,9 @@ static HRESULT WINAPI HTMLAttributeCollection2_getNamedItem(IHTMLAttributeCollec
         return hres;
     }
 
-    hres = get_domattr(This, id, NULL, &attr);
+    hres = get_domattr(This, id, nsattr, NULL, &attr);
+    if(nsattr)
+        nsIDOMAttr_Release(nsattr);
     if(FAILED(hres))
         return hres;
 
@@ -8187,19 +8935,22 @@ static HRESULT WINAPI HTMLAttributeCollection3_removeNamedItem(IHTMLAttributeCol
 static HRESULT WINAPI HTMLAttributeCollection3_item(IHTMLAttributeCollection3 *iface, LONG index, IHTMLDOMAttribute **ppNodeOut)
 {
     HTMLAttributeCollection *This = impl_from_IHTMLAttributeCollection3(iface);
+    nsIDOMAttr *nsattr = NULL;
     HTMLDOMAttribute *attr;
     DISPID id;
     HRESULT hres;
 
     TRACE("(%p)->(%ld %p)\n", This, index, ppNodeOut);
 
-    hres = get_attr_dispid_by_idx(This, &index, &id);
+    hres = get_attr_dispid_by_idx(This, &index, &id, &nsattr);
     if(hres == DISP_E_UNKNOWNNAME)
         return E_INVALIDARG;
     if(FAILED(hres))
         return hres;
 
-    hres = get_domattr(This, id, NULL, &attr);
+    hres = get_domattr(This, id, nsattr, NULL, &attr);
+    if(nsattr)
+        nsIDOMAttr_Release(nsattr);
     if(FAILED(hres))
         return hres;
 
@@ -8236,17 +8987,20 @@ static inline HTMLAttributeCollection *HTMLAttributeCollection_from_DispatchEx(D
 static HRESULT HTMLAttributeCollection_get_dispid(DispatchEx *dispex, BSTR name, DWORD flags, DISPID *dispid)
 {
     HTMLAttributeCollection *This = HTMLAttributeCollection_from_DispatchEx(dispex);
+    nsIDOMAttr *nsattr = NULL;
     HTMLDOMAttribute *attr;
     LONG pos;
     HRESULT hres;
 
     TRACE("(%p)->(%s %lx %p)\n", This, debugstr_w(name), flags, dispid);
 
-    hres = get_attr_dispid_by_name(This, name, dispid);
+    hres = get_attr_dispid_by_name(This, name, dispid, &nsattr);
     if(FAILED(hres))
         return hres;
 
-    hres = get_domattr(This, *dispid, &pos, &attr);
+    hres = get_domattr(This, *dispid, nsattr, &pos, &attr);
+    if(nsattr)
+        nsIDOMAttr_Release(nsattr);
     if(FAILED(hres))
         return hres;
     IHTMLDOMAttribute_Release(&attr->IHTMLDOMAttribute_iface);
@@ -8255,7 +9009,7 @@ static HRESULT HTMLAttributeCollection_get_dispid(DispatchEx *dispex, BSTR name,
     return S_OK;
 }
 
-static HRESULT HTMLAttributeCollection_invoke(DispatchEx *dispex, DISPID id, LCID lcid,
+static HRESULT HTMLAttributeCollection_invoke(DispatchEx *dispex, IDispatch *this_obj, DISPID id, LCID lcid,
         WORD flags, DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
     HTMLAttributeCollection *This = HTMLAttributeCollection_from_DispatchEx(dispex);
@@ -8303,9 +9057,10 @@ static const tid_t HTMLAttributeCollection_iface_tids[] = {
     0
 };
 
-static dispex_static_data_t HTMLAttributeCollection_dispex = {
+dispex_static_data_t HTMLAttributeCollection_dispex = {
     L"NamedNodeMap",
     &HTMLAttributeCollection_dispex_vtbl,
+    PROTO_ID_HTMLAttributeCollection,
     DispHTMLAttributeCollection_tid,
     HTMLAttributeCollection_iface_tids
 };
@@ -8313,6 +9068,7 @@ static dispex_static_data_t HTMLAttributeCollection_dispex = {
 HRESULT HTMLElement_get_attr_col(HTMLDOMNode *iface, HTMLAttributeCollection **ac)
 {
     HTMLElement *This = impl_from_HTMLDOMNode(iface);
+    compat_mode_t compat_mode = dispex_compat_mode(&iface->event_target.dispex);
 
     if(This->attrs) {
         IHTMLAttributeCollection_AddRef(&This->attrs->IHTMLAttributeCollection_iface);
@@ -8332,7 +9088,10 @@ HRESULT HTMLElement_get_attr_col(HTMLDOMNode *iface, HTMLAttributeCollection **a
     This->attrs->elem = This;
     list_init(&This->attrs->attrs);
     init_dispatch(&This->attrs->dispex, (IUnknown*)&This->attrs->IHTMLAttributeCollection_iface,
-                  &HTMLAttributeCollection_dispex, dispex_compat_mode(&iface->event_target.dispex));
+                  &HTMLAttributeCollection_dispex, This->node.doc, compat_mode);
+
+    if(compat_mode >= COMPAT_MODE_IE9 && This->dom_element)
+        nsIDOMElement_GetAttributes(This->dom_element, &This->attrs->nsattrs);
 
     *ac = This->attrs;
     return S_OK;
diff --git a/dlls/mshtml/htmlelemcol.c b/dlls/mshtml/htmlelemcol.c
index 385bd9038b2..619d6a4c590 100644
--- a/dlls/mshtml/htmlelemcol.c
+++ b/dlls/mshtml/htmlelemcol.c
@@ -35,6 +35,7 @@ typedef struct {
     DispatchEx dispex;
     IHTMLElementCollection IHTMLElementCollection_iface;
 
+    HTMLDocumentNode *doc;
     HTMLElement **elems;
     DWORD len;
 
@@ -62,7 +63,7 @@ static inline HTMLElement *elem_from_HTMLDOMNode(HTMLDOMNode *iface)
     return CONTAINING_RECORD(iface, HTMLElement, node);
 }
 
-static IHTMLElementCollection *HTMLElementCollection_Create(HTMLElement**,DWORD,compat_mode_t);
+static IHTMLElementCollection *HTMLElementCollection_Create(HTMLElement**,DWORD,HTMLDocumentNode*);
 
 static void elem_vector_add(elem_vector_t *buf, HTMLElement *elem)
 {
@@ -259,6 +260,7 @@ static ULONG WINAPI HTMLElementCollection_Release(IHTMLElementCollection *iface)
             node_release(&This->elems[i]->node);
         heap_free(This->elems);
 
+        htmldoc_release(&This->doc->basedoc);
         release_dispex(&This->dispex);
         heap_free(This);
     }
@@ -461,8 +463,7 @@ static HRESULT WINAPI HTMLElementCollection_item(IHTMLElementCollection *iface,
 
             if(buf.len > 1) {
                 elem_vector_normalize(&buf);
-                *pdisp = (IDispatch*)HTMLElementCollection_Create(buf.buf, buf.len,
-                                                                  dispex_compat_mode(&This->dispex));
+                *pdisp = (IDispatch*)HTMLElementCollection_Create(buf.buf, buf.len, This->doc);
             }else {
                 if(buf.len == 1) {
                     /* Already AddRef-ed */
@@ -524,8 +525,7 @@ static HRESULT WINAPI HTMLElementCollection_tags(IHTMLElementCollection *iface,
 
     TRACE("found %ld tags\n", buf.len);
 
-    *pdisp = (IDispatch*)HTMLElementCollection_Create(buf.buf, buf.len,
-                                                      dispex_compat_mode(&This->dispex));
+    *pdisp = (IDispatch*)HTMLElementCollection_Create(buf.buf, buf.len, This->doc);
     return S_OK;
 }
 
@@ -581,8 +581,8 @@ static HRESULT HTMLElementCollection_get_dispid(DispatchEx *dispex, BSTR name, D
     return S_OK;
 }
 
-static HRESULT HTMLElementCollection_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
-        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+static HRESULT HTMLElementCollection_invoke(DispatchEx *dispex, IDispatch *this_obj, DISPID id, LCID lcid, WORD flags,
+        DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
     HTMLElementCollection *This = impl_from_DispatchEx(dispex);
     DWORD idx;
@@ -619,9 +619,10 @@ static const tid_t HTMLElementCollection_iface_tids[] = {
     0
 };
 
-static dispex_static_data_t HTMLElementCollection_dispex = {
+dispex_static_data_t HTMLElementCollection_dispex = {
     L"HTMLCollection",
     &HTMLElementColection_dispex_vtbl,
+    PROTO_ID_HTMLElementCollection,
     DispHTMLElementCollection_tid,
     HTMLElementCollection_iface_tids
 };
@@ -679,11 +680,10 @@ IHTMLElementCollection *create_all_collection(HTMLDOMNode *node, BOOL include_ro
     create_all_list(node, &buf);
     elem_vector_normalize(&buf);
 
-    return HTMLElementCollection_Create(buf.buf, buf.len,
-                                        dispex_compat_mode(&node->event_target.dispex));
+    return HTMLElementCollection_Create(buf.buf, buf.len, node->doc);
 }
 
-IHTMLElementCollection *create_collection_from_nodelist(nsIDOMNodeList *nslist, compat_mode_t compat_mode)
+IHTMLElementCollection *create_collection_from_nodelist(nsIDOMNodeList *nslist, HTMLDocumentNode *doc)
 {
     UINT32 length = 0, i;
     HTMLDOMNode *node;
@@ -715,10 +715,10 @@ IHTMLElementCollection *create_collection_from_nodelist(nsIDOMNodeList *nslist,
         buf.buf = NULL;
     }
 
-    return HTMLElementCollection_Create(buf.buf, buf.len, compat_mode);
+    return HTMLElementCollection_Create(buf.buf, buf.len, doc);
 }
 
-IHTMLElementCollection *create_collection_from_htmlcol(nsIDOMHTMLCollection *nscol, compat_mode_t compat_mode)
+IHTMLElementCollection *create_collection_from_htmlcol(nsIDOMHTMLCollection *nscol, HTMLDocumentNode *doc)
 {
     UINT32 length = 0, i;
     elem_vector_t buf;
@@ -751,7 +751,7 @@ IHTMLElementCollection *create_collection_from_htmlcol(nsIDOMHTMLCollection *nsc
         return NULL;
     }
 
-    return HTMLElementCollection_Create(buf.buf, buf.len, compat_mode);
+    return HTMLElementCollection_Create(buf.buf, buf.len, doc);
 }
 
 HRESULT get_elem_source_index(HTMLElement *elem, LONG *ret)
@@ -823,8 +823,9 @@ HRESULT get_elem_source_index(HTMLElement *elem, LONG *ret)
 }
 
 static IHTMLElementCollection *HTMLElementCollection_Create(HTMLElement **elems, DWORD len,
-                                                            compat_mode_t compat_mode)
+                                                            HTMLDocumentNode *doc)
 {
+    compat_mode_t compat_mode = doc ? dispex_compat_mode(&doc->node.event_target.dispex) : COMPAT_MODE_NONE;
     HTMLElementCollection *ret = heap_alloc_zero(sizeof(HTMLElementCollection));
 
     if (!ret)
@@ -834,9 +835,12 @@ static IHTMLElementCollection *HTMLElementCollection_Create(HTMLElement **elems,
     ret->ref = 1;
     ret->elems = elems;
     ret->len = len;
+    ret->doc = doc;
+    if(doc)
+        htmldoc_addref(&doc->basedoc);
 
     init_dispatch(&ret->dispex, (IUnknown*)&ret->IHTMLElementCollection_iface,
-                  &HTMLElementCollection_dispex, compat_mode);
+                  &HTMLElementCollection_dispex, doc, compat_mode);
 
     TRACE("ret=%p len=%ld\n", ret, len);
 
diff --git a/dlls/mshtml/htmlevent.c b/dlls/mshtml/htmlevent.c
index fe3433692f3..f4f1d4e3a0e 100644
--- a/dlls/mshtml/htmlevent.c
+++ b/dlls/mshtml/htmlevent.c
@@ -146,6 +146,8 @@ static const event_info_t event_info[] = {
         EVENT_BUBBLES | EVENT_CANCELABLE},
     {L"input",             EVENT_TYPE_EVENT,     DISPID_UNKNOWN,
         EVENT_DEFAULTLISTENER | EVENT_BUBBLES},
+    {L"invalid",           EVENT_TYPE_EVENT,     DISPID_EVPROP_INVALID,
+        EVENT_BIND_TO_TARGET | EVENT_CANCELABLE},
     {L"keydown",           EVENT_TYPE_KEYBOARD,  DISPID_EVMETH_ONKEYDOWN,
         EVENT_DEFAULTLISTENER | EVENT_HASDEFAULTHANDLERS | EVENT_BUBBLES | EVENT_CANCELABLE },
     {L"keypress",          EVENT_TYPE_KEYBOARD,  DISPID_EVMETH_ONKEYPRESS,
@@ -749,14 +751,15 @@ static const tid_t HTMLEventObj_iface_tids[] = {
     0
 };
 
-static dispex_static_data_t HTMLEventObj_dispex = {
+dispex_static_data_t HTMLEventObj_dispex = {
     L"MSEventObj",
     NULL,
+    PROTO_ID_HTMLEventObj,
     DispCEventObj_tid,
     HTMLEventObj_iface_tids
 };
 
-static HTMLEventObj *alloc_event_obj(DOMEvent *event, compat_mode_t compat_mode)
+static HTMLEventObj *alloc_event_obj(DOMEvent *event, HTMLDocumentNode *doc, compat_mode_t compat_mode)
 {
     HTMLEventObj *event_obj;
 
@@ -770,15 +773,15 @@ static HTMLEventObj *alloc_event_obj(DOMEvent *event, compat_mode_t compat_mode)
     if(event)
         IDOMEvent_AddRef(&event->IDOMEvent_iface);
 
-    init_dispatch(&event_obj->dispex, (IUnknown*)&event_obj->IHTMLEventObj_iface, &HTMLEventObj_dispex, compat_mode);
+    init_dispatch(&event_obj->dispex, (IUnknown*)&event_obj->IHTMLEventObj_iface, &HTMLEventObj_dispex, doc, compat_mode);
     return event_obj;
 }
 
-HRESULT create_event_obj(compat_mode_t compat_mode, IHTMLEventObj **ret)
+HRESULT create_event_obj(HTMLDocumentNode *doc, IHTMLEventObj **ret)
 {
     HTMLEventObj *event_obj;
 
-    event_obj = alloc_event_obj(NULL, compat_mode);
+    event_obj = alloc_event_obj(NULL, doc, dispex_compat_mode(&doc->node.event_target.dispex));
     if(!event_obj)
         return E_OUTOFMEMORY;
 
@@ -854,6 +857,7 @@ static ULONG WINAPI DOMEvent_Release(IDOMEvent *iface)
             nsIDOMKeyEvent_Release(This->keyboard_event);
         if(This->target)
             IEventTarget_Release(&This->target->IEventTarget_iface);
+        htmldoc_release(&This->doc->basedoc);
         nsIDOMEvent_Release(This->nsevent);
         release_dispex(&This->dispex);
         heap_free(This->type);
@@ -2004,8 +2008,11 @@ static HRESULT WINAPI DOMKeyboardEvent_get_char(IDOMKeyboardEvent *iface, VARIAN
 static HRESULT WINAPI DOMKeyboardEvent_get_locale(IDOMKeyboardEvent *iface, BSTR *p)
 {
     DOMEvent *This = impl_from_IDOMKeyboardEvent(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
+
+    FIXME("(%p)->(%p) semi-stub\n", This, p);
+
+    *p = SysAllocString(L"");
+    return *p ? S_OK : E_OUTOFMEMORY;
 }
 
 static const IDOMKeyboardEventVtbl DOMKeyboardEventVtbl = {
@@ -2150,7 +2157,7 @@ static void DOMCustomEvent_destroy(DOMEvent *event)
 typedef struct {
     DOMEvent event;
     IDOMMessageEvent IDOMMessageEvent_iface;
-    WCHAR *data;
+    VARIANT data;
 } DOMMessageEvent;
 
 static inline DOMMessageEvent *impl_from_IDOMMessageEvent(IDOMMessageEvent *iface)
@@ -2212,7 +2219,26 @@ static HRESULT WINAPI DOMMessageEvent_get_data(IDOMMessageEvent *iface, BSTR *p)
 
     TRACE("(%p)->(%p)\n", This, p);
 
-    return (*p = SysAllocString(This->data)) ? S_OK : E_OUTOFMEMORY;
+    if(V_VT(&This->data) != VT_BSTR) {
+        FIXME("non-string data\n");
+        return E_NOTIMPL;
+    }
+
+    return (*p = SysAllocString(V_BSTR(&This->data))) ? S_OK : E_OUTOFMEMORY;
+}
+
+static HRESULT DOMMessageEvent_get_data_hook(DispatchEx *dispex, WORD flags, DISPPARAMS *dp, VARIANT *res,
+        EXCEPINFO *ei, IServiceProvider *caller)
+{
+    DOMMessageEvent *This = CONTAINING_RECORD(dispex, DOMMessageEvent, event.dispex);
+
+    if(!(flags & DISPATCH_PROPERTYGET) || !res)
+        return S_FALSE;
+
+    TRACE("(%p)->(%p)\n", This, res);
+
+    V_VT(res) = VT_EMPTY;
+    return VariantCopy(res, &This->data);
 }
 
 static HRESULT WINAPI DOMMessageEvent_get_origin(IDOMMessageEvent *iface, BSTR *p)
@@ -2269,7 +2295,16 @@ static void *DOMMessageEvent_query_interface(DOMEvent *event, REFIID riid)
 static void DOMMessageEvent_destroy(DOMEvent *event)
 {
     DOMMessageEvent *message_event = DOMMessageEvent_from_DOMEvent(event);
-    heap_free(message_event->data);
+    VariantClear(&message_event->data);
+}
+
+static void DOMMessageEvent_init_dispex_info(dispex_data_t *info, compat_mode_t compat_mode)
+{
+    static const dispex_hook_t hooks[] = {
+        {DISPID_IDOMMESSAGEEVENT_DATA, DOMMessageEvent_get_data_hook},
+        {DISPID_UNKNOWN}
+    };
+    dispex_info_add_interface(info, IDOMMessageEvent_tid, compat_mode >= COMPAT_MODE_IE10 ? hooks : NULL);
 }
 
 static const tid_t DOMEvent_iface_tids[] = {
@@ -2277,9 +2312,10 @@ static const tid_t DOMEvent_iface_tids[] = {
     0
 };
 
-static dispex_static_data_t DOMEvent_dispex = {
+dispex_static_data_t DOMEvent_dispex = {
     L"Event",
     NULL,
+    PROTO_ID_DOMEvent,
     DispDOMEvent_tid,
     DOMEvent_iface_tids
 };
@@ -2290,9 +2326,10 @@ static const tid_t DOMUIEvent_iface_tids[] = {
     0
 };
 
-static dispex_static_data_t DOMUIEvent_dispex = {
+dispex_static_data_t DOMUIEvent_dispex = {
     L"UIEvent",
     NULL,
+    PROTO_ID_DOMUIEvent,
     DispDOMUIEvent_tid,
     DOMUIEvent_iface_tids
 };
@@ -2304,9 +2341,10 @@ static const tid_t DOMMouseEvent_iface_tids[] = {
     0
 };
 
-static dispex_static_data_t DOMMouseEvent_dispex = {
+dispex_static_data_t DOMMouseEvent_dispex = {
     L"MouseEvent",
     NULL,
+    PROTO_ID_DOMMouseEvent,
     DispDOMMouseEvent_tid,
     DOMMouseEvent_iface_tids
 };
@@ -2318,9 +2356,10 @@ static const tid_t DOMKeyboardEvent_iface_tids[] = {
     0
 };
 
-static dispex_static_data_t DOMKeyboardEvent_dispex = {
+dispex_static_data_t DOMKeyboardEvent_dispex = {
     L"KeyboardEvent",
     NULL,
+    PROTO_ID_DOMKeyboardEvent,
     DispDOMKeyboardEvent_tid,
     DOMKeyboardEvent_iface_tids
 };
@@ -2331,24 +2370,26 @@ static const tid_t DOMCustomEvent_iface_tids[] = {
     0
 };
 
-static dispex_static_data_t DOMCustomEvent_dispex = {
+dispex_static_data_t DOMCustomEvent_dispex = {
     L"CustomEvent",
     NULL,
+    PROTO_ID_DOMCustomEvent,
     DispDOMCustomEvent_tid,
     DOMCustomEvent_iface_tids
 };
 
 static const tid_t DOMMessageEvent_iface_tids[] = {
     IDOMEvent_tid,
-    IDOMMessageEvent_tid,
     0
 };
 
 dispex_static_data_t DOMMessageEvent_dispex = {
     L"MessageEvent",
     NULL,
+    PROTO_ID_DOMMessageEvent,
     DispDOMMessageEvent_tid,
-    DOMMessageEvent_iface_tids
+    DOMMessageEvent_iface_tids,
+    DOMMessageEvent_init_dispex_info
 };
 
 static BOOL check_event_iface(nsIDOMEvent *event, REFIID riid)
@@ -2364,7 +2405,8 @@ static BOOL check_event_iface(nsIDOMEvent *event, REFIID riid)
     return TRUE;
 }
 
-static DOMEvent *alloc_event(nsIDOMEvent *nsevent, compat_mode_t compat_mode, eventid_t event_id)
+static DOMEvent *alloc_event(nsIDOMEvent *nsevent, HTMLDocumentNode *doc, compat_mode_t compat_mode,
+        eventid_t event_id)
 {
     dispex_static_data_t *dispex_data = &DOMEvent_dispex;
     DOMEvent *event = NULL;
@@ -2401,6 +2443,10 @@ static DOMEvent *alloc_event(nsIDOMEvent *nsevent, compat_mode_t compat_mode, ev
     event->IDOMMouseEvent_iface.lpVtbl = &DOMMouseEventVtbl;
     event->IDOMKeyboardEvent_iface.lpVtbl = &DOMKeyboardEventVtbl;
     event->ref = 1;
+    event->doc = doc;
+    if(doc)
+        htmldoc_addref(&doc->basedoc);
+
     event->event_id = event_id;
     if(event_id != EVENTID_LAST) {
         event->type = heap_strdupW(event_info[event_id].name);
@@ -2433,11 +2479,12 @@ static DOMEvent *alloc_event(nsIDOMEvent *nsevent, compat_mode_t compat_mode, ev
     else
         event->keyboard_event = NULL;
 
-    init_dispatch(&event->dispex, (IUnknown*)&event->IDOMEvent_iface, dispex_data, compat_mode);
+    init_dispatch(&event->dispex, (IUnknown*)&event->IDOMEvent_iface, dispex_data, NULL, compat_mode);
     return event;
 }
 
-HRESULT create_event_from_nsevent(nsIDOMEvent *nsevent, compat_mode_t compat_mode, DOMEvent **ret_event)
+HRESULT create_event_from_nsevent(nsIDOMEvent *nsevent, HTMLDocumentNode *doc, compat_mode_t compat_mode,
+        DOMEvent **ret_event)
 {
     eventid_t event_id = EVENTID_LAST;
     DOMEvent *event;
@@ -2457,7 +2504,7 @@ HRESULT create_event_from_nsevent(nsIDOMEvent *nsevent, compat_mode_t compat_mod
     }
     nsAString_Finish(&nsstr);
 
-    event = alloc_event(nsevent, compat_mode, event_id);
+    event = alloc_event(nsevent, doc, compat_mode, event_id);
     if(!event)
         return E_OUTOFMEMORY;
 
@@ -2474,14 +2521,14 @@ HRESULT create_document_event_str(HTMLDocumentNode *doc, const WCHAR *type, IDOM
     nsresult nsres;
 
     nsAString_InitDepend(&nsstr, type);
-    nsres = nsIDOMHTMLDocument_CreateEvent(doc->nsdoc, &nsstr, &nsevent);
+    nsres = nsIDOMDocument_CreateEvent(doc->nsdoc, &nsstr, &nsevent);
     nsAString_Finish(&nsstr);
     if(NS_FAILED(nsres)) {
         FIXME("CreateEvent(%s) failed: %08lx\n", debugstr_w(type), nsres);
         return E_FAIL;
     }
 
-    event = alloc_event(nsevent, dispex_compat_mode(&doc->node.event_target.dispex), EVENTID_LAST);
+    event = alloc_event(nsevent, doc, dispex_compat_mode(&doc->node.event_target.dispex), EVENTID_LAST);
     nsIDOMEvent_Release(nsevent);
     if(!event)
         return E_OUTOFMEMORY;
@@ -2498,14 +2545,14 @@ HRESULT create_document_event(HTMLDocumentNode *doc, eventid_t event_id, DOMEven
     nsresult nsres;
 
     nsAString_InitDepend(&nsstr, event_types[event_info[event_id].type]);
-    nsres = nsIDOMHTMLDocument_CreateEvent(doc->nsdoc, &nsstr, &nsevent);
+    nsres = nsIDOMDocument_CreateEvent(doc->nsdoc, &nsstr, &nsevent);
     nsAString_Finish(&nsstr);
     if(NS_FAILED(nsres)) {
         FIXME("CreateEvent(%s) failed: %08lx\n", debugstr_w(event_types[event_info[event_id].type]), nsres);
         return E_FAIL;
     }
 
-    event = alloc_event(nsevent, doc->document_mode, event_id);
+    event = alloc_event(nsevent, doc, doc->document_mode, event_id);
     if(!event)
         return E_OUTOFMEMORY;
 
@@ -2515,7 +2562,7 @@ HRESULT create_document_event(HTMLDocumentNode *doc, eventid_t event_id, DOMEven
     return S_OK;
 }
 
-HRESULT create_message_event(HTMLDocumentNode *doc, BSTR data, DOMEvent **ret)
+HRESULT create_message_event(HTMLDocumentNode *doc, VARIANT *data, DOMEvent **ret)
 {
     DOMMessageEvent *message_event;
     DOMEvent *event;
@@ -2526,9 +2573,11 @@ HRESULT create_message_event(HTMLDocumentNode *doc, BSTR data, DOMEvent **ret)
         return hres;
     message_event = DOMMessageEvent_from_DOMEvent(event);
 
-    if(!(message_event->data = heap_strdupW(data))) {
+    V_VT(&message_event->data) = VT_EMPTY;
+    hres = VariantCopy(&message_event->data, data);
+    if(FAILED(hres)) {
         IDOMEvent_Release(&event->IDOMEvent_iface);
-        return E_OUTOFMEMORY;
+        return hres;
     }
 
     *ret = event;
@@ -2871,7 +2920,7 @@ static HRESULT dispatch_event_object(EventTarget *event_target, DOMEvent *event,
     } while(iter);
 
     if(!event->event_obj && !event->no_event_obj) {
-        event_obj_ref = alloc_event_obj(event, dispex_compat_mode(&event->dispex));
+        event_obj_ref = alloc_event_obj(event, event->doc, dispex_compat_mode(&event->dispex));
         if(event_obj_ref)
             event->event_obj = &event_obj_ref->IHTMLEventObj_iface;
     }
@@ -2989,7 +3038,7 @@ HRESULT fire_event(HTMLDOMNode *node, const WCHAR *event_name, VARIANT *event_va
     }
 
     if(!event_obj) {
-        event_obj = alloc_event_obj(NULL, dispex_compat_mode(&node->event_target.dispex));
+        event_obj = alloc_event_obj(NULL, node->doc, dispex_compat_mode(&node->event_target.dispex));
         if(!event_obj)
             return E_OUTOFMEMORY;
     }
@@ -3453,6 +3502,9 @@ static HRESULT WINAPI EventTarget_addEventListener(IEventTarget *iface, BSTR typ
 
     TRACE("(%p)->(%s %p %x)\n", This, debugstr_w(type), function, capture);
 
+    if(!function)
+        return S_OK;
+
     container = get_listener_container(This, type, TRUE);
     if(!container)
         return E_OUTOFMEMORY;
@@ -3614,9 +3666,9 @@ static int event_id_cmp(const void *key, const struct wine_rb_entry *entry)
 }
 
 void EventTarget_Init(EventTarget *event_target, IUnknown *outer, dispex_static_data_t *dispex_data,
-                      compat_mode_t compat_mode)
+                      HTMLDocumentNode *doc)
 {
-    init_dispatch(&event_target->dispex, outer, dispex_data, compat_mode);
+    init_dispatch(&event_target->dispex, outer, dispex_data, doc, doc ? doc->document_mode : COMPAT_MODE_NONE);
     event_target->IEventTarget_iface.lpVtbl = &EventTargetVtbl;
     wine_rb_init(&event_target->handler_map, event_id_cmp);
 }
diff --git a/dlls/mshtml/htmlevent.h b/dlls/mshtml/htmlevent.h
index 7f62bd69a7f..8011c25e234 100644
--- a/dlls/mshtml/htmlevent.h
+++ b/dlls/mshtml/htmlevent.h
@@ -37,6 +37,7 @@ typedef enum {
     EVENTID_FOCUSOUT,
     EVENTID_HELP,
     EVENTID_INPUT,
+    EVENTID_INVALID,
     EVENTID_KEYDOWN,
     EVENTID_KEYPRESS,
     EVENTID_KEYUP,
@@ -71,6 +72,7 @@ typedef struct DOMEvent {
     void *(*query_interface)(struct DOMEvent*,REFIID);
     void (*destroy)(struct DOMEvent*);
 
+    HTMLDocumentNode *doc;
     nsIDOMEvent *nsevent;
     nsIDOMUIEvent *ui_event;
     nsIDOMMouseEvent *mouse_event;
@@ -103,7 +105,7 @@ HRESULT fire_event(HTMLDOMNode*,const WCHAR*,VARIANT*,VARIANT_BOOL*) DECLSPEC_HI
 void update_doc_cp_events(HTMLDocumentNode*,cp_static_data_t*) DECLSPEC_HIDDEN;
 HRESULT doc_init_events(HTMLDocumentNode*) DECLSPEC_HIDDEN;
 void detach_events(HTMLDocumentNode *doc) DECLSPEC_HIDDEN;
-HRESULT create_event_obj(compat_mode_t,IHTMLEventObj**) DECLSPEC_HIDDEN;
+HRESULT create_event_obj(HTMLDocumentNode*,IHTMLEventObj**) DECLSPEC_HIDDEN;
 void bind_target_event(HTMLDocumentNode*,EventTarget*,const WCHAR*,IDispatch*) DECLSPEC_HIDDEN;
 HRESULT ensure_doc_nsevent_handler(HTMLDocumentNode*,nsIDOMNode*,eventid_t) DECLSPEC_HIDDEN;
 
@@ -111,8 +113,8 @@ void dispatch_event(EventTarget*,DOMEvent*) DECLSPEC_HIDDEN;
 
 HRESULT create_document_event(HTMLDocumentNode*,eventid_t,DOMEvent**) DECLSPEC_HIDDEN;
 HRESULT create_document_event_str(HTMLDocumentNode*,const WCHAR*,IDOMEvent**) DECLSPEC_HIDDEN;
-HRESULT create_event_from_nsevent(nsIDOMEvent*,compat_mode_t,DOMEvent**) DECLSPEC_HIDDEN;
-HRESULT create_message_event(HTMLDocumentNode*,BSTR,DOMEvent**) DECLSPEC_HIDDEN;
+HRESULT create_event_from_nsevent(nsIDOMEvent*,HTMLDocumentNode*,compat_mode_t,DOMEvent**) DECLSPEC_HIDDEN;
+HRESULT create_message_event(HTMLDocumentNode*,VARIANT*,DOMEvent**) DECLSPEC_HIDDEN;
 
 void init_nsevents(HTMLDocumentNode*) DECLSPEC_HIDDEN;
 void release_nsevents(HTMLDocumentNode*) DECLSPEC_HIDDEN;
diff --git a/dlls/mshtml/htmlform.c b/dlls/mshtml/htmlform.c
index 18b56ae54a8..a55bb356a7d 100644
--- a/dlls/mshtml/htmlform.c
+++ b/dlls/mshtml/htmlform.c
@@ -37,6 +37,7 @@ struct HTMLFormElement {
     HTMLElement element;
 
     IHTMLFormElement IHTMLFormElement_iface;
+    IWineHTMLFormPrivate IWineHTMLFormPrivate_iface;
 
     nsIDOMHTMLFormElement *nsform;
 };
@@ -452,7 +453,7 @@ static HRESULT WINAPI HTMLFormElement_get_elements(IHTMLFormElement *iface, IDis
         return E_FAIL;
     }
 
-    *p = (IDispatch*)create_collection_from_htmlcol(elements, dispex_compat_mode(&This->element.node.event_target.dispex));
+    *p = (IDispatch*)create_collection_from_htmlcol(elements, This->element.node.doc);
     nsIDOMHTMLCollection_Release(elements);
     return S_OK;
 }
@@ -768,6 +769,115 @@ static const IHTMLFormElementVtbl HTMLFormElementVtbl = {
     HTMLFormElement_tags
 };
 
+static inline HTMLFormElement *impl_from_IWineHTMLFormPrivateVtbl(IWineHTMLFormPrivate *iface)
+{
+    return CONTAINING_RECORD(iface, HTMLFormElement, IWineHTMLFormPrivate_iface);
+}
+
+static HRESULT WINAPI HTMLFormElement_private_QueryInterface(IWineHTMLFormPrivate *iface,
+        REFIID riid, void **ppv)
+{
+    HTMLFormElement *This = impl_from_IWineHTMLFormPrivateVtbl(iface);
+
+    return IHTMLDOMNode_QueryInterface(&This->element.node.IHTMLDOMNode_iface, riid, ppv);
+}
+
+static ULONG WINAPI HTMLFormElement_private_AddRef(IWineHTMLFormPrivate *iface)
+{
+    HTMLFormElement *This = impl_from_IWineHTMLFormPrivateVtbl(iface);
+
+    return IHTMLDOMNode_AddRef(&This->element.node.IHTMLDOMNode_iface);
+}
+
+static ULONG WINAPI HTMLFormElement_private_Release(IWineHTMLFormPrivate *iface)
+{
+    HTMLFormElement *This = impl_from_IWineHTMLFormPrivateVtbl(iface);
+
+    return IHTMLDOMNode_Release(&This->element.node.IHTMLDOMNode_iface);
+}
+
+static HRESULT WINAPI HTMLFormElement_private_GetTypeInfoCount(IWineHTMLFormPrivate *iface, UINT *pctinfo)
+{
+    HTMLFormElement *This = impl_from_IWineHTMLFormPrivateVtbl(iface);
+    return IDispatchEx_GetTypeInfoCount(&This->element.node.event_target.dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI HTMLFormElement_private_GetTypeInfo(IWineHTMLFormPrivate *iface, UINT iTInfo,
+                                              LCID lcid, ITypeInfo **ppTInfo)
+{
+    HTMLFormElement *This = impl_from_IWineHTMLFormPrivateVtbl(iface);
+    return IDispatchEx_GetTypeInfo(&This->element.node.event_target.dispex.IDispatchEx_iface, iTInfo, lcid,
+            ppTInfo);
+}
+
+static HRESULT WINAPI HTMLFormElement_private_GetIDsOfNames(IWineHTMLFormPrivate *iface, REFIID riid,
+                                                LPOLESTR *rgszNames, UINT cNames,
+                                                LCID lcid, DISPID *rgDispId)
+{
+    HTMLFormElement *This = impl_from_IWineHTMLFormPrivateVtbl(iface);
+    return IDispatchEx_GetIDsOfNames(&This->element.node.event_target.dispex.IDispatchEx_iface, riid, rgszNames,
+            cNames, lcid, rgDispId);
+}
+
+static HRESULT WINAPI HTMLFormElement_private_Invoke(IWineHTMLFormPrivate *iface, DISPID dispIdMember,
+                            REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+                            VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    HTMLFormElement *This = impl_from_IWineHTMLFormPrivateVtbl(iface);
+    return IDispatchEx_Invoke(&This->element.node.event_target.dispex.IDispatchEx_iface, dispIdMember, riid,
+            lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI HTMLFormElement_private_put_enctype(IWineHTMLFormPrivate *iface, BSTR v)
+{
+    HTMLFormElement *This = impl_from_IWineHTMLFormPrivateVtbl(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLFormElement_private_get_enctype(IWineHTMLFormPrivate *iface, BSTR *ret)
+{
+    HTMLFormElement *This = impl_from_IWineHTMLFormPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLFormElement_private_put_noValidate(IWineHTMLFormPrivate *iface, VARIANT_BOOL v)
+{
+    HTMLFormElement *This = impl_from_IWineHTMLFormPrivateVtbl(iface);
+    FIXME("(%p)->(%x)\n", This, v);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLFormElement_private_get_noValidate(IWineHTMLFormPrivate *iface, VARIANT_BOOL *ret)
+{
+    HTMLFormElement *This = impl_from_IWineHTMLFormPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLFormElement_private_checkValidity(IWineHTMLFormPrivate *iface, VARIANT_BOOL *ret)
+{
+    HTMLFormElement *This = impl_from_IWineHTMLFormPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static const IWineHTMLFormPrivateVtbl WineHTMLFormPrivateVtbl = {
+    HTMLFormElement_private_QueryInterface,
+    HTMLFormElement_private_AddRef,
+    HTMLFormElement_private_Release,
+    HTMLFormElement_private_GetTypeInfoCount,
+    HTMLFormElement_private_GetTypeInfo,
+    HTMLFormElement_private_GetIDsOfNames,
+    HTMLFormElement_private_Invoke,
+    HTMLFormElement_private_put_enctype,
+    HTMLFormElement_private_get_enctype,
+    HTMLFormElement_private_put_noValidate,
+    HTMLFormElement_private_get_noValidate,
+    HTMLFormElement_private_checkValidity,
+};
+
 static inline HTMLFormElement *impl_from_HTMLDOMNode(HTMLDOMNode *iface)
 {
     return CONTAINING_RECORD(iface, HTMLFormElement, element.node);
@@ -788,6 +898,9 @@ static HRESULT HTMLFormElement_QI(HTMLDOMNode *iface, REFIID riid, void **ppv)
     }else if(IsEqualGUID(&IID_IHTMLFormElement, riid)) {
         TRACE("(%p)->(IID_IHTMLFormElement %p)\n", This, ppv);
         *ppv = &This->IHTMLFormElement_iface;
+    }else if(IsEqualGUID(&IID_IWineHTMLFormPrivate, riid)) {
+        TRACE("(%p)->(IID_IWineHTMLFormPrivate %p)\n", This, ppv);
+        *ppv = &This->IWineHTMLFormPrivate_iface;
     }else if(IsEqualGUID(&DIID_DispHTMLFormElement, riid)) {
         TRACE("(%p)->(DIID_DispHTMLFormElement %p)\n", This, ppv);
         *ppv = &This->IHTMLFormElement_iface;
@@ -898,7 +1011,7 @@ static HRESULT HTMLFormElement_get_dispid(HTMLDOMNode *iface,
     return hres;
 }
 
-static HRESULT HTMLFormElement_invoke(HTMLDOMNode *iface,
+static HRESULT HTMLFormElement_invoke(HTMLDOMNode *iface, IDispatch *this_obj,
         DISPID id, LCID lcid, WORD flags, DISPPARAMS *params, VARIANT *res,
         EXCEPINFO *ei, IServiceProvider *caller)
 {
@@ -973,18 +1086,32 @@ static const NodeImplVtbl HTMLFormElementImplVtbl = {
     HTMLFormElement_unlink
 };
 
+static void HTMLFormElement_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
+{
+    static const dispex_hook_t form_private_ie9_hooks[] = {
+        {DISPID_IWINEHTMLFORMPRIVATE_NOVALIDATE},
+        {DISPID_IWINEHTMLFORMPRIVATE_CHECKVALIDITY},
+        {DISPID_UNKNOWN}
+    };
+    HTMLElement_init_dispex_info(info, mode);
+
+    if(mode >= COMPAT_MODE_IE9)
+        dispex_info_add_interface(info, IWineHTMLFormPrivate_tid, mode < COMPAT_MODE_IE10 ? form_private_ie9_hooks : NULL);
+}
+
 static const tid_t HTMLFormElement_iface_tids[] = {
     HTMLELEMENT_TIDS,
     IHTMLFormElement_tid,
     0
 };
 
-static dispex_static_data_t HTMLFormElement_dispex = {
+dispex_static_data_t HTMLFormElement_dispex = {
     L"HTMLFormElement",
     NULL,
+    PROTO_ID_HTMLFormElement,
     DispHTMLFormElement_tid,
     HTMLFormElement_iface_tids,
-    HTMLElement_init_dispex_info
+    HTMLFormElement_init_dispex_info
 };
 
 HRESULT HTMLFormElement_Create(HTMLDocumentNode *doc, nsIDOMElement *nselem, HTMLElement **elem)
@@ -997,6 +1124,7 @@ HRESULT HTMLFormElement_Create(HTMLDocumentNode *doc, nsIDOMElement *nselem, HTM
         return E_OUTOFMEMORY;
 
     ret->IHTMLFormElement_iface.lpVtbl = &HTMLFormElementVtbl;
+    ret->IWineHTMLFormPrivate_iface.lpVtbl = &WineHTMLFormPrivateVtbl;
     ret->element.node.vtbl = &HTMLFormElementImplVtbl;
 
     HTMLElement_Init(&ret->element, doc, nselem, &HTMLFormElement_dispex);
diff --git a/dlls/mshtml/htmlframe.c b/dlls/mshtml/htmlframe.c
index 7a49e60bf8f..8c3733c9e81 100644
--- a/dlls/mshtml/htmlframe.c
+++ b/dlls/mshtml/htmlframe.c
@@ -942,7 +942,7 @@ static HRESULT HTMLFrameElement_get_dispid(HTMLDOMNode *iface, BSTR name,
     return search_window_props(This->framebase.content_window->base.inner_window, name, grfdex, pid);
 }
 
-static HRESULT HTMLFrameElement_invoke(HTMLDOMNode *iface, DISPID id, LCID lcid,
+static HRESULT HTMLFrameElement_invoke(HTMLDOMNode *iface, IDispatch *this_obj, DISPID id, LCID lcid,
         WORD flags, DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
     HTMLFrameElement *This = frame_from_HTMLDOMNode(iface);
@@ -952,8 +952,8 @@ static HRESULT HTMLFrameElement_invoke(HTMLDOMNode *iface, DISPID id, LCID lcid,
         return E_FAIL;
     }
 
-    return IDispatchEx_InvokeEx(&This->framebase.content_window->base.IDispatchEx_iface, id, lcid,
-            flags, params, res, ei, caller);
+    return dispex_invoke(&This->framebase.content_window->base.inner_window->event_target.dispex,
+                         this_obj, id, lcid, flags, params, res, ei, caller);
 }
 
 static HRESULT HTMLFrameElement_bind_to_tree(HTMLDOMNode *iface)
@@ -1022,9 +1022,10 @@ static const tid_t HTMLFrameElement_iface_tids[] = {
     0
 };
 
-static dispex_static_data_t HTMLFrameElement_dispex = {
+dispex_static_data_t HTMLFrameElement_dispex = {
     L"HTMLFrameElement",
     NULL,
+    PROTO_ID_HTMLFrameElement,
     DispHTMLFrameElement_tid,
     HTMLFrameElement_iface_tids,
     HTMLElement_init_dispex_info
@@ -1514,7 +1515,7 @@ static HRESULT HTMLIFrame_get_dispid(HTMLDOMNode *iface, BSTR name,
     return search_window_props(This->framebase.content_window->base.inner_window, name, grfdex, pid);
 }
 
-static HRESULT HTMLIFrame_invoke(HTMLDOMNode *iface, DISPID id, LCID lcid,
+static HRESULT HTMLIFrame_invoke(HTMLDOMNode *iface, IDispatch *this_obj, DISPID id, LCID lcid,
         WORD flags, DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
     HTMLIFrame *This = iframe_from_HTMLDOMNode(iface);
@@ -1524,8 +1525,8 @@ static HRESULT HTMLIFrame_invoke(HTMLDOMNode *iface, DISPID id, LCID lcid,
         return E_FAIL;
     }
 
-    return IDispatchEx_InvokeEx(&This->framebase.content_window->base.IDispatchEx_iface, id, lcid,
-            flags, params, res, ei, caller);
+    return dispex_invoke(&This->framebase.content_window->base.inner_window->event_target.dispex,
+                         this_obj, id, lcid, flags, params, res, ei, caller);
 }
 
 static HRESULT HTMLIFrame_get_readystate(HTMLDOMNode *iface, BSTR *p)
@@ -1603,9 +1604,10 @@ static const tid_t HTMLIFrame_iface_tids[] = {
     0
 };
 
-static dispex_static_data_t HTMLIFrame_dispex = {
+dispex_static_data_t HTMLIFrame_dispex = {
     L"HTMLIFrameElement",
     NULL,
+    PROTO_ID_HTMLIFrameElement,
     DispHTMLIFrame_tid,
     HTMLIFrame_iface_tids,
     HTMLElement_init_dispex_info
diff --git a/dlls/mshtml/htmlgeneric.c b/dlls/mshtml/htmlgeneric.c
index 459fc78266b..4c45399bed7 100644
--- a/dlls/mshtml/htmlgeneric.c
+++ b/dlls/mshtml/htmlgeneric.c
@@ -167,9 +167,10 @@ static const tid_t HTMLGenericElement_iface_tids[] = {
     0
 };
 
-static dispex_static_data_t HTMLGenericElement_dispex = {
+dispex_static_data_t HTMLGenericElement_dispex = {
     L"HTMLUnknownElement",
     NULL,
+    PROTO_ID_HTMLGenericElement,
     DispHTMLGenericElement_tid,
     HTMLGenericElement_iface_tids,
     HTMLElement_init_dispex_info
diff --git a/dlls/mshtml/htmlhead.c b/dlls/mshtml/htmlhead.c
index 1bad06ee9d7..2e7d563c4fe 100644
--- a/dlls/mshtml/htmlhead.c
+++ b/dlls/mshtml/htmlhead.c
@@ -103,15 +103,29 @@ static HRESULT WINAPI HTMLTitleElement_Invoke(IHTMLTitleElement *iface, DISPID d
 static HRESULT WINAPI HTMLTitleElement_put_text(IHTMLTitleElement *iface, BSTR v)
 {
     HTMLTitleElement *This = impl_from_IHTMLTitleElement(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_w(v));
-    return E_NOTIMPL;
+    nsAString text;
+    nsresult nsres;
+
+    TRACE("(%p)->(%s)\n", This, debugstr_w(v));
+
+    nsAString_InitDepend(&text, v);
+    nsres = nsIDOMNode_SetTextContent(This->element.node.nsnode, &text);
+    nsAString_Finish(&text);
+
+    return map_nsresult(nsres);
 }
 
 static HRESULT WINAPI HTMLTitleElement_get_text(IHTMLTitleElement *iface, BSTR *p)
 {
     HTMLTitleElement *This = impl_from_IHTMLTitleElement(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
+    nsAString text;
+    nsresult nsres;
+
+    TRACE("(%p)->(%p)\n", This, p);
+
+    nsAString_Init(&text, NULL);
+    nsres = nsIDOMNode_GetTextContent(This->element.node.nsnode, &text);
+    return return_nsstr(nsres, &text, p);
 }
 
 static const IHTMLTitleElementVtbl HTMLTitleElementVtbl = {
@@ -168,9 +182,10 @@ static const tid_t HTMLTitleElement_iface_tids[] = {
     IHTMLTitleElement_tid,
     0
 };
-static dispex_static_data_t HTMLTitleElement_dispex = {
+dispex_static_data_t HTMLTitleElement_dispex = {
     L"HTMLTitleElement",
     NULL,
+    PROTO_ID_HTMLTitleElement,
     DispHTMLTitleElement_tid,
     HTMLTitleElement_iface_tids,
     HTMLElement_init_dispex_info
@@ -352,9 +367,10 @@ static const tid_t HTMLHtmlElement_iface_tids[] = {
     IHTMLHtmlElement_tid,
     0
 };
-static dispex_static_data_t HTMLHtmlElement_dispex = {
+dispex_static_data_t HTMLHtmlElement_dispex = {
     L"HTMLHtmlElement",
     NULL,
+    PROTO_ID_HTMLHtmlElement,
     DispHTMLHtmlElement_tid,
     HTMLHtmlElement_iface_tids,
     HTMLElement_init_dispex_info
@@ -589,9 +605,10 @@ static const tid_t HTMLMetaElement_iface_tids[] = {
     0
 };
 
-static dispex_static_data_t HTMLMetaElement_dispex = {
+dispex_static_data_t HTMLMetaElement_dispex = {
     L"HTMLMetaElement",
     NULL,
+    PROTO_ID_HTMLMetaElement,
     DispHTMLMetaElement_tid,
     HTMLMetaElement_iface_tids,
     HTMLElement_init_dispex_info
@@ -753,9 +770,10 @@ static const tid_t HTMLHeadElement_iface_tids[] = {
     IHTMLHeadElement_tid,
     0
 };
-static dispex_static_data_t HTMLHeadElement_dispex = {
+dispex_static_data_t HTMLHeadElement_dispex = {
     L"HTMLHeadElement",
     NULL,
+    PROTO_ID_HTMLHeadElement,
     DispHTMLHeadElement_tid,
     HTMLHeadElement_iface_tids,
     HTMLElement_init_dispex_info
diff --git a/dlls/mshtml/htmlimg.c b/dlls/mshtml/htmlimg.c
index 4483a5ed5ac..71035405016 100644
--- a/dlls/mshtml/htmlimg.c
+++ b/dlls/mshtml/htmlimg.c
@@ -729,9 +729,10 @@ static const tid_t HTMLImgElement_iface_tids[] = {
     IHTMLImgElement_tid,
     0
 };
-static dispex_static_data_t HTMLImgElement_dispex = {
+dispex_static_data_t HTMLImgElement_dispex = {
     L"HTMLImageElement",
     NULL,
+    PROTO_ID_HTMLImgElement,
     DispHTMLImg_tid,
     HTMLImgElement_iface_tids,
     HTMLElement_init_dispex_info
@@ -758,15 +759,15 @@ HRESULT HTMLImgElement_Create(HTMLDocumentNode *doc, nsIDOMElement *nselem, HTML
     return S_OK;
 }
 
-static inline HTMLImageElementFactory *impl_from_IHTMLImageElementFactory(IHTMLImageElementFactory *iface)
+static inline struct compat_ctor *impl_from_IHTMLImageElementFactory(IHTMLImageElementFactory *iface)
 {
-    return CONTAINING_RECORD(iface, HTMLImageElementFactory, IHTMLImageElementFactory_iface);
+    return CONTAINING_RECORD(iface, struct compat_ctor, IHTMLImageElementFactory_iface);
 }
 
 static HRESULT WINAPI HTMLImageElementFactory_QueryInterface(IHTMLImageElementFactory *iface,
         REFIID riid, void **ppv)
 {
-    HTMLImageElementFactory *This = impl_from_IHTMLImageElementFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLImageElementFactory(iface);
 
     TRACE("(%p)->(%s %p)\n", This, debugstr_mshtml_guid(riid), ppv);
 
@@ -788,7 +789,7 @@ static HRESULT WINAPI HTMLImageElementFactory_QueryInterface(IHTMLImageElementFa
 
 static ULONG WINAPI HTMLImageElementFactory_AddRef(IHTMLImageElementFactory *iface)
 {
-    HTMLImageElementFactory *This = impl_from_IHTMLImageElementFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLImageElementFactory(iface);
     LONG ref = InterlockedIncrement(&This->ref);
 
     TRACE("(%p) ref=%ld\n", This, ref);
@@ -798,7 +799,7 @@ static ULONG WINAPI HTMLImageElementFactory_AddRef(IHTMLImageElementFactory *ifa
 
 static ULONG WINAPI HTMLImageElementFactory_Release(IHTMLImageElementFactory *iface)
 {
-    HTMLImageElementFactory *This = impl_from_IHTMLImageElementFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLImageElementFactory(iface);
     LONG ref = InterlockedDecrement(&This->ref);
 
     TRACE("(%p) ref=%ld\n", This, ref);
@@ -812,14 +813,14 @@ static ULONG WINAPI HTMLImageElementFactory_Release(IHTMLImageElementFactory *if
 static HRESULT WINAPI HTMLImageElementFactory_GetTypeInfoCount(IHTMLImageElementFactory *iface,
         UINT *pctinfo)
 {
-    HTMLImageElementFactory *This = impl_from_IHTMLImageElementFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLImageElementFactory(iface);
     return IDispatchEx_GetTypeInfoCount(&This->dispex.IDispatchEx_iface, pctinfo);
 }
 
 static HRESULT WINAPI HTMLImageElementFactory_GetTypeInfo(IHTMLImageElementFactory *iface,
         UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)
 {
-    HTMLImageElementFactory *This = impl_from_IHTMLImageElementFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLImageElementFactory(iface);
     return IDispatchEx_GetTypeInfo(&This->dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
 }
 
@@ -827,7 +828,7 @@ static HRESULT WINAPI HTMLImageElementFactory_GetIDsOfNames(IHTMLImageElementFac
         REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid,
         DISPID *rgDispId)
 {
-    HTMLImageElementFactory *This = impl_from_IHTMLImageElementFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLImageElementFactory(iface);
     return IDispatchEx_GetIDsOfNames(&This->dispex.IDispatchEx_iface, riid, rgszNames, cNames, lcid, rgDispId);
 }
 
@@ -836,7 +837,7 @@ static HRESULT WINAPI HTMLImageElementFactory_Invoke(IHTMLImageElementFactory *i
         DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo,
         UINT *puArgErr)
 {
-    HTMLImageElementFactory *This = impl_from_IHTMLImageElementFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLImageElementFactory(iface);
     return IDispatchEx_Invoke(&This->dispex.IDispatchEx_iface, dispIdMember, riid, lcid, wFlags,
             pDispParams, pVarResult, pExcepInfo, puArgErr);
 }
@@ -868,7 +869,7 @@ static LONG var_to_size(const VARIANT *v)
 static HRESULT WINAPI HTMLImageElementFactory_create(IHTMLImageElementFactory *iface,
         VARIANT width, VARIANT height, IHTMLImgElement **img_elem)
 {
-    HTMLImageElementFactory *This = impl_from_IHTMLImageElementFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLImageElementFactory(iface);
     HTMLDocumentNode *doc;
     IHTMLImgElement *img;
     HTMLElement *elem;
@@ -918,7 +919,7 @@ static HRESULT WINAPI HTMLImageElementFactory_create(IHTMLImageElementFactory *i
     return S_OK;
 }
 
-static const IHTMLImageElementFactoryVtbl HTMLImageElementFactoryVtbl = {
+const IHTMLImageElementFactoryVtbl HTMLImageElementFactoryVtbl = {
     HTMLImageElementFactory_QueryInterface,
     HTMLImageElementFactory_AddRef,
     HTMLImageElementFactory_Release,
@@ -929,21 +930,24 @@ static const IHTMLImageElementFactoryVtbl HTMLImageElementFactoryVtbl = {
     HTMLImageElementFactory_create
 };
 
-static inline HTMLImageElementFactory *impl_from_DispatchEx(DispatchEx *iface)
+static inline struct compat_ctor *impl_from_DispatchEx(DispatchEx *iface)
 {
-    return CONTAINING_RECORD(iface, HTMLImageElementFactory, dispex);
+    return CONTAINING_RECORD(iface, struct compat_ctor, dispex);
 }
 
 static HRESULT HTMLImageElementFactory_value(DispatchEx *dispex, LCID lcid,
         WORD flags, DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei,
         IServiceProvider *caller)
 {
-    HTMLImageElementFactory *This = impl_from_DispatchEx(dispex);
+    struct compat_ctor *This = impl_from_DispatchEx(dispex);
     IHTMLImgElement *img;
     VARIANT empty, *width, *height;
     HRESULT hres;
     int argc = params->cArgs - params->cNamedArgs;
 
+    if(flags != DISPATCH_CONSTRUCT)
+        return S_FALSE;
+
     V_VT(res) = VT_NULL;
 
     V_VT(&empty) = VT_EMPTY;
@@ -969,33 +973,39 @@ static const tid_t HTMLImageElementFactory_iface_tids[] = {
 
 static const dispex_static_data_vtbl_t HTMLImageElementFactory_dispex_vtbl = {
     HTMLImageElementFactory_value,
-    NULL,
-    NULL,
-    NULL
+    compat_ctor_get_dispid,
+    compat_ctor_invoke,
+    compat_ctor_delete
 };
 
-static dispex_static_data_t HTMLImageElementFactory_dispex = {
-    L"Function",
+dispex_static_data_t HTMLImageElementFactory_dispex = {
+    L"HTMLImageElement",
     &HTMLImageElementFactory_dispex_vtbl,
+    PROTO_ID_NULL,
     IHTMLImageElementFactory_tid,
     HTMLImageElementFactory_iface_tids
 };
 
-HRESULT HTMLImageElementFactory_Create(HTMLInnerWindow *window, HTMLImageElementFactory **ret_val)
+static HRESULT HTMLImageCtor_value(DispatchEx *iface, LCID lcid, WORD flags, DISPPARAMS *params,
+        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
-    HTMLImageElementFactory *ret;
+    if(flags == DISPATCH_CONSTRUCT)
+        return HTMLImageElementFactory_value(iface, lcid, flags, params, res, ei, caller);
 
-    ret = heap_alloc(sizeof(HTMLImageElementFactory));
-    if(!ret)
-        return E_OUTOFMEMORY;
-
-    ret->IHTMLImageElementFactory_iface.lpVtbl = &HTMLImageElementFactoryVtbl;
-    ret->ref = 1;
-    ret->window = window;
+    return compat_ctor_value(iface, lcid, flags, params, res, ei, caller);
+}
 
-    init_dispatch(&ret->dispex, (IUnknown*)&ret->IHTMLImageElementFactory_iface,
-                  &HTMLImageElementFactory_dispex, dispex_compat_mode(&window->event_target.dispex));
+static const dispex_static_data_vtbl_t HTMLImageCtor_dispex_vtbl = {
+    HTMLImageCtor_value,
+    compat_ctor_get_dispid,
+    compat_ctor_invoke,
+    compat_ctor_delete
+};
 
-    *ret_val = ret;
-    return S_OK;
-}
+dispex_static_data_t HTMLImageCtor_dispex = {
+    L"HTMLImageElement",
+    &HTMLImageCtor_dispex_vtbl,
+    PROTO_ID_NULL,
+    IHTMLImageElementFactory_tid,
+    HTMLImageElementFactory_iface_tids
+};
diff --git a/dlls/mshtml/htmlinput.c b/dlls/mshtml/htmlinput.c
index 757a85e4290..e31b26e2d0e 100644
--- a/dlls/mshtml/htmlinput.c
+++ b/dlls/mshtml/htmlinput.c
@@ -39,6 +39,8 @@ struct HTMLInputElement {
     IHTMLInputElement IHTMLInputElement_iface;
     IHTMLInputTextElement IHTMLInputTextElement_iface;
     IHTMLInputTextElement2 IHTMLInputTextElement2_iface;
+    IWineHTMLInputPrivate IWineHTMLInputPrivate_iface;
+    IWineHTMLParentFormPrivate IWineHTMLParentFormPrivate_iface;
 
     nsIDOMHTMLInputElement *nsinput;
 };
@@ -1326,6 +1328,297 @@ static const IHTMLInputTextElement2Vtbl HTMLInputTextElement2Vtbl = {
     HTMLInputTextElement2_setSelectionRange
 };
 
+static inline HTMLInputElement *impl_from_IWineHTMLInputPrivateVtbl(IWineHTMLInputPrivate *iface)
+{
+    return CONTAINING_RECORD(iface, HTMLInputElement, IWineHTMLInputPrivate_iface);
+}
+
+static HRESULT WINAPI HTMLInputElement_private_QueryInterface(IWineHTMLInputPrivate *iface,
+        REFIID riid, void **ppv)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IHTMLDOMNode_QueryInterface(&This->element.node.IHTMLDOMNode_iface, riid, ppv);
+}
+
+static ULONG WINAPI HTMLInputElement_private_AddRef(IWineHTMLInputPrivate *iface)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IHTMLDOMNode_AddRef(&This->element.node.IHTMLDOMNode_iface);
+}
+
+static ULONG WINAPI HTMLInputElement_private_Release(IWineHTMLInputPrivate *iface)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IHTMLDOMNode_Release(&This->element.node.IHTMLDOMNode_iface);
+}
+
+static HRESULT WINAPI HTMLInputElement_private_GetTypeInfoCount(IWineHTMLInputPrivate *iface, UINT *pctinfo)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IDispatchEx_GetTypeInfoCount(&This->element.node.event_target.dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI HTMLInputElement_private_GetTypeInfo(IWineHTMLInputPrivate *iface, UINT iTInfo,
+                                              LCID lcid, ITypeInfo **ppTInfo)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IDispatchEx_GetTypeInfo(&This->element.node.event_target.dispex.IDispatchEx_iface, iTInfo, lcid,
+            ppTInfo);
+}
+
+static HRESULT WINAPI HTMLInputElement_private_GetIDsOfNames(IWineHTMLInputPrivate *iface, REFIID riid,
+                                                LPOLESTR *rgszNames, UINT cNames,
+                                                LCID lcid, DISPID *rgDispId)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IDispatchEx_GetIDsOfNames(&This->element.node.event_target.dispex.IDispatchEx_iface, riid, rgszNames,
+            cNames, lcid, rgDispId);
+}
+
+static HRESULT WINAPI HTMLInputElement_private_Invoke(IWineHTMLInputPrivate *iface, DISPID dispIdMember,
+                            REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+                            VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IDispatchEx_Invoke(&This->element.node.event_target.dispex.IDispatchEx_iface, dispIdMember, riid,
+            lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI HTMLInputElement_private_put_autofocus(IWineHTMLInputPrivate *iface, VARIANT_BOOL v)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%x)\n", This, v);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLInputElement_private_get_autofocus(IWineHTMLInputPrivate *iface, VARIANT_BOOL *ret)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLInputElement_private_get_validationMessage(IWineHTMLInputPrivate *iface, BSTR *ret)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLInputElement_private_get_validity(IWineHTMLInputPrivate *iface, IDispatch **ret)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLInputElement_private_get_willValidate(IWineHTMLInputPrivate *iface, VARIANT_BOOL *ret)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLInputElement_private_setCustomValidity(IWineHTMLInputPrivate *iface, VARIANT *message)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_variant(message));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLInputElement_private_checkValidity(IWineHTMLInputPrivate *iface, VARIANT_BOOL *ret)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    nsIDOMValidityState *nsvalidity;
+    DOMEvent *event;
+    nsresult nsres;
+    HRESULT hres;
+    cpp_bool b;
+
+    TRACE("(%p)->(%p)\n", This, ret);
+
+    nsres = nsIDOMHTMLInputElement_GetValidity(This->nsinput, &nsvalidity);
+    if(NS_FAILED(nsres))
+        return map_nsresult(nsres);
+    nsres = nsIDOMValidityState_GetValid(nsvalidity, &b);
+    nsIDOMValidityState_Release(nsvalidity);
+
+    if(!(*ret = variant_bool(NS_SUCCEEDED(nsres) && b))) {
+        hres = create_document_event(This->element.node.doc, EVENTID_INVALID, &event);
+        if(FAILED(hres))
+            return hres;
+        dispatch_event(&This->element.node.event_target, event);
+        IDOMEvent_Release(&event->IDOMEvent_iface);
+    }
+    return S_OK;
+}
+
+static const IWineHTMLInputPrivateVtbl WineHTMLInputPrivateVtbl = {
+    HTMLInputElement_private_QueryInterface,
+    HTMLInputElement_private_AddRef,
+    HTMLInputElement_private_Release,
+    HTMLInputElement_private_GetTypeInfoCount,
+    HTMLInputElement_private_GetTypeInfo,
+    HTMLInputElement_private_GetIDsOfNames,
+    HTMLInputElement_private_Invoke,
+    HTMLInputElement_private_put_autofocus,
+    HTMLInputElement_private_get_autofocus,
+    HTMLInputElement_private_get_validationMessage,
+    HTMLInputElement_private_get_validity,
+    HTMLInputElement_private_get_willValidate,
+    HTMLInputElement_private_setCustomValidity,
+    HTMLInputElement_private_checkValidity
+};
+
+static inline HTMLInputElement *impl_from_IWineHTMLParentFormPrivateVtbl(IWineHTMLParentFormPrivate *iface)
+{
+    return CONTAINING_RECORD(iface, HTMLInputElement, IWineHTMLParentFormPrivate_iface);
+}
+
+static HRESULT WINAPI HTMLInputElement_form_private_QueryInterface(IWineHTMLParentFormPrivate *iface,
+        REFIID riid, void **ppv)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLParentFormPrivateVtbl(iface);
+
+    return IHTMLDOMNode_QueryInterface(&This->element.node.IHTMLDOMNode_iface, riid, ppv);
+}
+
+static ULONG WINAPI HTMLInputElement_form_private_AddRef(IWineHTMLParentFormPrivate *iface)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLParentFormPrivateVtbl(iface);
+
+    return IHTMLDOMNode_AddRef(&This->element.node.IHTMLDOMNode_iface);
+}
+
+static ULONG WINAPI HTMLInputElement_form_private_Release(IWineHTMLParentFormPrivate *iface)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLParentFormPrivateVtbl(iface);
+
+    return IHTMLDOMNode_Release(&This->element.node.IHTMLDOMNode_iface);
+}
+
+static HRESULT WINAPI HTMLInputElement_form_private_GetTypeInfoCount(IWineHTMLParentFormPrivate *iface, UINT *pctinfo)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLParentFormPrivateVtbl(iface);
+    return IDispatchEx_GetTypeInfoCount(&This->element.node.event_target.dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI HTMLInputElement_form_private_GetTypeInfo(IWineHTMLParentFormPrivate *iface, UINT iTInfo,
+                                              LCID lcid, ITypeInfo **ppTInfo)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLParentFormPrivateVtbl(iface);
+    return IDispatchEx_GetTypeInfo(&This->element.node.event_target.dispex.IDispatchEx_iface, iTInfo, lcid,
+            ppTInfo);
+}
+
+static HRESULT WINAPI HTMLInputElement_form_private_GetIDsOfNames(IWineHTMLParentFormPrivate *iface, REFIID riid,
+                                                LPOLESTR *rgszNames, UINT cNames,
+                                                LCID lcid, DISPID *rgDispId)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLParentFormPrivateVtbl(iface);
+    return IDispatchEx_GetIDsOfNames(&This->element.node.event_target.dispex.IDispatchEx_iface, riid, rgszNames,
+            cNames, lcid, rgDispId);
+}
+
+static HRESULT WINAPI HTMLInputElement_form_private_Invoke(IWineHTMLParentFormPrivate *iface, DISPID dispIdMember,
+                            REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+                            VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLParentFormPrivateVtbl(iface);
+    return IDispatchEx_Invoke(&This->element.node.event_target.dispex.IDispatchEx_iface, dispIdMember, riid,
+            lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI HTMLInputElement_form_private_put_formAction(IWineHTMLParentFormPrivate *iface, BSTR v)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLParentFormPrivateVtbl(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLInputElement_form_private_get_formAction(IWineHTMLParentFormPrivate *iface, BSTR *ret)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLParentFormPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLInputElement_form_private_put_formEnctype(IWineHTMLParentFormPrivate *iface, BSTR v)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLParentFormPrivateVtbl(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLInputElement_form_private_get_formEnctype(IWineHTMLParentFormPrivate *iface, BSTR *ret)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLParentFormPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLInputElement_form_private_put_formMethod(IWineHTMLParentFormPrivate *iface, BSTR v)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLParentFormPrivateVtbl(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLInputElement_form_private_get_formMethod(IWineHTMLParentFormPrivate *iface, BSTR *ret)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLParentFormPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLInputElement_form_private_put_formNoValidate(IWineHTMLParentFormPrivate *iface, VARIANT_BOOL v)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLParentFormPrivateVtbl(iface);
+    FIXME("(%p)->(%x)\n", This, v);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLInputElement_form_private_get_formNoValidate(IWineHTMLParentFormPrivate *iface, VARIANT_BOOL *ret)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLParentFormPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLInputElement_form_private_put_formTarget(IWineHTMLParentFormPrivate *iface, BSTR v)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLParentFormPrivateVtbl(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLInputElement_form_private_get_formTarget(IWineHTMLParentFormPrivate *iface, BSTR *ret)
+{
+    HTMLInputElement *This = impl_from_IWineHTMLParentFormPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static const IWineHTMLParentFormPrivateVtbl WineHTMLParentFormPrivateVtbl = {
+    HTMLInputElement_form_private_QueryInterface,
+    HTMLInputElement_form_private_AddRef,
+    HTMLInputElement_form_private_Release,
+    HTMLInputElement_form_private_GetTypeInfoCount,
+    HTMLInputElement_form_private_GetTypeInfo,
+    HTMLInputElement_form_private_GetIDsOfNames,
+    HTMLInputElement_form_private_Invoke,
+    HTMLInputElement_form_private_put_formAction,
+    HTMLInputElement_form_private_get_formAction,
+    HTMLInputElement_form_private_put_formEnctype,
+    HTMLInputElement_form_private_get_formEnctype,
+    HTMLInputElement_form_private_put_formMethod,
+    HTMLInputElement_form_private_get_formMethod,
+    HTMLInputElement_form_private_put_formNoValidate,
+    HTMLInputElement_form_private_get_formNoValidate,
+    HTMLInputElement_form_private_put_formTarget,
+    HTMLInputElement_form_private_get_formTarget
+};
+
 static inline HTMLInputElement *impl_from_HTMLDOMNode(HTMLDOMNode *iface)
 {
     return CONTAINING_RECORD(iface, HTMLInputElement, element.node);
@@ -1352,6 +1645,12 @@ static HRESULT HTMLInputElement_QI(HTMLDOMNode *iface, REFIID riid, void **ppv)
     }else if(IsEqualGUID(&IID_IHTMLInputTextElement2, riid)) {
         TRACE("(%p)->(IID_IHTMLInputTextElement2 %p)\n", This, ppv);
         *ppv = &This->IHTMLInputTextElement2_iface;
+    }else if(IsEqualGUID(&IID_IWineHTMLInputPrivate, riid)) {
+        TRACE("(%p)->(IID_IWineHTMLInputPrivate %p)\n", This, ppv);
+        *ppv = &This->IWineHTMLInputPrivate_iface;
+    }else if(IsEqualGUID(&IID_IWineHTMLParentFormPrivate, riid)) {
+        TRACE("(%p)->(IID_IWineHTMLParentFormPrivate %p)\n", This, ppv);
+        *ppv = &This->IWineHTMLParentFormPrivate_iface;
     }
 
     if(*ppv) {
@@ -1434,18 +1733,29 @@ static const NodeImplVtbl HTMLInputElementImplVtbl = {
     HTMLInputElement_is_text_edit
 };
 
+static void HTMLInputElement_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
+{
+    HTMLElement_init_dispex_info(info, mode);
+
+    if(mode >= COMPAT_MODE_IE10) {
+        dispex_info_add_interface(info, IWineHTMLInputPrivate_tid, NULL);
+        dispex_info_add_interface(info, IWineHTMLParentFormPrivate_tid, NULL);
+    }
+}
+
 static const tid_t HTMLInputElement_iface_tids[] = {
     HTMLELEMENT_TIDS,
     IHTMLInputElement_tid,
     IHTMLInputTextElement2_tid,
     0
 };
-static dispex_static_data_t HTMLInputElement_dispex = {
+dispex_static_data_t HTMLInputElement_dispex = {
     L"HTMLInputElement",
     NULL,
+    PROTO_ID_HTMLInputElement,
     DispHTMLInputElement_tid,
     HTMLInputElement_iface_tids,
-    HTMLElement_init_dispex_info
+    HTMLInputElement_init_dispex_info
 };
 
 HRESULT HTMLInputElement_Create(HTMLDocumentNode *doc, nsIDOMElement *nselem, HTMLElement **elem)
@@ -1460,6 +1770,8 @@ HRESULT HTMLInputElement_Create(HTMLDocumentNode *doc, nsIDOMElement *nselem, HT
     ret->IHTMLInputElement_iface.lpVtbl = &HTMLInputElementVtbl;
     ret->IHTMLInputTextElement_iface.lpVtbl = &HTMLInputTextElementVtbl;
     ret->IHTMLInputTextElement2_iface.lpVtbl = &HTMLInputTextElement2Vtbl;
+    ret->IWineHTMLInputPrivate_iface.lpVtbl = &WineHTMLInputPrivateVtbl;
+    ret->IWineHTMLParentFormPrivate_iface.lpVtbl = &WineHTMLParentFormPrivateVtbl;
     ret->element.node.vtbl = &HTMLInputElementImplVtbl;
 
     HTMLElement_Init(&ret->element, doc, nselem, &HTMLInputElement_dispex);
@@ -1637,9 +1949,10 @@ static const tid_t HTMLLabelElement_iface_tids[] = {
     0
 };
 
-static dispex_static_data_t HTMLLabelElement_dispex = {
+dispex_static_data_t HTMLLabelElement_dispex = {
     L"HTMLLabelElement",
     NULL,
+    PROTO_ID_HTMLLabelElement,
     DispHTMLLabelElement_tid,
     HTMLLabelElement_iface_tids,
     HTMLElement_init_dispex_info
@@ -1665,6 +1978,8 @@ struct HTMLButtonElement {
     HTMLElement element;
 
     IHTMLButtonElement IHTMLButtonElement_iface;
+    IWineHTMLInputPrivate IWineHTMLInputPrivate_iface;
+    IWineHTMLParentFormPrivate IWineHTMLParentFormPrivate_iface;
 
     nsIDOMHTMLButtonElement *nsbutton;
 };
@@ -1895,6 +2210,277 @@ static const IHTMLButtonElementVtbl HTMLButtonElementVtbl = {
     HTMLButtonElement_createTextRange
 };
 
+static inline HTMLButtonElement *button_from_IWineHTMLInputPrivateVtbl(IWineHTMLInputPrivate *iface)
+{
+    return CONTAINING_RECORD(iface, HTMLButtonElement, IWineHTMLInputPrivate_iface);
+}
+
+static HRESULT WINAPI HTMLButtonElement_private_QueryInterface(IWineHTMLInputPrivate *iface,
+        REFIID riid, void **ppv)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLInputPrivateVtbl(iface);
+    return IHTMLDOMNode_QueryInterface(&This->element.node.IHTMLDOMNode_iface, riid, ppv);
+}
+
+static ULONG WINAPI HTMLButtonElement_private_AddRef(IWineHTMLInputPrivate *iface)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLInputPrivateVtbl(iface);
+    return IHTMLDOMNode_AddRef(&This->element.node.IHTMLDOMNode_iface);
+}
+
+static ULONG WINAPI HTMLButtonElement_private_Release(IWineHTMLInputPrivate *iface)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLInputPrivateVtbl(iface);
+    return IHTMLDOMNode_Release(&This->element.node.IHTMLDOMNode_iface);
+}
+
+static HRESULT WINAPI HTMLButtonElement_private_GetTypeInfoCount(IWineHTMLInputPrivate *iface, UINT *pctinfo)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLInputPrivateVtbl(iface);
+    return IDispatchEx_GetTypeInfoCount(&This->element.node.event_target.dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI HTMLButtonElement_private_GetTypeInfo(IWineHTMLInputPrivate *iface, UINT iTInfo,
+                                              LCID lcid, ITypeInfo **ppTInfo)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLInputPrivateVtbl(iface);
+    return IDispatchEx_GetTypeInfo(&This->element.node.event_target.dispex.IDispatchEx_iface, iTInfo, lcid,
+            ppTInfo);
+}
+
+static HRESULT WINAPI HTMLButtonElement_private_GetIDsOfNames(IWineHTMLInputPrivate *iface, REFIID riid,
+                                                LPOLESTR *rgszNames, UINT cNames,
+                                                LCID lcid, DISPID *rgDispId)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLInputPrivateVtbl(iface);
+    return IDispatchEx_GetIDsOfNames(&This->element.node.event_target.dispex.IDispatchEx_iface, riid, rgszNames,
+            cNames, lcid, rgDispId);
+}
+
+static HRESULT WINAPI HTMLButtonElement_private_Invoke(IWineHTMLInputPrivate *iface, DISPID dispIdMember,
+                            REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+                            VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLInputPrivateVtbl(iface);
+    return IDispatchEx_Invoke(&This->element.node.event_target.dispex.IDispatchEx_iface, dispIdMember, riid,
+            lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI HTMLButtonElement_private_put_autofocus(IWineHTMLInputPrivate *iface, VARIANT_BOOL v)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%x)\n", This, v);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLButtonElement_private_get_autofocus(IWineHTMLInputPrivate *iface, VARIANT_BOOL *ret)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLButtonElement_private_get_validationMessage(IWineHTMLInputPrivate *iface, BSTR *ret)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLButtonElement_private_get_validity(IWineHTMLInputPrivate *iface, IDispatch **ret)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLButtonElement_private_get_willValidate(IWineHTMLInputPrivate *iface, VARIANT_BOOL *ret)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLButtonElement_private_setCustomValidity(IWineHTMLInputPrivate *iface, VARIANT *message)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_variant(message));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLButtonElement_private_checkValidity(IWineHTMLInputPrivate *iface, VARIANT_BOOL *ret)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static const IWineHTMLInputPrivateVtbl WineHTMLButtonInputPrivateVtbl = {
+    HTMLButtonElement_private_QueryInterface,
+    HTMLButtonElement_private_AddRef,
+    HTMLButtonElement_private_Release,
+    HTMLButtonElement_private_GetTypeInfoCount,
+    HTMLButtonElement_private_GetTypeInfo,
+    HTMLButtonElement_private_GetIDsOfNames,
+    HTMLButtonElement_private_Invoke,
+    HTMLButtonElement_private_put_autofocus,
+    HTMLButtonElement_private_get_autofocus,
+    HTMLButtonElement_private_get_validationMessage,
+    HTMLButtonElement_private_get_validity,
+    HTMLButtonElement_private_get_willValidate,
+    HTMLButtonElement_private_setCustomValidity,
+    HTMLButtonElement_private_checkValidity
+};
+
+static inline HTMLButtonElement *button_from_IWineHTMLParentFormPrivateVtbl(IWineHTMLParentFormPrivate *iface)
+{
+    return CONTAINING_RECORD(iface, HTMLButtonElement, IWineHTMLParentFormPrivate_iface);
+}
+
+static HRESULT WINAPI HTMLButtonElement_form_private_QueryInterface(IWineHTMLParentFormPrivate *iface,
+        REFIID riid, void **ppv)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLParentFormPrivateVtbl(iface);
+
+    return IHTMLDOMNode_QueryInterface(&This->element.node.IHTMLDOMNode_iface, riid, ppv);
+}
+
+static ULONG WINAPI HTMLButtonElement_form_private_AddRef(IWineHTMLParentFormPrivate *iface)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLParentFormPrivateVtbl(iface);
+
+    return IHTMLDOMNode_AddRef(&This->element.node.IHTMLDOMNode_iface);
+}
+
+static ULONG WINAPI HTMLButtonElement_form_private_Release(IWineHTMLParentFormPrivate *iface)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLParentFormPrivateVtbl(iface);
+
+    return IHTMLDOMNode_Release(&This->element.node.IHTMLDOMNode_iface);
+}
+
+static HRESULT WINAPI HTMLButtonElement_form_private_GetTypeInfoCount(IWineHTMLParentFormPrivate *iface, UINT *pctinfo)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLParentFormPrivateVtbl(iface);
+    return IDispatchEx_GetTypeInfoCount(&This->element.node.event_target.dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI HTMLButtonElement_form_private_GetTypeInfo(IWineHTMLParentFormPrivate *iface, UINT iTInfo,
+                                              LCID lcid, ITypeInfo **ppTInfo)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLParentFormPrivateVtbl(iface);
+    return IDispatchEx_GetTypeInfo(&This->element.node.event_target.dispex.IDispatchEx_iface, iTInfo, lcid,
+            ppTInfo);
+}
+
+static HRESULT WINAPI HTMLButtonElement_form_private_GetIDsOfNames(IWineHTMLParentFormPrivate *iface, REFIID riid,
+                                                LPOLESTR *rgszNames, UINT cNames,
+                                                LCID lcid, DISPID *rgDispId)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLParentFormPrivateVtbl(iface);
+    return IDispatchEx_GetIDsOfNames(&This->element.node.event_target.dispex.IDispatchEx_iface, riid, rgszNames,
+            cNames, lcid, rgDispId);
+}
+
+static HRESULT WINAPI HTMLButtonElement_form_private_Invoke(IWineHTMLParentFormPrivate *iface, DISPID dispIdMember,
+                            REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+                            VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLParentFormPrivateVtbl(iface);
+    return IDispatchEx_Invoke(&This->element.node.event_target.dispex.IDispatchEx_iface, dispIdMember, riid,
+            lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI HTMLButtonElement_form_private_put_formAction(IWineHTMLParentFormPrivate *iface, BSTR v)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLParentFormPrivateVtbl(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLButtonElement_form_private_get_formAction(IWineHTMLParentFormPrivate *iface, BSTR *ret)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLParentFormPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLButtonElement_form_private_put_formEnctype(IWineHTMLParentFormPrivate *iface, BSTR v)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLParentFormPrivateVtbl(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLButtonElement_form_private_get_formEnctype(IWineHTMLParentFormPrivate *iface, BSTR *ret)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLParentFormPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLButtonElement_form_private_put_formMethod(IWineHTMLParentFormPrivate *iface, BSTR v)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLParentFormPrivateVtbl(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLButtonElement_form_private_get_formMethod(IWineHTMLParentFormPrivate *iface, BSTR *ret)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLParentFormPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLButtonElement_form_private_put_formNoValidate(IWineHTMLParentFormPrivate *iface, VARIANT_BOOL v)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLParentFormPrivateVtbl(iface);
+    FIXME("(%p)->(%x)\n", This, v);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLButtonElement_form_private_get_formNoValidate(IWineHTMLParentFormPrivate *iface, VARIANT_BOOL *ret)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLParentFormPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLButtonElement_form_private_put_formTarget(IWineHTMLParentFormPrivate *iface, BSTR v)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLParentFormPrivateVtbl(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLButtonElement_form_private_get_formTarget(IWineHTMLParentFormPrivate *iface, BSTR *ret)
+{
+    HTMLButtonElement *This = button_from_IWineHTMLParentFormPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static const IWineHTMLParentFormPrivateVtbl WineHTMLButtonParentFormPrivateVtbl = {
+    HTMLButtonElement_form_private_QueryInterface,
+    HTMLButtonElement_form_private_AddRef,
+    HTMLButtonElement_form_private_Release,
+    HTMLButtonElement_form_private_GetTypeInfoCount,
+    HTMLButtonElement_form_private_GetTypeInfo,
+    HTMLButtonElement_form_private_GetIDsOfNames,
+    HTMLButtonElement_form_private_Invoke,
+    HTMLButtonElement_form_private_put_formAction,
+    HTMLButtonElement_form_private_get_formAction,
+    HTMLButtonElement_form_private_put_formEnctype,
+    HTMLButtonElement_form_private_get_formEnctype,
+    HTMLButtonElement_form_private_put_formMethod,
+    HTMLButtonElement_form_private_get_formMethod,
+    HTMLButtonElement_form_private_put_formNoValidate,
+    HTMLButtonElement_form_private_get_formNoValidate,
+    HTMLButtonElement_form_private_put_formTarget,
+    HTMLButtonElement_form_private_get_formTarget
+};
+
 static inline HTMLButtonElement *button_from_HTMLDOMNode(HTMLDOMNode *iface)
 {
     return CONTAINING_RECORD(iface, HTMLButtonElement, element.node);
@@ -1912,6 +2498,12 @@ static HRESULT HTMLButtonElement_QI(HTMLDOMNode *iface, REFIID riid, void **ppv)
     }else if(IsEqualGUID(&IID_IHTMLButtonElement, riid)) {
         TRACE("(%p)->(IID_IHTMLButtonElement %p)\n", This, ppv);
         *ppv = &This->IHTMLButtonElement_iface;
+    }else if(IsEqualGUID(&IID_IWineHTMLInputPrivate, riid)) {
+        TRACE("(%p)->(IID_IWineHTMLInputPrivate %p)\n", This, ppv);
+        *ppv = &This->IWineHTMLInputPrivate_iface;
+    }else if(IsEqualGUID(&IID_IWineHTMLParentFormPrivate, riid)) {
+        TRACE("(%p)->(IID_IWineHTMLParentFormPrivate %p)\n", This, ppv);
+        *ppv = &This->IWineHTMLParentFormPrivate_iface;
     }else {
         return HTMLElement_QI(&This->element.node, riid, ppv);
     }
@@ -1978,18 +2570,29 @@ static const NodeImplVtbl HTMLButtonElementImplVtbl = {
     HTMLButtonElement_is_text_edit
 };
 
+static void HTMLButtonElement_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
+{
+    HTMLElement_init_dispex_info(info, mode);
+
+    if(mode >= COMPAT_MODE_IE10) {
+        dispex_info_add_interface(info, IWineHTMLInputPrivate_tid, NULL);
+        dispex_info_add_interface(info, IWineHTMLParentFormPrivate_tid, NULL);
+    }
+}
+
 static const tid_t HTMLButtonElement_iface_tids[] = {
     HTMLELEMENT_TIDS,
     IHTMLButtonElement_tid,
     0
 };
 
-static dispex_static_data_t HTMLButtonElement_dispex = {
+dispex_static_data_t HTMLButtonElement_dispex = {
     L"HTMLButtonElement",
     NULL,
+    PROTO_ID_HTMLButtonElement,
     DispHTMLButtonElement_tid,
     HTMLButtonElement_iface_tids,
-    HTMLElement_init_dispex_info
+    HTMLButtonElement_init_dispex_info
 };
 
 HRESULT HTMLButtonElement_Create(HTMLDocumentNode *doc, nsIDOMElement *nselem, HTMLElement **elem)
@@ -2002,6 +2605,8 @@ HRESULT HTMLButtonElement_Create(HTMLDocumentNode *doc, nsIDOMElement *nselem, H
         return E_OUTOFMEMORY;
 
     ret->IHTMLButtonElement_iface.lpVtbl = &HTMLButtonElementVtbl;
+    ret->IWineHTMLInputPrivate_iface.lpVtbl = &WineHTMLButtonInputPrivateVtbl;
+    ret->IWineHTMLParentFormPrivate_iface.lpVtbl = &WineHTMLButtonParentFormPrivateVtbl;
     ret->element.node.vtbl = &HTMLButtonElementImplVtbl;
 
     HTMLElement_Init(&ret->element, doc, nselem, &HTMLButtonElement_dispex);
diff --git a/dlls/mshtml/htmllink.c b/dlls/mshtml/htmllink.c
index f4f5e2eb943..8308632035f 100644
--- a/dlls/mshtml/htmllink.c
+++ b/dlls/mshtml/htmllink.c
@@ -445,9 +445,10 @@ static const tid_t HTMLLinkElement_iface_tids[] = {
     IHTMLLinkElement_tid,
     0
 };
-static dispex_static_data_t HTMLLinkElement_dispex = {
+dispex_static_data_t HTMLLinkElement_dispex = {
     L"HTMLLinkElement",
     NULL,
+    PROTO_ID_HTMLLinkElement,
     DispHTMLLinkElement_tid,
     HTMLLinkElement_iface_tids,
     HTMLElement_init_dispex_info
diff --git a/dlls/mshtml/htmllocation.c b/dlls/mshtml/htmllocation.c
index 8f7800ff2a3..a01c640a40b 100644
--- a/dlls/mshtml/htmllocation.c
+++ b/dlls/mshtml/htmllocation.c
@@ -524,8 +524,29 @@ static HRESULT WINAPI HTMLLocation_get_search(IHTMLLocation *iface, BSTR *p)
 static HRESULT WINAPI HTMLLocation_put_hash(IHTMLLocation *iface, BSTR v)
 {
     HTMLLocation *This = impl_from_IHTMLLocation(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_w(v));
-    return E_NOTIMPL;
+    WCHAR *hash = v;
+    HRESULT hres;
+
+    TRACE("(%p)->(%s)\n", This, debugstr_w(v));
+
+    if(!This->window || !This->window->base.outer_window) {
+        FIXME("No window available\n");
+        return E_FAIL;
+    }
+
+    if(hash[0] != '#') {
+        DWORD size = (1 /* # */ + SysStringLen(v) + 1) * sizeof(WCHAR);
+        if(!(hash = heap_alloc(size)))
+            return E_OUTOFMEMORY;
+        hash[0] = '#';
+        memcpy(hash + 1, v, size - sizeof(WCHAR));
+    }
+
+    hres = navigate_url(This->window->base.outer_window, hash, This->window->base.outer_window->uri, BINDING_NAVIGATED);
+
+    if(hash != v)
+        heap_free(hash);
+    return hres;
 }
 
 static HRESULT WINAPI HTMLLocation_get_hash(IHTMLLocation *iface, BSTR *p)
@@ -633,6 +654,14 @@ static const tid_t HTMLLocation_iface_tids[] = {
 static dispex_static_data_t HTMLLocation_dispex = {
     L"Object",
     NULL,
+    PROTO_ID_NULL,
+    DispHTMLLocation_tid,
+    HTMLLocation_iface_tids
+};
+dispex_static_data_t HTMLLocation_compat_dispex = {
+    L"Location",
+    NULL,
+    PROTO_ID_HTMLLocation,
     DispHTMLLocation_tid,
     HTMLLocation_iface_tids
 };
@@ -640,6 +669,7 @@ static dispex_static_data_t HTMLLocation_dispex = {
 
 HRESULT HTMLLocation_Create(HTMLInnerWindow *window, HTMLLocation **ret)
 {
+    compat_mode_t compat_mode = dispex_compat_mode(&window->event_target.dispex);
     HTMLLocation *location;
 
     location = heap_alloc(sizeof(*location));
@@ -650,8 +680,9 @@ HRESULT HTMLLocation_Create(HTMLInnerWindow *window, HTMLLocation **ret)
     location->ref = 1;
     location->window = window;
 
-    init_dispatch(&location->dispex, (IUnknown*)&location->IHTMLLocation_iface, &HTMLLocation_dispex,
-                  dispex_compat_mode(&window->event_target.dispex));
+    init_dispatch(&location->dispex, (IUnknown*)&location->IHTMLLocation_iface,
+                  compat_mode < COMPAT_MODE_IE9 ? &HTMLLocation_compat_dispex : &HTMLLocation_dispex,
+                  NULL, compat_mode);
 
     *ret = location;
     return S_OK;
diff --git a/dlls/mshtml/htmlnode.c b/dlls/mshtml/htmlnode.c
index 13f178fc33b..c4bdda6dcf3 100644
--- a/dlls/mshtml/htmlnode.c
+++ b/dlls/mshtml/htmlnode.c
@@ -386,8 +386,8 @@ static HRESULT HTMLDOMChildrenCollection_get_dispid(DispatchEx *dispex, BSTR nam
     return S_OK;
 }
 
-static HRESULT HTMLDOMChildrenCollection_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
-        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+static HRESULT HTMLDOMChildrenCollection_invoke(DispatchEx *dispex, IDispatch *this_obj, DISPID id, LCID lcid, WORD flags,
+        DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
     HTMLDOMChildrenCollection *This = impl_from_DispatchEx(dispex);
 
@@ -428,16 +428,18 @@ static const tid_t HTMLDOMChildrenCollection_iface_tids[] = {
     0
 };
 
-static dispex_static_data_t HTMLDOMChildrenCollection_dispex = {
+dispex_static_data_t HTMLDOMChildrenCollection_dispex = {
     L"NodeList",
     &HTMLDOMChildrenCollection_dispex_vtbl,
+    PROTO_ID_HTMLDOMChildrenCollection,
     DispDOMChildrenCollection_tid,
     HTMLDOMChildrenCollection_iface_tids,
     HTMLDOMNode_init_dispex_info
 };
 
-HRESULT create_child_collection(nsIDOMNodeList *nslist, compat_mode_t compat_mode, IHTMLDOMChildrenCollection **ret)
+HRESULT create_child_collection(nsIDOMNodeList *nslist, HTMLDocumentNode *doc, IHTMLDOMChildrenCollection **ret)
 {
+    compat_mode_t compat_mode = doc ? dispex_compat_mode(&doc->node.event_target.dispex) : COMPAT_MODE_NONE;
     HTMLDOMChildrenCollection *collection;
 
     if(!(collection = heap_alloc_zero(sizeof(*collection))))
@@ -450,7 +452,7 @@ HRESULT create_child_collection(nsIDOMNodeList *nslist, compat_mode_t compat_mod
     collection->nslist = nslist;
 
     init_dispatch(&collection->dispex, (IUnknown*)&collection->IHTMLDOMChildrenCollection_iface,
-                  &HTMLDOMChildrenCollection_dispex, compat_mode);
+                  &HTMLDOMChildrenCollection_dispex, doc, compat_mode);
 
     *ret = &collection->IHTMLDOMChildrenCollection_iface;
     return S_OK;
@@ -621,8 +623,7 @@ static HRESULT WINAPI HTMLDOMNode_get_childNodes(IHTMLDOMNode *iface, IDispatch
         return hres;
     }
 
-    hres = create_child_collection(nslist, dispex_compat_mode(&This->event_target.dispex),
-                                   (IHTMLDOMChildrenCollection**)p);
+    hres = create_child_collection(nslist, This->doc, (IHTMLDOMChildrenCollection**)p);
     nsIDOMNodeList_Release(nslist);
     return hres;
 }
@@ -1051,6 +1052,11 @@ static const IHTMLDOMNodeVtbl HTMLDOMNodeVtbl = {
     HTMLDOMNode_get_nextSibling
 };
 
+HTMLDOMNode *unsafe_impl_from_IHTMLDOMNode(IHTMLDOMNode *iface)
+{
+    return iface->lpVtbl == &HTMLDOMNodeVtbl ? impl_from_IHTMLDOMNode(iface) : NULL;
+}
+
 static HTMLDOMNode *get_node_obj(IHTMLDOMNode *iface)
 {
     HTMLDOMNode *ret;
@@ -1435,8 +1441,10 @@ static HRESULT HTMLDOMNode_clone(HTMLDOMNode *This, nsIDOMNode *nsnode, HTMLDOMN
 
 void HTMLDOMNode_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
 {
-    if(mode >= COMPAT_MODE_IE9)
+    if(mode >= COMPAT_MODE_IE9) {
+        dispex_info_add_interface(info, IHTMLDOMNode2_tid, NULL);
         dispex_info_add_interface(info, IHTMLDOMNode3_tid, NULL);
+    }
 
     EventTarget_init_dispex_info(info, mode);
 }
@@ -1460,7 +1468,7 @@ void HTMLDOMNode_Init(HTMLDocumentNode *doc, HTMLDOMNode *node, nsIDOMNode *nsno
     node->IHTMLDOMNode3_iface.lpVtbl = &HTMLDOMNode3Vtbl;
 
     ccref_init(&node->ccref, 1);
-    EventTarget_Init(&node->event_target, (IUnknown*)&node->IHTMLDOMNode_iface, dispex_data, doc->document_mode);
+    EventTarget_Init(&node->event_target, (IUnknown*)&node->IHTMLDOMNode_iface, dispex_data, doc);
 
     if(&doc->node != node)
         htmldoc_addref(&doc->basedoc);
@@ -1477,9 +1485,10 @@ static const tid_t HTMLDOMNode_iface_tids[] = {
     IHTMLDOMNode_tid,
     0
 };
-static dispex_static_data_t HTMLDOMNode_dispex = {
+dispex_static_data_t HTMLDOMNode_dispex = {
     L"Node",
     NULL,
+    PROTO_ID_HTMLDOMNode,
     IHTMLDOMNode_tid,
     HTMLDOMNode_iface_tids,
     HTMLDOMNode_init_dispex_info
diff --git a/dlls/mshtml/htmlobject.c b/dlls/mshtml/htmlobject.c
index 787dd3762ee..62c8382878a 100644
--- a/dlls/mshtml/htmlobject.c
+++ b/dlls/mshtml/htmlobject.c
@@ -38,6 +38,7 @@ struct HTMLObjectElement {
 
     IHTMLObjectElement IHTMLObjectElement_iface;
     IHTMLObjectElement2 IHTMLObjectElement2_iface;
+    IWineHTMLInputPrivate IWineHTMLInputPrivate_iface;
 
     nsIDOMHTMLObjectElement *nsobject;
 };
@@ -631,6 +632,128 @@ static const IHTMLObjectElement2Vtbl HTMLObjectElement2Vtbl = {
     HTMLObjectElement2_get_data
 };
 
+static inline HTMLObjectElement *impl_from_IWineHTMLInputPrivateVtbl(IWineHTMLInputPrivate *iface)
+{
+    return CONTAINING_RECORD(iface, HTMLObjectElement, IWineHTMLInputPrivate_iface);
+}
+
+static HRESULT WINAPI HTMLObjectElement_input_private_QueryInterface(IWineHTMLInputPrivate *iface,
+        REFIID riid, void **ppv)
+{
+    HTMLObjectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IHTMLDOMNode_QueryInterface(&This->plugin_container.element.node.IHTMLDOMNode_iface, riid, ppv);
+}
+
+static ULONG WINAPI HTMLObjectElement_input_private_AddRef(IWineHTMLInputPrivate *iface)
+{
+    HTMLObjectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IHTMLDOMNode_AddRef(&This->plugin_container.element.node.IHTMLDOMNode_iface);
+}
+
+static ULONG WINAPI HTMLObjectElement_input_private_Release(IWineHTMLInputPrivate *iface)
+{
+    HTMLObjectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IHTMLDOMNode_Release(&This->plugin_container.element.node.IHTMLDOMNode_iface);
+}
+
+static HRESULT WINAPI HTMLObjectElement_input_private_GetTypeInfoCount(IWineHTMLInputPrivate *iface, UINT *pctinfo)
+{
+    HTMLObjectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IDispatchEx_GetTypeInfoCount(&This->plugin_container.element.node.event_target.dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI HTMLObjectElement_input_private_GetTypeInfo(IWineHTMLInputPrivate *iface, UINT iTInfo,
+                                              LCID lcid, ITypeInfo **ppTInfo)
+{
+    HTMLObjectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IDispatchEx_GetTypeInfo(&This->plugin_container.element.node.event_target.dispex.IDispatchEx_iface, iTInfo, lcid,
+            ppTInfo);
+}
+
+static HRESULT WINAPI HTMLObjectElement_input_private_GetIDsOfNames(IWineHTMLInputPrivate *iface, REFIID riid,
+                                                LPOLESTR *rgszNames, UINT cNames,
+                                                LCID lcid, DISPID *rgDispId)
+{
+    HTMLObjectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IDispatchEx_GetIDsOfNames(&This->plugin_container.element.node.event_target.dispex.IDispatchEx_iface, riid,
+            rgszNames, cNames, lcid, rgDispId);
+}
+
+static HRESULT WINAPI HTMLObjectElement_input_private_Invoke(IWineHTMLInputPrivate *iface, DISPID dispIdMember,
+                            REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+                            VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    HTMLObjectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IDispatchEx_Invoke(&This->plugin_container.element.node.event_target.dispex.IDispatchEx_iface, dispIdMember,
+            riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI HTMLObjectElement_input_private_put_autofocus(IWineHTMLInputPrivate *iface, VARIANT_BOOL v)
+{
+    HTMLObjectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    WARN("(%p)->(%x)\n", This, v);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLObjectElement_input_private_get_autofocus(IWineHTMLInputPrivate *iface, VARIANT_BOOL *ret)
+{
+    HTMLObjectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    WARN("(%p)->(%p)\n", This, ret);
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI HTMLObjectElement_input_private_get_validationMessage(IWineHTMLInputPrivate *iface, BSTR *ret)
+{
+    HTMLObjectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLObjectElement_input_private_get_validity(IWineHTMLInputPrivate *iface, IDispatch **ret)
+{
+    HTMLObjectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLObjectElement_input_private_get_willValidate(IWineHTMLInputPrivate *iface, VARIANT_BOOL *ret)
+{
+    HTMLObjectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLObjectElement_input_private_setCustomValidity(IWineHTMLInputPrivate *iface, VARIANT *message)
+{
+    HTMLObjectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_variant(message));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLObjectElement_input_private_checkValidity(IWineHTMLInputPrivate *iface, VARIANT_BOOL *ret)
+{
+    HTMLObjectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static const IWineHTMLInputPrivateVtbl WineHTMLInputPrivateVtbl = {
+    HTMLObjectElement_input_private_QueryInterface,
+    HTMLObjectElement_input_private_AddRef,
+    HTMLObjectElement_input_private_Release,
+    HTMLObjectElement_input_private_GetTypeInfoCount,
+    HTMLObjectElement_input_private_GetTypeInfo,
+    HTMLObjectElement_input_private_GetIDsOfNames,
+    HTMLObjectElement_input_private_Invoke,
+    HTMLObjectElement_input_private_put_autofocus,
+    HTMLObjectElement_input_private_get_autofocus,
+    HTMLObjectElement_input_private_get_validationMessage,
+    HTMLObjectElement_input_private_get_validity,
+    HTMLObjectElement_input_private_get_willValidate,
+    HTMLObjectElement_input_private_setCustomValidity,
+    HTMLObjectElement_input_private_checkValidity
+};
+
 static inline HTMLObjectElement *impl_from_HTMLDOMNode(HTMLDOMNode *iface)
 {
     return CONTAINING_RECORD(iface, HTMLObjectElement, plugin_container.element.node);
@@ -650,6 +773,8 @@ static HRESULT HTMLObjectElement_QI(HTMLDOMNode *iface, REFIID riid, void **ppv)
         *ppv = &This->IHTMLObjectElement_iface;
     }else if(IsEqualGUID(&IID_IHTMLObjectElement2, riid)) {
         *ppv = &This->IHTMLObjectElement2_iface;
+    }else if(IsEqualGUID(&IID_IWineHTMLInputPrivate, riid)) {
+        *ppv = &This->IWineHTMLInputPrivate_iface;
     }else if(IsEqualGUID(&IID_HTMLPluginContainer, riid)) {
         /* Special pseudo-interface returning HTMLPluginContainse struct. */
         *ppv = &This->plugin_container;
@@ -709,7 +834,7 @@ static HRESULT HTMLObjectElement_get_dispid(HTMLDOMNode *iface, BSTR name,
     return get_plugin_dispid(&This->plugin_container, name, pid);
 }
 
-static HRESULT HTMLObjectElement_invoke(HTMLDOMNode *iface, DISPID id, LCID lcid,
+static HRESULT HTMLObjectElement_invoke(HTMLDOMNode *iface, IDispatch *this_obj, DISPID id, LCID lcid,
         WORD flags, DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
     HTMLObjectElement *This = impl_from_HTMLDOMNode(iface);
@@ -759,18 +884,31 @@ static const NodeImplVtbl HTMLObjectElementImplVtbl = {
     HTMLObjectElement_unlink
 };
 
+static void HTMLObjectElement_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
+{
+    static const dispex_hook_t input_private_hooks[] = {
+        {DISPID_IWINEHTMLINPUTPRIVATE_AUTOFOCUS},
+        {DISPID_UNKNOWN}
+    };
+    HTMLElement_init_dispex_info(info, mode);
+
+    if(mode >= COMPAT_MODE_IE10)
+        dispex_info_add_interface(info, IWineHTMLInputPrivate_tid, input_private_hooks);
+}
+
 static const tid_t HTMLObjectElement_iface_tids[] = {
     IHTMLObjectElement2_tid,
     IHTMLObjectElement_tid,
     HTMLELEMENT_TIDS,
     0
 };
-static dispex_static_data_t HTMLObjectElement_dispex = {
+dispex_static_data_t HTMLObjectElement_dispex = {
     L"HTMLObjectElement",
     NULL,
+    PROTO_ID_HTMLObjectElement,
     DispHTMLObjectElement_tid,
     HTMLObjectElement_iface_tids,
-    HTMLElement_init_dispex_info
+    HTMLObjectElement_init_dispex_info
 };
 
 HRESULT HTMLObjectElement_Create(HTMLDocumentNode *doc, nsIDOMElement *nselem, HTMLElement **elem)
@@ -784,6 +922,7 @@ HRESULT HTMLObjectElement_Create(HTMLDocumentNode *doc, nsIDOMElement *nselem, H
 
     ret->IHTMLObjectElement_iface.lpVtbl = &HTMLObjectElementVtbl;
     ret->IHTMLObjectElement2_iface.lpVtbl = &HTMLObjectElement2Vtbl;
+    ret->IWineHTMLInputPrivate_iface.lpVtbl = &WineHTMLInputPrivateVtbl;
     ret->plugin_container.element.node.vtbl = &HTMLObjectElementImplVtbl;
 
     HTMLElement_Init(&ret->plugin_container.element, doc, nselem, &HTMLObjectElement_dispex);
@@ -1028,9 +1167,10 @@ static const tid_t HTMLEmbedElement_iface_tids[] = {
     IHTMLEmbedElement_tid,
     0
 };
-static dispex_static_data_t HTMLEmbedElement_dispex = {
+dispex_static_data_t HTMLEmbedElement_dispex = {
     L"HTMLEmbedElement",
     NULL,
+    PROTO_ID_HTMLEmbedElement,
     DispHTMLEmbed_tid,
     HTMLEmbedElement_iface_tids,
     HTMLElement_init_dispex_info
diff --git a/dlls/mshtml/htmlscript.c b/dlls/mshtml/htmlscript.c
index f28a9d3a29d..068d77d5a28 100644
--- a/dlls/mshtml/htmlscript.c
+++ b/dlls/mshtml/htmlscript.c
@@ -478,9 +478,10 @@ static const tid_t HTMLScriptElement_iface_tids[] = {
     0
 };
 
-static dispex_static_data_t HTMLScriptElement_dispex = {
+dispex_static_data_t HTMLScriptElement_dispex = {
     L"HTMLScriptElement",
     NULL,
+    PROTO_ID_HTMLScriptElement,
     DispHTMLScriptElement_tid,
     HTMLScriptElement_iface_tids,
     HTMLElement_init_dispex_info
diff --git a/dlls/mshtml/htmlselect.c b/dlls/mshtml/htmlselect.c
index ae6543a3d13..289328bd2f2 100644
--- a/dlls/mshtml/htmlselect.c
+++ b/dlls/mshtml/htmlselect.c
@@ -275,7 +275,7 @@ static HRESULT WINAPI HTMLOptionElement_put_text(IHTMLOptionElement *iface, BSTR
     }
 
     nsAString_InitDepend(&text_str, v);
-    nsres = nsIDOMHTMLDocument_CreateTextNode(This->element.node.doc->nsdoc, &text_str, &text_node);
+    nsres = nsIDOMDocument_CreateTextNode(This->element.node.doc->nsdoc, &text_str, &text_node);
     nsAString_Finish(&text_str);
     if(NS_FAILED(nsres)) {
         ERR("CreateTextNode failed: %08lx\n", nsres);
@@ -415,9 +415,10 @@ static const tid_t HTMLOptionElement_iface_tids[] = {
     IHTMLOptionElement_tid,
     0
 };
-static dispex_static_data_t HTMLOptionElement_dispex = {
+dispex_static_data_t HTMLOptionElement_dispex = {
     L"HTMLOptionElement",
     NULL,
+    PROTO_ID_HTMLOptionElement,
     DispHTMLOptionElement_tid,
     HTMLOptionElement_iface_tids,
     HTMLElement_init_dispex_info
@@ -444,15 +445,15 @@ HRESULT HTMLOptionElement_Create(HTMLDocumentNode *doc, nsIDOMElement *nselem, H
     return S_OK;
 }
 
-static inline HTMLOptionElementFactory *impl_from_IHTMLOptionElementFactory(IHTMLOptionElementFactory *iface)
+static inline struct compat_ctor *impl_from_IHTMLOptionElementFactory(IHTMLOptionElementFactory *iface)
 {
-    return CONTAINING_RECORD(iface, HTMLOptionElementFactory, IHTMLOptionElementFactory_iface);
+    return CONTAINING_RECORD(iface, struct compat_ctor, IHTMLOptionElementFactory_iface);
 }
 
 static HRESULT WINAPI HTMLOptionElementFactory_QueryInterface(IHTMLOptionElementFactory *iface,
                                                               REFIID riid, void **ppv)
 {
-    HTMLOptionElementFactory *This = impl_from_IHTMLOptionElementFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLOptionElementFactory(iface);
 
     TRACE("(%p)->(%s %p)\n", This, debugstr_mshtml_guid(riid), ppv);
 
@@ -476,7 +477,7 @@ static HRESULT WINAPI HTMLOptionElementFactory_QueryInterface(IHTMLOptionElement
 
 static ULONG WINAPI HTMLOptionElementFactory_AddRef(IHTMLOptionElementFactory *iface)
 {
-    HTMLOptionElementFactory *This = impl_from_IHTMLOptionElementFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLOptionElementFactory(iface);
     LONG ref = InterlockedIncrement(&This->ref);
 
     TRACE("(%p) ref=%ld\n", This, ref);
@@ -486,7 +487,7 @@ static ULONG WINAPI HTMLOptionElementFactory_AddRef(IHTMLOptionElementFactory *i
 
 static ULONG WINAPI HTMLOptionElementFactory_Release(IHTMLOptionElementFactory *iface)
 {
-    HTMLOptionElementFactory *This = impl_from_IHTMLOptionElementFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLOptionElementFactory(iface);
     LONG ref = InterlockedDecrement(&This->ref);
 
     TRACE("(%p) ref=%ld\n", This, ref);
@@ -501,14 +502,14 @@ static ULONG WINAPI HTMLOptionElementFactory_Release(IHTMLOptionElementFactory *
 
 static HRESULT WINAPI HTMLOptionElementFactory_GetTypeInfoCount(IHTMLOptionElementFactory *iface, UINT *pctinfo)
 {
-    HTMLOptionElementFactory *This = impl_from_IHTMLOptionElementFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLOptionElementFactory(iface);
     return IDispatchEx_GetTypeInfoCount(&This->dispex.IDispatchEx_iface, pctinfo);
 }
 
 static HRESULT WINAPI HTMLOptionElementFactory_GetTypeInfo(IHTMLOptionElementFactory *iface, UINT iTInfo,
                                               LCID lcid, ITypeInfo **ppTInfo)
 {
-    HTMLOptionElementFactory *This = impl_from_IHTMLOptionElementFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLOptionElementFactory(iface);
     return IDispatchEx_GetTypeInfo(&This->dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
 }
 
@@ -516,7 +517,7 @@ static HRESULT WINAPI HTMLOptionElementFactory_GetIDsOfNames(IHTMLOptionElementF
                                                 LPOLESTR *rgszNames, UINT cNames,
                                                 LCID lcid, DISPID *rgDispId)
 {
-    HTMLOptionElementFactory *This = impl_from_IHTMLOptionElementFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLOptionElementFactory(iface);
     return IDispatchEx_GetIDsOfNames(&This->dispex.IDispatchEx_iface, riid, rgszNames, cNames, lcid, rgDispId);
 }
 
@@ -524,7 +525,7 @@ static HRESULT WINAPI HTMLOptionElementFactory_Invoke(IHTMLOptionElementFactory
                             REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
                             VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
 {
-    HTMLOptionElementFactory *This = impl_from_IHTMLOptionElementFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLOptionElementFactory(iface);
     return IDispatchEx_Invoke(&This->dispex.IDispatchEx_iface, dispIdMember, riid, lcid, wFlags, pDispParams,
             pVarResult, pExcepInfo, puArgErr);
 }
@@ -533,7 +534,7 @@ static HRESULT WINAPI HTMLOptionElementFactory_create(IHTMLOptionElementFactory
         VARIANT text, VARIANT value, VARIANT defaultselected, VARIANT selected,
         IHTMLOptionElement **optelem)
 {
-    HTMLOptionElementFactory *This = impl_from_IHTMLOptionElementFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLOptionElementFactory(iface);
     nsIDOMElement *nselem;
     HTMLDOMNode *node;
     HRESULT hres;
@@ -579,7 +580,7 @@ static HRESULT WINAPI HTMLOptionElementFactory_create(IHTMLOptionElementFactory
     return S_OK;
 }
 
-static const IHTMLOptionElementFactoryVtbl HTMLOptionElementFactoryVtbl = {
+const IHTMLOptionElementFactoryVtbl HTMLOptionElementFactoryVtbl = {
     HTMLOptionElementFactory_QueryInterface,
     HTMLOptionElementFactory_AddRef,
     HTMLOptionElementFactory_Release,
@@ -590,25 +591,23 @@ static const IHTMLOptionElementFactoryVtbl HTMLOptionElementFactoryVtbl = {
     HTMLOptionElementFactory_create
 };
 
-static inline HTMLOptionElementFactory *HTMLOptionElementFactory_from_DispatchEx(DispatchEx *iface)
+static inline struct compat_ctor *HTMLOptionElementFactory_from_DispatchEx(DispatchEx *iface)
 {
-    return CONTAINING_RECORD(iface, HTMLOptionElementFactory, dispex);
+    return CONTAINING_RECORD(iface, struct compat_ctor, dispex);
 }
 
 static HRESULT HTMLOptionElementFactory_value(DispatchEx *dispex, LCID lcid,
         WORD flags, DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei,
         IServiceProvider *caller)
 {
-    HTMLOptionElementFactory *This = HTMLOptionElementFactory_from_DispatchEx(dispex);
+    struct compat_ctor *This = HTMLOptionElementFactory_from_DispatchEx(dispex);
     unsigned int i, argc = params->cArgs - params->cNamedArgs;
     IHTMLOptionElement *opt;
     VARIANT empty, *arg[4];
     HRESULT hres;
 
-    if(flags != DISPATCH_CONSTRUCT) {
-        FIXME("flags %x not supported\n", flags);
-        return E_NOTIMPL;
-    }
+    if(flags != DISPATCH_CONSTRUCT)
+        return S_FALSE;
 
     V_VT(res) = VT_NULL;
     V_VT(&empty) = VT_EMPTY;
@@ -634,42 +633,50 @@ static const tid_t HTMLOptionElementFactory_iface_tids[] = {
 
 static const dispex_static_data_vtbl_t HTMLOptionElementFactory_dispex_vtbl = {
     HTMLOptionElementFactory_value,
-    NULL,
-    NULL,
-    NULL
+    compat_ctor_get_dispid,
+    compat_ctor_invoke,
+    compat_ctor_delete
 };
 
-static dispex_static_data_t HTMLOptionElementFactory_dispex = {
-    L"Function",
+dispex_static_data_t HTMLOptionElementFactory_dispex = {
+    L"HTMLOptionElement",
     &HTMLOptionElementFactory_dispex_vtbl,
+    PROTO_ID_NULL,
     IHTMLOptionElementFactory_tid,
     HTMLOptionElementFactory_iface_tids,
     HTMLElement_init_dispex_info
 };
 
-HRESULT HTMLOptionElementFactory_Create(HTMLInnerWindow *window, HTMLOptionElementFactory **ret_ptr)
+static HRESULT HTMLOptionCtor_value(DispatchEx *iface, LCID lcid, WORD flags, DISPPARAMS *params,
+        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
-    HTMLOptionElementFactory *ret;
+    if(flags == DISPATCH_CONSTRUCT)
+        return HTMLOptionElementFactory_value(iface, lcid, flags, params, res, ei, caller);
 
-    ret = heap_alloc(sizeof(*ret));
-    if(!ret)
-        return E_OUTOFMEMORY;
-
-    ret->IHTMLOptionElementFactory_iface.lpVtbl = &HTMLOptionElementFactoryVtbl;
-    ret->ref = 1;
-    ret->window = window;
+    return compat_ctor_value(iface, lcid, flags, params, res, ei, caller);
+}
 
-    init_dispatch(&ret->dispex, (IUnknown*)&ret->IHTMLOptionElementFactory_iface,
-                  &HTMLOptionElementFactory_dispex, dispex_compat_mode(&window->event_target.dispex));
+static const dispex_static_data_vtbl_t HTMLOptionCtor_dispex_vtbl = {
+    HTMLOptionCtor_value,
+    compat_ctor_get_dispid,
+    compat_ctor_invoke,
+    compat_ctor_delete
+};
 
-    *ret_ptr = ret;
-    return S_OK;
-}
+dispex_static_data_t HTMLOptionCtor_dispex = {
+    L"HTMLOptionElement",
+    &HTMLOptionCtor_dispex_vtbl,
+    PROTO_ID_NULL,
+    IHTMLOptionElementFactory_tid,
+    HTMLOptionElementFactory_iface_tids,
+    HTMLElement_init_dispex_info
+};
 
 struct HTMLSelectElement {
     HTMLElement element;
 
     IHTMLSelectElement IHTMLSelectElement_iface;
+    IWineHTMLInputPrivate IWineHTMLInputPrivate_iface;
 
     nsIDOMHTMLSelectElement *nsselect;
 };
@@ -1337,6 +1344,128 @@ static const IHTMLSelectElementVtbl HTMLSelectElementVtbl = {
     HTMLSelectElement_tags
 };
 
+static inline HTMLSelectElement *impl_from_IWineHTMLInputPrivateVtbl(IWineHTMLInputPrivate *iface)
+{
+    return CONTAINING_RECORD(iface, HTMLSelectElement, IWineHTMLInputPrivate_iface);
+}
+
+static HRESULT WINAPI HTMLSelectElement_input_private_QueryInterface(IWineHTMLInputPrivate *iface,
+        REFIID riid, void **ppv)
+{
+    HTMLSelectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IHTMLDOMNode_QueryInterface(&This->element.node.IHTMLDOMNode_iface, riid, ppv);
+}
+
+static ULONG WINAPI HTMLSelectElement_input_private_AddRef(IWineHTMLInputPrivate *iface)
+{
+    HTMLSelectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IHTMLDOMNode_AddRef(&This->element.node.IHTMLDOMNode_iface);
+}
+
+static ULONG WINAPI HTMLSelectElement_input_private_Release(IWineHTMLInputPrivate *iface)
+{
+    HTMLSelectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IHTMLDOMNode_Release(&This->element.node.IHTMLDOMNode_iface);
+}
+
+static HRESULT WINAPI HTMLSelectElement_input_private_GetTypeInfoCount(IWineHTMLInputPrivate *iface, UINT *pctinfo)
+{
+    HTMLSelectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IDispatchEx_GetTypeInfoCount(&This->element.node.event_target.dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI HTMLSelectElement_input_private_GetTypeInfo(IWineHTMLInputPrivate *iface, UINT iTInfo,
+                                              LCID lcid, ITypeInfo **ppTInfo)
+{
+    HTMLSelectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IDispatchEx_GetTypeInfo(&This->element.node.event_target.dispex.IDispatchEx_iface, iTInfo, lcid,
+            ppTInfo);
+}
+
+static HRESULT WINAPI HTMLSelectElement_input_private_GetIDsOfNames(IWineHTMLInputPrivate *iface, REFIID riid,
+                                                LPOLESTR *rgszNames, UINT cNames,
+                                                LCID lcid, DISPID *rgDispId)
+{
+    HTMLSelectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IDispatchEx_GetIDsOfNames(&This->element.node.event_target.dispex.IDispatchEx_iface, riid, rgszNames,
+            cNames, lcid, rgDispId);
+}
+
+static HRESULT WINAPI HTMLSelectElement_input_private_Invoke(IWineHTMLInputPrivate *iface, DISPID dispIdMember,
+                            REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+                            VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    HTMLSelectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IDispatchEx_Invoke(&This->element.node.event_target.dispex.IDispatchEx_iface, dispIdMember, riid,
+            lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI HTMLSelectElement_input_private_put_autofocus(IWineHTMLInputPrivate *iface, VARIANT_BOOL v)
+{
+    HTMLSelectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%x)\n", This, v);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLSelectElement_input_private_get_autofocus(IWineHTMLInputPrivate *iface, VARIANT_BOOL *ret)
+{
+    HTMLSelectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLSelectElement_input_private_get_validationMessage(IWineHTMLInputPrivate *iface, BSTR *ret)
+{
+    HTMLSelectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLSelectElement_input_private_get_validity(IWineHTMLInputPrivate *iface, IDispatch **ret)
+{
+    HTMLSelectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLSelectElement_input_private_get_willValidate(IWineHTMLInputPrivate *iface, VARIANT_BOOL *ret)
+{
+    HTMLSelectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLSelectElement_input_private_setCustomValidity(IWineHTMLInputPrivate *iface, VARIANT *message)
+{
+    HTMLSelectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_variant(message));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLSelectElement_input_private_checkValidity(IWineHTMLInputPrivate *iface, VARIANT_BOOL *ret)
+{
+    HTMLSelectElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static const IWineHTMLInputPrivateVtbl WineHTMLInputPrivateVtbl = {
+    HTMLSelectElement_input_private_QueryInterface,
+    HTMLSelectElement_input_private_AddRef,
+    HTMLSelectElement_input_private_Release,
+    HTMLSelectElement_input_private_GetTypeInfoCount,
+    HTMLSelectElement_input_private_GetTypeInfo,
+    HTMLSelectElement_input_private_GetIDsOfNames,
+    HTMLSelectElement_input_private_Invoke,
+    HTMLSelectElement_input_private_put_autofocus,
+    HTMLSelectElement_input_private_get_autofocus,
+    HTMLSelectElement_input_private_get_validationMessage,
+    HTMLSelectElement_input_private_get_validity,
+    HTMLSelectElement_input_private_get_willValidate,
+    HTMLSelectElement_input_private_setCustomValidity,
+    HTMLSelectElement_input_private_checkValidity
+};
+
 static inline HTMLSelectElement *impl_from_HTMLDOMNode(HTMLDOMNode *iface)
 {
     return CONTAINING_RECORD(iface, HTMLSelectElement, element.node);
@@ -1357,6 +1486,9 @@ static HRESULT HTMLSelectElement_QI(HTMLDOMNode *iface, REFIID riid, void **ppv)
     }else if(IsEqualGUID(&IID_IHTMLSelectElement, riid)) {
         TRACE("(%p)->(IID_IHTMLSelectElement %p)\n", This, ppv);
         *ppv = &This->IHTMLSelectElement_iface;
+    }else if(IsEqualGUID(&IID_IWineHTMLInputPrivate, riid)) {
+        TRACE("(%p)->(IID_IWineHTMLInputPrivate_iface %p)\n", This, ppv);
+        *ppv = &This->IWineHTMLInputPrivate_iface;
     }
 
     if(*ppv) {
@@ -1400,8 +1532,8 @@ static HRESULT HTMLSelectElement_get_dispid(HTMLDOMNode *iface, BSTR name, DWORD
     return S_OK;
 }
 
-static HRESULT HTMLSelectElement_invoke(HTMLDOMNode *iface, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
-        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+static HRESULT HTMLSelectElement_invoke(HTMLDOMNode *iface, IDispatch *this_obj, DISPID id, LCID lcid, WORD flags,
+        DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
     HTMLSelectElement *This = impl_from_HTMLDOMNode(iface);
 
@@ -1473,18 +1605,27 @@ static const NodeImplVtbl HTMLSelectElementImplVtbl = {
     HTMLSelectElement_unlink
 };
 
+static void HTMLSelectElement_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
+{
+    HTMLElement_init_dispex_info(info, mode);
+
+    if(mode >= COMPAT_MODE_IE10)
+        dispex_info_add_interface(info, IWineHTMLInputPrivate_tid, NULL);
+}
+
 static const tid_t HTMLSelectElement_tids[] = {
     HTMLELEMENT_TIDS,
     IHTMLSelectElement_tid,
     0
 };
 
-static dispex_static_data_t HTMLSelectElement_dispex = {
+dispex_static_data_t HTMLSelectElement_dispex = {
     L"HTMLSelectElement",
     NULL,
+    PROTO_ID_HTMLSelectElement,
     DispHTMLSelectElement_tid,
     HTMLSelectElement_tids,
-    HTMLElement_init_dispex_info
+    HTMLSelectElement_init_dispex_info
 };
 
 HRESULT HTMLSelectElement_Create(HTMLDocumentNode *doc, nsIDOMElement *nselem, HTMLElement **elem)
@@ -1497,6 +1638,7 @@ HRESULT HTMLSelectElement_Create(HTMLDocumentNode *doc, nsIDOMElement *nselem, H
         return E_OUTOFMEMORY;
 
     ret->IHTMLSelectElement_iface.lpVtbl = &HTMLSelectElementVtbl;
+    ret->IWineHTMLInputPrivate_iface.lpVtbl = &WineHTMLInputPrivateVtbl;
     ret->element.node.vtbl = &HTMLSelectElementImplVtbl;
 
     HTMLElement_Init(&ret->element, doc, nselem, &HTMLSelectElement_dispex);
diff --git a/dlls/mshtml/htmlstorage.c b/dlls/mshtml/htmlstorage.c
index 95f7ae5cd16..6cdadde4fd8 100644
--- a/dlls/mshtml/htmlstorage.c
+++ b/dlls/mshtml/htmlstorage.c
@@ -194,14 +194,15 @@ static const tid_t HTMLStorage_iface_tids[] = {
     IHTMLStorage_tid,
     0
 };
-static dispex_static_data_t HTMLStorage_dispex = {
+dispex_static_data_t HTMLStorage_dispex = {
     L"Storage",
     NULL,
+    PROTO_ID_HTMLStorage,
     IHTMLStorage_tid,
     HTMLStorage_iface_tids
 };
 
-HRESULT create_html_storage(compat_mode_t compat_mode, IHTMLStorage **p)
+HRESULT create_html_storage(compat_mode_t compat_mode, HTMLDocumentNode *doc, IHTMLStorage **p)
 {
     HTMLStorage *storage;
 
@@ -211,7 +212,7 @@ HRESULT create_html_storage(compat_mode_t compat_mode, IHTMLStorage **p)
 
     storage->IHTMLStorage_iface.lpVtbl = &HTMLStorageVtbl;
     storage->ref = 1;
-    init_dispatch(&storage->dispex, (IUnknown*)&storage->IHTMLStorage_iface, &HTMLStorage_dispex, compat_mode);
+    init_dispatch(&storage->dispex, (IUnknown*)&storage->IHTMLStorage_iface, &HTMLStorage_dispex, doc, compat_mode);
 
     *p = &storage->IHTMLStorage_iface;
     return S_OK;
diff --git a/dlls/mshtml/htmlstyle.c b/dlls/mshtml/htmlstyle.c
index 44ac21c5f97..24367977ba8 100644
--- a/dlls/mshtml/htmlstyle.c
+++ b/dlls/mshtml/htmlstyle.c
@@ -109,6 +109,7 @@ static const WCHAR *overflow_values[] = {
 #define ATTR_REMOVE_COMMA   0x0010
 #define ATTR_NO_NULL        0x0020
 #define ATTR_COMPAT_IE10    0x0040
+#define ATTR_IN_CSSPROPERTIES 0x0080
 
 typedef struct {
     const WCHAR *name;
@@ -167,13 +168,13 @@ static const style_tbl_entry_t style_tbl[] = {
         L"background-position-x",
         DISPID_IHTMLCSSSTYLEDECLARATION_BACKGROUNDPOSITIONX,
         DISPID_A_BACKGROUNDPOSX,
-        ATTR_FIX_PX
+        ATTR_FIX_PX | ATTR_IN_CSSPROPERTIES
     },
     {
         L"background-position-y",
         DISPID_IHTMLCSSSTYLEDECLARATION_BACKGROUNDPOSITIONY,
         DISPID_A_BACKGROUNDPOSY,
-        ATTR_FIX_PX
+        ATTR_FIX_PX | ATTR_IN_CSSPROPERTIES
     },
     {
         L"background-repeat",
@@ -702,7 +703,7 @@ static const style_tbl_entry_t style_tbl[] = {
 
 C_ASSERT(ARRAY_SIZE(style_tbl) == STYLEID_MAX_VALUE);
 
-static const style_tbl_entry_t *lookup_style_tbl(CSSStyle *style, const WCHAR *name)
+static const style_tbl_entry_t *lookup_style_tbl_compat_mode(compat_mode_t compat_mode, const WCHAR *name)
 {
     int c, i, min = 0, max = ARRAY_SIZE(style_tbl)-1;
 
@@ -711,7 +712,7 @@ static const style_tbl_entry_t *lookup_style_tbl(CSSStyle *style, const WCHAR *n
 
         c = wcscmp(style_tbl[i].name, name);
         if(!c) {
-            if((style_tbl[i].flags & ATTR_COMPAT_IE10) && dispex_compat_mode(&style->dispex) < COMPAT_MODE_IE10)
+            if((style_tbl[i].flags & ATTR_COMPAT_IE10) && compat_mode < COMPAT_MODE_IE10)
                 return NULL;
             return style_tbl+i;
         }
@@ -725,6 +726,11 @@ static const style_tbl_entry_t *lookup_style_tbl(CSSStyle *style, const WCHAR *n
     return NULL;
 }
 
+static const style_tbl_entry_t *lookup_style_tbl(CSSStyle *style, const WCHAR *name)
+{
+    return lookup_style_tbl_compat_mode(dispex_compat_mode(&style->dispex), name);
+}
+
 static void fix_px_value(nsAString *nsstr)
 {
     const WCHAR *val, *ptr;
@@ -2980,6 +2986,7 @@ static HRESULT WINAPI HTMLStyle_removeAttribute(IHTMLStyle *iface, BSTR strAttri
     style_entry = lookup_style_tbl(&This->css_style, strAttributeName);
     if(!style_entry) {
         compat_mode_t compat_mode = dispex_compat_mode(&This->css_style.dispex);
+        IWineDispatchProxyCbPrivate *proxy = This->css_style.dispex.proxy;
         DISPID dispid;
         unsigned i;
 
@@ -2990,6 +2997,18 @@ static HRESULT WINAPI HTMLStyle_removeAttribute(IHTMLStyle *iface, BSTR strAttri
             return S_OK;
         }
 
+        if(proxy) {
+            DISPID underlying = proxy->lpVtbl->GetUnderlyingDispID(proxy, dispid);
+            hres = IDispatchEx_DeleteMemberByDispID((IDispatchEx*)proxy, dispid);
+            if(underlying == DISPID_UNKNOWN) {
+                if(FAILED(hres))
+                    return hres;
+                *pfSuccess = (hres == S_OK);
+                return S_OK;
+            }
+            dispid = underlying;
+        }
+
         for(i=0; i < ARRAY_SIZE(style_tbl); i++) {
             if(dispid == (compat_mode >= COMPAT_MODE_IE9
                           ? style_tbl[i].dispid : style_tbl[i].compat_dispid))
@@ -9969,19 +9988,20 @@ static inline CSSStyle *impl_from_DispatchEx(DispatchEx *dispex)
     return CONTAINING_RECORD(dispex, CSSStyle, dispex);
 }
 
-static HRESULT CSSStyle_get_dispid(DispatchEx *dispex, BSTR name, DWORD flags, DISPID *dispid)
+static HRESULT CSSStyle_get_static_dispid(compat_mode_t compat_mode, BSTR name, DWORD flags, DISPID *dispid)
 {
-    CSSStyle *This = impl_from_DispatchEx(dispex);
     const style_tbl_entry_t *style_entry;
 
-    style_entry = lookup_style_tbl(This, name);
+    /* Found in prototypes */
+    if(compat_mode >= COMPAT_MODE_IE9)
+        return DISP_E_UNKNOWNNAME;
+
+    style_entry = lookup_style_tbl_compat_mode(compat_mode, name);
     if(style_entry) {
-        DISPID id = dispex_compat_mode(dispex) >= COMPAT_MODE_IE9
-            ? style_entry->dispid : style_entry->compat_dispid;
-        if(id == DISPID_UNKNOWN)
+        if(style_entry->compat_dispid == DISPID_UNKNOWN)
             return DISP_E_UNKNOWNNAME;
 
-        *dispid = id;
+        *dispid = style_entry->compat_dispid;
         return S_OK;
     }
 
@@ -9998,9 +10018,10 @@ void CSSStyle_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
 
 const dispex_static_data_vtbl_t CSSStyle_dispex_vtbl = {
     NULL,
-    CSSStyle_get_dispid,
     NULL,
-    NULL
+    NULL,
+    NULL,
+    CSSStyle_get_static_dispid
 };
 
 static const tid_t HTMLStyle_iface_tids[] = {
@@ -10012,9 +10033,10 @@ static const tid_t HTMLStyle_iface_tids[] = {
     IHTMLStyle_tid,
     0
 };
-static dispex_static_data_t HTMLStyle_dispex = {
+dispex_static_data_t HTMLStyle_dispex = {
     L"MSStyleCSSProperties",
     &CSSStyle_dispex_vtbl,
+    PROTO_ID_HTMLStyle,
     DispHTMLStyle_tid,
     HTMLStyle_iface_tids,
     CSSStyle_init_dispex_info
@@ -10059,7 +10081,7 @@ static HRESULT get_style_from_elem(HTMLElement *elem, nsIDOMCSSStyleDeclaration
 }
 
 void init_css_style(CSSStyle *style, nsIDOMCSSStyleDeclaration *nsstyle, style_qi_t qi,
-                    dispex_static_data_t *dispex_info, compat_mode_t compat_mode)
+                    dispex_static_data_t *dispex_info, HTMLDocumentNode *doc, compat_mode_t compat_mode)
 {
     style->IHTMLCSSStyleDeclaration_iface.lpVtbl = &HTMLCSSStyleDeclarationVtbl;
     style->IHTMLCSSStyleDeclaration2_iface.lpVtbl = &HTMLCSSStyleDeclaration2Vtbl;
@@ -10069,7 +10091,7 @@ void init_css_style(CSSStyle *style, nsIDOMCSSStyleDeclaration *nsstyle, style_q
     nsIDOMCSSStyleDeclaration_AddRef(nsstyle);
 
     init_dispatch(&style->dispex, (IUnknown*)&style->IHTMLCSSStyleDeclaration_iface,
-                  dispex_info, compat_mode);
+                  dispex_info, doc, compat_mode);
 }
 
 HRESULT HTMLStyle_Create(HTMLElement *elem, HTMLStyle **ret)
@@ -10098,31 +10120,180 @@ HRESULT HTMLStyle_Create(HTMLElement *elem, HTMLStyle **ret)
     style->elem = elem;
 
     init_css_style(&style->css_style, nsstyle, HTMLStyle_QI, &HTMLStyle_dispex,
-                   dispex_compat_mode(&elem->node.event_target.dispex));
+                   elem->node.doc, dispex_compat_mode(&elem->node.event_target.dispex));
 
     *ret = style;
     return S_OK;
 }
 
+/* dummy dispex used only for MSCSSPropertiesPrototype in prototype chain */
+static HRESULT HTMLCSSProperties_get_static_dispid(compat_mode_t compat_mode, BSTR name, DWORD flags, DISPID *dispid)
+{
+    const style_tbl_entry_t *style_entry;
+
+    style_entry = lookup_style_tbl_compat_mode(compat_mode, name);
+    if(style_entry) {
+        if(style_entry->dispid == DISPID_UNKNOWN || !(style_entry->flags & ATTR_IN_CSSPROPERTIES))
+            return DISP_E_UNKNOWNNAME;
+
+        *dispid = style_entry->dispid;
+        return S_OK;
+    }
+
+    return DISP_E_UNKNOWNNAME;
+}
+
+static void HTMLCSSProperties_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
+{
+    static const dispex_hook_t style_hooks[] = {
+        {DISPID_IHTMLSTYLE_TEXTDECORATIONNONE},
+        {DISPID_IHTMLSTYLE_TEXTDECORATIONUNDERLINE},
+        {DISPID_IHTMLSTYLE_TEXTDECORATIONOVERLINE},
+        {DISPID_IHTMLSTYLE_TEXTDECORATIONLINETHROUGH},
+        {DISPID_IHTMLSTYLE_TEXTDECORATIONBLINK},
+        {DISPID_IHTMLSTYLE_PIXELTOP},
+        {DISPID_IHTMLSTYLE_PIXELLEFT},
+        {DISPID_IHTMLSTYLE_PIXELWIDTH},
+        {DISPID_IHTMLSTYLE_PIXELHEIGHT},
+        {DISPID_IHTMLSTYLE_POSTOP},
+        {DISPID_IHTMLSTYLE_POSLEFT},
+        {DISPID_IHTMLSTYLE_POSWIDTH},
+        {DISPID_IHTMLSTYLE_POSHEIGHT},
+        {DISPID_IHTMLSTYLE_TOSTRING},
+        {DISPID_UNKNOWN}
+    };
+    static const dispex_hook_t style2_hooks[] = {
+        {DISPID_IHTMLSTYLE2_SETEXPRESSION},
+        {DISPID_IHTMLSTYLE2_GETEXPRESSION},
+        {DISPID_IHTMLSTYLE2_REMOVEEXPRESSION},
+        {DISPID_IHTMLSTYLE2_PIXELBOTTOM},
+        {DISPID_IHTMLSTYLE2_PIXELRIGHT},
+        {DISPID_IHTMLSTYLE2_POSBOTTOM},
+        {DISPID_IHTMLSTYLE2_POSRIGHT},
+        {DISPID_UNKNOWN}
+    };
+
+    dispex_info_add_interface(info, IHTMLStyle6_tid, NULL);
+    dispex_info_add_interface(info, IHTMLStyle5_tid, NULL);
+    dispex_info_add_interface(info, IHTMLStyle3_tid, NULL);
+    dispex_info_add_interface(info, IHTMLStyle2_tid, style2_hooks);
+    dispex_info_add_interface(info, IHTMLStyle_tid, style_hooks);
+}
+
+const dispex_static_data_vtbl_t HTMLCSSProperties_dispex_vtbl = {
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    HTMLCSSProperties_get_static_dispid
+};
+
+dispex_static_data_t HTMLCSSProperties_dispex = {
+    L"MSCSSProperties",
+    &HTMLCSSProperties_dispex_vtbl,
+    PROTO_ID_HTMLCSSProperties,
+    NULL_tid,
+    no_iface_tids,
+    HTMLCSSProperties_init_dispex_info
+};
+
+static HRESULT HTMLW3CComputedStyle_get_static_dispid(compat_mode_t compat_mode, BSTR name, DWORD flags, DISPID *dispid)
+{
+    const style_tbl_entry_t *style_entry;
+    DISPID id;
+
+    style_entry = lookup_style_tbl_compat_mode(compat_mode, name);
+    if(style_entry) {
+        if(compat_mode < COMPAT_MODE_IE9)
+            id = style_entry->compat_dispid;
+        else {
+            if(style_entry->flags & ATTR_IN_CSSPROPERTIES)
+                return DISP_E_UNKNOWNNAME;
+            id = style_entry->dispid;
+        }
+        if(id == DISPID_UNKNOWN)
+            return DISP_E_UNKNOWNNAME;
+
+        *dispid = id;
+        return S_OK;
+    }
+
+    return DISP_E_UNKNOWNNAME;
+}
+
+void HTMLW3CComputedStyle_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
+{
+    /* don't expose props shared with children prototypes */
+    static const dispex_hook_t styledecl_hooks[] = {
+        {DISPID_IHTMLCSSSTYLEDECLARATION_BACKGROUNDPOSITIONX},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_BACKGROUNDPOSITIONY},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_STYLEFLOAT},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_IMEMODE},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_LAYOUTGRIDCHAR},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_LAYOUTGRIDLINE},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_LAYOUTGRIDMODE},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_LAYOUTGRIDTYPE},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_LAYOUTGRID},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_TEXTAUTOSPACE},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_LINEBREAK},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_TEXTJUSTIFYTRIM},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_TEXTKASHIDA},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_ACCELERATOR},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_LAYOUTFLOW},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_ZOOM},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_SCROLLBARBASECOLOR},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_SCROLLBARFACECOLOR},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_SCROLLBAR3DLIGHTCOLOR},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_SCROLLBARSHADOWCOLOR},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_SCROLLBARHIGHLIGHTCOLOR},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_SCROLLBARDARKSHADOWCOLOR},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_SCROLLBARARROWCOLOR},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_SCROLLBARTRACKCOLOR},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_WRITINGMODE},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_TEXTKASHIDASPACE},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_MSINTERPOLATIONMODE},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_MSBLOCKPROGRESSION},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_CLIPTOP},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_CLIPRIGHT},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_CLIPBOTTOM},
+        {DISPID_IHTMLCSSSTYLEDECLARATION_CLIPLEFT},
+        {DISPID_UNKNOWN}
+    };
+    if(mode >= COMPAT_MODE_IE9)
+        dispex_info_add_interface(info, IHTMLCSSStyleDeclaration_tid, styledecl_hooks);
+    if(mode >= COMPAT_MODE_IE10)
+        dispex_info_add_interface(info, IHTMLCSSStyleDeclaration2_tid, NULL);
+}
+
+const dispex_static_data_vtbl_t HTMLW3CComputedStyle_dispex_vtbl = {
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    HTMLW3CComputedStyle_get_static_dispid
+};
+
 static const tid_t HTMLW3CComputedStyle_iface_tids[] = {
     0
 };
-static dispex_static_data_t HTMLW3CComputedStyle_dispex = {
+dispex_static_data_t HTMLW3CComputedStyle_dispex = {
     L"CSSStyleDeclaration",
-    &CSSStyle_dispex_vtbl,
+    &HTMLW3CComputedStyle_dispex_vtbl,
+    PROTO_ID_HTMLW3CComputedStyle,
     DispHTMLW3CComputedStyle_tid,
     HTMLW3CComputedStyle_iface_tids,
-    CSSStyle_init_dispex_info
+    HTMLW3CComputedStyle_init_dispex_info
 };
 
-HRESULT create_computed_style(nsIDOMCSSStyleDeclaration *nsstyle, compat_mode_t compat_mode, IHTMLCSSStyleDeclaration **p)
+HRESULT create_computed_style(nsIDOMCSSStyleDeclaration *nsstyle, HTMLDocumentNode *doc,
+        compat_mode_t compat_mode, IHTMLCSSStyleDeclaration **p)
 {
     CSSStyle *style;
 
     if(!(style = heap_alloc_zero(sizeof(*style))))
         return E_OUTOFMEMORY;
 
-    init_css_style(style, nsstyle, NULL, &HTMLW3CComputedStyle_dispex, compat_mode);
+    init_css_style(style, nsstyle, NULL, &HTMLW3CComputedStyle_dispex, doc, compat_mode);
     *p = &style->IHTMLCSSStyleDeclaration_iface;
     return S_OK;
 }
diff --git a/dlls/mshtml/htmlstyle.h b/dlls/mshtml/htmlstyle.h
index e14c1274360..45e26840695 100644
--- a/dlls/mshtml/htmlstyle.h
+++ b/dlls/mshtml/htmlstyle.h
@@ -152,9 +152,10 @@ typedef enum {
 } styleid_t;
 
 HRESULT HTMLStyle_Create(HTMLElement*,HTMLStyle**) DECLSPEC_HIDDEN;
-HRESULT create_computed_style(nsIDOMCSSStyleDeclaration*,compat_mode_t,IHTMLCSSStyleDeclaration**) DECLSPEC_HIDDEN;
+HRESULT create_computed_style(nsIDOMCSSStyleDeclaration*,HTMLDocumentNode*,compat_mode_t,
+                              IHTMLCSSStyleDeclaration**) DECLSPEC_HIDDEN;
 void init_css_style(CSSStyle*,nsIDOMCSSStyleDeclaration*,style_qi_t,
-                    dispex_static_data_t*,compat_mode_t) DECLSPEC_HIDDEN;
+                    dispex_static_data_t*,HTMLDocumentNode*,compat_mode_t) DECLSPEC_HIDDEN;
 
 void CSSStyle_init_dispex_info(dispex_data_t *info, compat_mode_t mode) DECLSPEC_HIDDEN;
 extern const dispex_static_data_vtbl_t CSSStyle_dispex_vtbl DECLSPEC_HIDDEN;
diff --git a/dlls/mshtml/htmlstyleelem.c b/dlls/mshtml/htmlstyleelem.c
index 1b1297ea5eb..b887e1c5fd0 100644
--- a/dlls/mshtml/htmlstyleelem.c
+++ b/dlls/mshtml/htmlstyleelem.c
@@ -199,8 +199,7 @@ static HRESULT WINAPI HTMLStyleElement_get_styleSheet(IHTMLStyleElement *iface,
         assert(nsres == NS_OK);
 
         if(ss) {
-            HRESULT hres = create_style_sheet(ss, dispex_compat_mode(&This->element.node.event_target.dispex),
-                                              &This->style_sheet);
+            HRESULT hres = create_style_sheet(ss, This->element.node.doc, &This->style_sheet);
             nsIDOMStyleSheet_Release(ss);
             if(FAILED(hres))
                 return hres;
@@ -461,9 +460,10 @@ static const tid_t HTMLStyleElement_iface_tids[] = {
     HTMLELEMENT_TIDS,
     0
 };
-static dispex_static_data_t HTMLStyleElement_dispex = {
+dispex_static_data_t HTMLStyleElement_dispex = {
     L"HTMLStyleElement",
     NULL,
+    PROTO_ID_HTMLStyleElement,
     DispHTMLStyleElement_tid,
     HTMLStyleElement_iface_tids,
     HTMLStyleElement_init_dispex_info
diff --git a/dlls/mshtml/htmlstylesheet.c b/dlls/mshtml/htmlstylesheet.c
index 2d76e370ed2..7df4570a8c9 100644
--- a/dlls/mshtml/htmlstylesheet.c
+++ b/dlls/mshtml/htmlstylesheet.c
@@ -24,6 +24,7 @@
 #include "winbase.h"
 #include "winuser.h"
 #include "ole2.h"
+#include "mshtmdid.h"
 
 #include "wine/debug.h"
 
@@ -38,6 +39,7 @@ struct HTMLStyleSheet {
 
     LONG ref;
 
+    HTMLDocumentNode *doc;
     nsIDOMCSSStyleSheet *nsstylesheet;
 };
 
@@ -47,6 +49,7 @@ struct HTMLStyleSheetsCollection {
 
     LONG ref;
 
+    HTMLDocumentNode *doc;
     nsIDOMStyleSheetList *nslist;
 };
 
@@ -65,12 +68,14 @@ struct HTMLStyleSheetRulesCollection {
 
     LONG ref;
 
+    HTMLDocumentNode *doc;
     nsIDOMCSSRuleList *nslist;
 };
 
 struct HTMLStyleSheetRule {
     DispatchEx dispex;
     IHTMLStyleSheetRule IHTMLStyleSheetRule_iface;
+    IHTMLCSSRule IHTMLCSSRule_iface;
 
     LONG ref;
 
@@ -206,19 +211,129 @@ static const IHTMLStyleSheetRuleVtbl HTMLStyleSheetRuleVtbl = {
     HTMLStyleSheetRule_get_readOnly
 };
 
+static inline HTMLStyleSheetRule *impl_from_IHTMLCSSRule(IHTMLCSSRule *iface)
+{
+    return CONTAINING_RECORD(iface, HTMLStyleSheetRule, IHTMLCSSRule_iface);
+}
+
+static HRESULT WINAPI HTMLCSSRule_QueryInterface(IHTMLCSSRule *iface, REFIID riid, void **ppv)
+{
+    HTMLStyleSheetRule *This = impl_from_IHTMLCSSRule(iface);
+    return IHTMLStyleSheetRule_QueryInterface(&This->IHTMLStyleSheetRule_iface, riid, ppv);
+}
+
+static ULONG WINAPI HTMLCSSRule_AddRef(IHTMLCSSRule *iface)
+{
+    HTMLStyleSheetRule *This = impl_from_IHTMLCSSRule(iface);
+    return IHTMLStyleSheetRule_AddRef(&This->IHTMLStyleSheetRule_iface);
+}
+
+static ULONG WINAPI HTMLCSSRule_Release(IHTMLCSSRule *iface)
+{
+    HTMLStyleSheetRule *This = impl_from_IHTMLCSSRule(iface);
+    return IHTMLStyleSheetRule_Release(&This->IHTMLStyleSheetRule_iface);
+}
+
+static HRESULT WINAPI HTMLCSSRule_GetTypeInfoCount(
+        IHTMLCSSRule *iface, UINT *pctinfo)
+{
+    HTMLStyleSheetRule *This = impl_from_IHTMLCSSRule(iface);
+    return IDispatchEx_GetTypeInfoCount(&This->dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI HTMLCSSRule_GetTypeInfo(IHTMLCSSRule *iface, UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)
+{
+    HTMLStyleSheetRule *This = impl_from_IHTMLCSSRule(iface);
+    return IDispatchEx_GetTypeInfo(&This->dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
+}
+
+static HRESULT WINAPI HTMLCSSRule_GetIDsOfNames(IHTMLCSSRule *iface, REFIID riid, LPOLESTR *rgszNames,
+        UINT cNames, LCID lcid, DISPID *rgDispId)
+{
+    HTMLStyleSheetRule *This = impl_from_IHTMLCSSRule(iface);
+    return IDispatchEx_GetIDsOfNames(&This->dispex.IDispatchEx_iface, riid, rgszNames, cNames,
+            lcid, rgDispId);
+}
+
+static HRESULT WINAPI HTMLCSSRule_Invoke(IHTMLCSSRule *iface, DISPID dispIdMember, REFIID riid, LCID lcid,
+        WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    HTMLStyleSheetRule *This = impl_from_IHTMLCSSRule(iface);
+    return IDispatchEx_Invoke(&This->dispex.IDispatchEx_iface, dispIdMember, riid, lcid, wFlags,
+            pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI HTMLCSSRule_get_type(IHTMLCSSRule *iface, USHORT *p)
+{
+    HTMLStyleSheetRule *This = impl_from_IHTMLCSSRule(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCSSRule_put_cssText(IHTMLCSSRule *iface, BSTR v)
+{
+    HTMLStyleSheetRule *This = impl_from_IHTMLCSSRule(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_w(v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCSSRule_get_cssText(IHTMLCSSRule *iface, BSTR *p)
+{
+    HTMLStyleSheetRule *This = impl_from_IHTMLCSSRule(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCSSRule_get_parentRule(IHTMLCSSRule *iface, IHTMLCSSRule **p)
+{
+    HTMLStyleSheetRule *This = impl_from_IHTMLCSSRule(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLCSSRule_get_parentStyleSheet(IHTMLCSSRule *iface, IHTMLStyleSheet **p)
+{
+    HTMLStyleSheetRule *This = impl_from_IHTMLCSSRule(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static const IHTMLCSSRuleVtbl HTMLCSSRuleVtbl = {
+    HTMLCSSRule_QueryInterface,
+    HTMLCSSRule_AddRef,
+    HTMLCSSRule_Release,
+    HTMLCSSRule_GetTypeInfoCount,
+    HTMLCSSRule_GetTypeInfo,
+    HTMLCSSRule_GetIDsOfNames,
+    HTMLCSSRule_Invoke,
+    HTMLCSSRule_get_type,
+    HTMLCSSRule_put_cssText,
+    HTMLCSSRule_get_cssText,
+    HTMLCSSRule_get_parentRule,
+    HTMLCSSRule_get_parentStyleSheet
+};
+
+static void HTMLStyleSheetRule_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
+{
+    if(mode >= COMPAT_MODE_IE9)
+        dispex_info_add_interface(info, IHTMLCSSRule_tid, NULL);
+}
+
 static const tid_t HTMLStyleSheetRule_iface_tids[] = {
     IHTMLStyleSheetRule_tid,
     0
 };
-static dispex_static_data_t HTMLStyleSheetRule_dispex = {
+dispex_static_data_t HTMLStyleSheetRule_dispex = {
     L"CSSStyleRule",
     NULL,
+    PROTO_ID_HTMLStyleSheetRule,
     DispHTMLStyleSheetRule_tid,
-    HTMLStyleSheetRule_iface_tids
+    HTMLStyleSheetRule_iface_tids,
+    HTMLStyleSheetRule_init_dispex_info
 };
 
-static HRESULT create_style_sheet_rule(nsIDOMCSSRule *nsstylesheetrule, compat_mode_t compat_mode,
-                                       IHTMLStyleSheetRule **ret)
+static HRESULT create_style_sheet_rule(nsIDOMCSSRule *nsstylesheetrule, HTMLDocumentNode *doc,
+        compat_mode_t compat_mode, IHTMLStyleSheetRule **ret)
 {
     HTMLStyleSheetRule *rule;
     nsresult nsres;
@@ -227,11 +342,12 @@ static HRESULT create_style_sheet_rule(nsIDOMCSSRule *nsstylesheetrule, compat_m
         return E_OUTOFMEMORY;
 
     rule->IHTMLStyleSheetRule_iface.lpVtbl = &HTMLStyleSheetRuleVtbl;
+    rule->IHTMLCSSRule_iface.lpVtbl = &HTMLCSSRuleVtbl;
     rule->ref = 1;
     rule->nsstylesheetrule = NULL;
 
     init_dispatch(&rule->dispex, (IUnknown *)&rule->IHTMLStyleSheetRule_iface, &HTMLStyleSheetRule_dispex,
-                  compat_mode);
+                  doc, compat_mode);
 
     if (nsstylesheetrule)
     {
@@ -245,6 +361,21 @@ static HRESULT create_style_sheet_rule(nsIDOMCSSRule *nsstylesheetrule, compat_m
     return S_OK;
 }
 
+/* dummy dispex used only for StyleSheet in prototype chain */
+static void CSSRule_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
+{
+    dispex_info_add_interface(info, IHTMLCSSRule_tid, NULL);
+}
+
+dispex_static_data_t CSSRule_dispex = {
+    L"CSSRule",
+    NULL,
+    PROTO_ID_CSSRule,
+    NULL_tid,
+    no_iface_tids,
+    CSSRule_init_dispex_info
+};
+
 static inline HTMLStyleSheetRulesCollection *impl_from_IHTMLStyleSheetRulesCollection(IHTMLStyleSheetRulesCollection *iface)
 {
     return CONTAINING_RECORD(iface, HTMLStyleSheetRulesCollection, IHTMLStyleSheetRulesCollection_iface);
@@ -291,6 +422,7 @@ static ULONG WINAPI HTMLStyleSheetRulesCollection_Release(IHTMLStyleSheetRulesCo
     TRACE("(%p) ref=%ld\n", This, ref);
 
     if(!ref) {
+        htmldoc_release(&This->doc->basedoc);
         release_dispex(&This->dispex);
         if(This->nslist)
             nsIDOMCSSRuleList_Release(This->nslist);
@@ -367,7 +499,7 @@ static HRESULT WINAPI HTMLStyleSheetRulesCollection_item(IHTMLStyleSheetRulesCol
     if(!nsstylesheetrule)
         return E_INVALIDARG;
 
-    hres = create_style_sheet_rule(nsstylesheetrule, dispex_compat_mode(&This->dispex), p);
+    hres = create_style_sheet_rule(nsstylesheetrule, This->doc, dispex_compat_mode(&This->dispex), p);
     nsIDOMCSSRule_Release(nsstylesheetrule);
     return hres;
 }
@@ -410,8 +542,8 @@ static HRESULT HTMLStyleSheetRulesCollection_get_dispid(DispatchEx *dispex, BSTR
     return S_OK;
 }
 
-static HRESULT HTMLStyleSheetRulesCollection_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
-        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+static HRESULT HTMLStyleSheetRulesCollection_invoke(DispatchEx *dispex, IDispatch *this_obj, DISPID id, LCID lcid, WORD flags,
+        DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
     HTMLStyleSheetRulesCollection *This = HTMLStyleSheetRulesCollection_from_DispatchEx(dispex);
 
@@ -432,7 +564,7 @@ static HRESULT HTMLStyleSheetRulesCollection_invoke(DispatchEx *dispex, DISPID i
             return S_OK;
         }
 
-        hres = create_style_sheet_rule(nsstylesheetrule, dispex_compat_mode(&This->dispex), &stylesheetrule);
+        hres = create_style_sheet_rule(nsstylesheetrule, This->doc, dispex_compat_mode(&This->dispex), &stylesheetrule);
         nsIDOMCSSRule_Release(nsstylesheetrule);
         if(FAILED(hres))
             return hres;
@@ -459,15 +591,16 @@ static const tid_t HTMLStyleSheetRulesCollection_iface_tids[] = {
     IHTMLStyleSheetRulesCollection_tid,
     0
 };
-static dispex_static_data_t HTMLStyleSheetRulesCollection_dispex = {
+dispex_static_data_t HTMLStyleSheetRulesCollection_dispex = {
     L"MSCSSRuleList",
     &HTMLStyleSheetRulesCollection_dispex_vtbl,
+    PROTO_ID_HTMLStyleSheetRulesCollection,
     DispHTMLStyleSheetRulesCollection_tid,
     HTMLStyleSheetRulesCollection_iface_tids
 };
 
-static HRESULT create_style_sheet_rules_collection(nsIDOMCSSRuleList *nslist, compat_mode_t compat_mode,
-                                                   IHTMLStyleSheetRulesCollection **ret)
+static HRESULT create_style_sheet_rules_collection(nsIDOMCSSRuleList *nslist, HTMLDocumentNode *doc,
+        compat_mode_t compat_mode, IHTMLStyleSheetRulesCollection **ret)
 {
     HTMLStyleSheetRulesCollection *collection;
 
@@ -477,9 +610,12 @@ static HRESULT create_style_sheet_rules_collection(nsIDOMCSSRuleList *nslist, co
     collection->IHTMLStyleSheetRulesCollection_iface.lpVtbl = &HTMLStyleSheetRulesCollectionVtbl;
     collection->ref = 1;
     collection->nslist = nslist;
+    collection->doc = doc;
+    if(doc)
+        htmldoc_addref(&doc->basedoc);
 
     init_dispatch(&collection->dispex, (IUnknown*)&collection->IHTMLStyleSheetRulesCollection_iface,
-                  &HTMLStyleSheetRulesCollection_dispex, compat_mode);
+                  &HTMLStyleSheetRulesCollection_dispex, doc, compat_mode);
 
     if(nslist)
         nsIDOMCSSRuleList_AddRef(nslist);
@@ -660,6 +796,7 @@ static ULONG WINAPI HTMLStyleSheetsCollection_Release(IHTMLStyleSheetsCollection
     TRACE("(%p) ref=%ld\n", This, ref);
 
     if(!ref) {
+        htmldoc_release(&This->doc->basedoc);
         release_dispex(&This->dispex);
         if(This->nslist)
             nsIDOMStyleSheetList_Release(This->nslist);
@@ -761,7 +898,7 @@ static HRESULT WINAPI HTMLStyleSheetsCollection_item(IHTMLStyleSheetsCollection
             return E_INVALIDARG;
         }
 
-        hres = create_style_sheet(nsstylesheet, dispex_compat_mode(&This->dispex), &stylesheet);
+        hres = create_style_sheet(nsstylesheet, This->doc, &stylesheet);
         nsIDOMStyleSheet_Release(nsstylesheet);
         if(FAILED(hres))
             return hres;
@@ -821,8 +958,8 @@ static HRESULT HTMLStyleSheetsCollection_get_dispid(DispatchEx *dispex, BSTR nam
     return S_OK;
 }
 
-static HRESULT HTMLStyleSheetsCollection_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
-        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+static HRESULT HTMLStyleSheetsCollection_invoke(DispatchEx *dispex, IDispatch *this_obj, DISPID id, LCID lcid, WORD flags,
+        DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
     HTMLStyleSheetsCollection *This = HTMLStyleSheetsCollection_from_DispatchEx(dispex);
 
@@ -843,7 +980,7 @@ static HRESULT HTMLStyleSheetsCollection_invoke(DispatchEx *dispex, DISPID id, L
             return S_OK;
         }
 
-        hres = create_style_sheet(nsstylesheet, dispex_compat_mode(&This->dispex), &stylesheet);
+        hres = create_style_sheet(nsstylesheet, This->doc, &stylesheet);
         nsIDOMStyleSheet_Release(nsstylesheet);
         if(FAILED(hres))
             return hres;
@@ -870,16 +1007,18 @@ static const tid_t HTMLStyleSheetsCollection_iface_tids[] = {
     IHTMLStyleSheetsCollection_tid,
     0
 };
-static dispex_static_data_t HTMLStyleSheetsCollection_dispex = {
+dispex_static_data_t HTMLStyleSheetsCollection_dispex = {
     L"StyleSheetList",
     &HTMLStyleSheetsCollection_dispex_vtbl,
+    PROTO_ID_HTMLStyleSheetsCollection,
     DispHTMLStyleSheetsCollection_tid,
     HTMLStyleSheetsCollection_iface_tids
 };
 
-HRESULT create_style_sheet_collection(nsIDOMStyleSheetList *nslist, compat_mode_t compat_mode,
+HRESULT create_style_sheet_collection(nsIDOMStyleSheetList *nslist, HTMLDocumentNode *doc,
                                       IHTMLStyleSheetsCollection **ret)
 {
+    compat_mode_t compat_mode = doc ? dispex_compat_mode(&doc->node.event_target.dispex) : COMPAT_MODE_NONE;
     HTMLStyleSheetsCollection *collection;
 
     if(!(collection = heap_alloc(sizeof(HTMLStyleSheetsCollection))))
@@ -887,13 +1026,16 @@ HRESULT create_style_sheet_collection(nsIDOMStyleSheetList *nslist, compat_mode_
 
     collection->IHTMLStyleSheetsCollection_iface.lpVtbl = &HTMLStyleSheetsCollectionVtbl;
     collection->ref = 1;
+    collection->doc = doc;
+    if(doc)
+        htmldoc_addref(&doc->basedoc);
 
     if(nslist)
         nsIDOMStyleSheetList_AddRef(nslist);
     collection->nslist = nslist;
 
     init_dispatch(&collection->dispex, (IUnknown*)&collection->IHTMLStyleSheetsCollection_iface,
-                  &HTMLStyleSheetsCollection_dispex, compat_mode);
+                  &HTMLStyleSheetsCollection_dispex, doc, compat_mode);
 
     *ret = &collection->IHTMLStyleSheetsCollection_iface;
     return S_OK;
@@ -948,6 +1090,7 @@ static ULONG WINAPI HTMLStyleSheet_Release(IHTMLStyleSheet *iface)
     TRACE("(%p) ref=%ld\n", This, ref);
 
     if(!ref) {
+        htmldoc_release(&This->doc->basedoc);
         release_dispex(&This->dispex);
         if(This->nsstylesheet)
             nsIDOMCSSStyleSheet_Release(This->nsstylesheet);
@@ -1169,17 +1312,48 @@ static HRESULT WINAPI HTMLStyleSheet_put_cssText(IHTMLStyleSheet *iface, BSTR v)
     }while(NS_SUCCEEDED(nsres));
 
     if(v && *v) {
+        UINT32 i, depth, idx;
         nsAString nsstr;
-        UINT32 idx;
-
-        /* FIXME: This won't work for multiple rules in the string. */
-        nsAString_InitDepend(&nsstr, v);
-        nsres = nsIDOMCSSStyleSheet_InsertRule(This->nsstylesheet, &nsstr, 0, &idx);
-        nsAString_Finish(&nsstr);
-        if(NS_FAILED(nsres)) {
-            FIXME("InsertRule failed for string %s. Probably multiple rules passed.\n", debugstr_w(v));
-            return E_FAIL;
+        WCHAR *ws;
+
+        depth = 0;
+        ws = heap_alloc(sizeof(*ws) * (lstrlenW(v) + 1));
+        do
+        {
+            for (i = 0; v[i]; ++i)
+            {
+                ws[i] = v[i];
+                if (ws[i] == '{')
+                    ++depth;
+                else if (ws[i] == '}' && !--depth)
+                    break;
+            }
+            if (ws[i])
+                ws[++i] = 0;
+
+            v += i;
+
+            for (i = 0; ws[i]; ++i)
+                if (!iswspace(ws[i]))
+                    break;
+
+            if (!ws[i])
+            {
+                TRACE("Skipping empty part.\n");
+                continue;
+            }
+
+            nsAString_InitDepend(&nsstr, ws);
+            nsres = nsIDOMCSSStyleSheet_InsertRule(This->nsstylesheet, &nsstr, 0, &idx);
+            nsAString_Finish(&nsstr);
+
+            if(NS_FAILED(nsres))
+                FIXME("InsertRule failed for string %s.\n", debugstr_w(ws));
+            else
+                TRACE("Added rule %s.\n", debugstr_w(ws));
         }
+        while (*v);
+        heap_free(ws);
     }
 
     return S_OK;
@@ -1242,7 +1416,7 @@ static HRESULT WINAPI HTMLStyleSheet_get_rules(IHTMLStyleSheet *iface,
         return E_FAIL;
     }
 
-    hres = create_style_sheet_rules_collection(nslist, dispex_compat_mode(&This->dispex), p);
+    hres = create_style_sheet_rules_collection(nslist, This->doc, dispex_compat_mode(&This->dispex), p);
     nsIDOMCSSRuleList_Release(nslist);
     return hres;
 }
@@ -1440,16 +1614,18 @@ static const tid_t HTMLStyleSheet_iface_tids[] = {
     IHTMLStyleSheet_tid,
     0
 };
-static dispex_static_data_t HTMLStyleSheet_dispex = {
+dispex_static_data_t HTMLStyleSheet_dispex = {
     L"CSSStyleSheet",
     NULL,
+    PROTO_ID_HTMLStyleSheet,
     DispHTMLStyleSheet_tid,
     HTMLStyleSheet_iface_tids,
     HTMLStyleSheet_init_dispex_info
 };
 
-HRESULT create_style_sheet(nsIDOMStyleSheet *nsstylesheet, compat_mode_t compat_mode, IHTMLStyleSheet **ret)
+HRESULT create_style_sheet(nsIDOMStyleSheet *nsstylesheet, HTMLDocumentNode *doc, IHTMLStyleSheet **ret)
 {
+    compat_mode_t compat_mode = doc ? dispex_compat_mode(&doc->node.event_target.dispex) : COMPAT_MODE_NONE;
     HTMLStyleSheet *style_sheet;
     nsresult nsres;
 
@@ -1460,9 +1636,12 @@ HRESULT create_style_sheet(nsIDOMStyleSheet *nsstylesheet, compat_mode_t compat_
     style_sheet->IHTMLStyleSheet4_iface.lpVtbl = &HTMLStyleSheet4Vtbl;
     style_sheet->ref = 1;
     style_sheet->nsstylesheet = NULL;
+    style_sheet->doc = doc;
+    if(doc)
+        htmldoc_addref(&doc->basedoc);
 
     init_dispatch(&style_sheet->dispex, (IUnknown*)&style_sheet->IHTMLStyleSheet_iface,
-                  &HTMLStyleSheet_dispex, compat_mode);
+                  &HTMLStyleSheet_dispex, doc, compat_mode);
 
     if(nsstylesheet) {
         nsres = nsIDOMStyleSheet_QueryInterface(nsstylesheet, &IID_nsIDOMCSSStyleSheet,
@@ -1474,3 +1653,40 @@ HRESULT create_style_sheet(nsIDOMStyleSheet *nsstylesheet, compat_mode_t compat_
     *ret = &style_sheet->IHTMLStyleSheet_iface;
     return S_OK;
 }
+
+/* dummy dispex used only for StyleSheet in prototype chain */
+static void StyleSheet_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
+{
+    static const dispex_hook_t stylesheet_hooks[] = {
+        {DISPID_IHTMLSTYLESHEET_OWNINGELEMENT},
+        {DISPID_IHTMLSTYLESHEET_READONLY},
+        {DISPID_IHTMLSTYLESHEET_IMPORTS},
+        {DISPID_IHTMLSTYLESHEET_ID},
+        {DISPID_IHTMLSTYLESHEET_ADDIMPORT},
+        {DISPID_IHTMLSTYLESHEET_ADDRULE},
+        {DISPID_IHTMLSTYLESHEET_REMOVEIMPORT},
+        {DISPID_IHTMLSTYLESHEET_REMOVERULE},
+        {DISPID_IHTMLSTYLESHEET_CSSTEXT},
+        {DISPID_IHTMLSTYLESHEET_RULES},
+        {DISPID_UNKNOWN}
+    };
+    static const dispex_hook_t stylesheet4_hooks[] = {
+        {DISPID_IHTMLSTYLESHEET4_OWNERRULE},
+        {DISPID_IHTMLSTYLESHEET4_CSSRULES},
+        {DISPID_IHTMLSTYLESHEET4_INSERTRULE},
+        {DISPID_IHTMLSTYLESHEET4_DELETERULE},
+        {DISPID_UNKNOWN}
+    };
+
+    dispex_info_add_interface(info, IHTMLStyleSheet4_tid, stylesheet4_hooks);
+    dispex_info_add_interface(info, IHTMLStyleSheet_tid, stylesheet_hooks);
+}
+
+dispex_static_data_t StyleSheet_dispex = {
+    L"StyleSheet",
+    NULL,
+    PROTO_ID_StyleSheet,
+    NULL_tid,
+    no_iface_tids,
+    StyleSheet_init_dispex_info
+};
diff --git a/dlls/mshtml/htmltable.c b/dlls/mshtml/htmltable.c
index 6a64672a83a..5fa80bd754e 100644
--- a/dlls/mshtml/htmltable.c
+++ b/dlls/mshtml/htmltable.c
@@ -519,9 +519,10 @@ static const tid_t HTMLTableCell_iface_tids[] = {
     0
 };
 
-static dispex_static_data_t HTMLTableCell_dispex = {
+dispex_static_data_t HTMLTableCell_dispex = {
     L"HTMLTableDataCellElement",
     NULL,
+    PROTO_ID_HTMLTableCellElement,
     DispHTMLTableCell_tid,
     HTMLTableCell_iface_tids,
     HTMLElement_init_dispex_info
@@ -548,6 +549,21 @@ HRESULT HTMLTableCell_Create(HTMLDocumentNode *doc, nsIDOMElement *nselem, HTMLE
     return S_OK;
 }
 
+/* dummy dispex used only for HTMLTableCellElementPrototype in prototype chain */
+static void HTMLTableCellProt_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
+{
+    dispex_info_add_interface(info, IHTMLTableCell_tid, NULL);
+}
+
+dispex_static_data_t HTMLTableCellProt_dispex = {
+    L"HTMLTableCellElement",
+    NULL,
+    PROTO_ID_HTMLTableCellProt,
+    NULL_tid,
+    no_iface_tids,
+    HTMLTableCellProt_init_dispex_info
+};
+
 struct HTMLTableRow {
     HTMLElement element;
 
@@ -815,7 +831,7 @@ static HRESULT WINAPI HTMLTableRow_get_cells(IHTMLTableRow *iface, IHTMLElementC
         return E_FAIL;
     }
 
-    *p = create_collection_from_htmlcol(nscol, dispex_compat_mode(&This->element.node.event_target.dispex));
+    *p = create_collection_from_htmlcol(nscol, This->element.node.doc);
 
     nsIDOMHTMLCollection_Release(nscol);
     return S_OK;
@@ -964,9 +980,10 @@ static const tid_t HTMLTableRow_iface_tids[] = {
     0
 };
 
-static dispex_static_data_t HTMLTableRow_dispex = {
+dispex_static_data_t HTMLTableRow_dispex = {
     L"HTMLTableRowElement",
     NULL,
+    PROTO_ID_HTMLTableRowElement,
     DispHTMLTableRow_tid,
     HTMLTableRow_iface_tids,
     HTMLElement_init_dispex_info
@@ -1418,7 +1435,7 @@ static HRESULT WINAPI HTMLTable_get_rows(IHTMLTable *iface, IHTMLElementCollecti
         return E_FAIL;
     }
 
-    *p = create_collection_from_htmlcol(nscol, dispex_compat_mode(&This->element.node.event_target.dispex));
+    *p = create_collection_from_htmlcol(nscol, This->element.node.doc);
 
     nsIDOMHTMLCollection_Release(nscol);
     return S_OK;
@@ -1533,7 +1550,7 @@ static HRESULT WINAPI HTMLTable_get_tBodies(IHTMLTable *iface, IHTMLElementColle
         return E_FAIL;
     }
 
-    *p = create_collection_from_htmlcol(nscol, dispex_compat_mode(&This->element.node.event_target.dispex));
+    *p = create_collection_from_htmlcol(nscol, This->element.node.doc);
 
     nsIDOMHTMLCollection_Release(nscol);
     return S_OK;
@@ -1997,9 +2014,10 @@ static const tid_t HTMLTable_iface_tids[] = {
     0
 };
 
-static dispex_static_data_t HTMLTable_dispex = {
+dispex_static_data_t HTMLTable_dispex = {
     L"HTMLTableElement",
     NULL,
+    PROTO_ID_HTMLTableElement,
     DispHTMLTable_tid,
     HTMLTable_iface_tids,
     HTMLElement_init_dispex_info
diff --git a/dlls/mshtml/htmltextarea.c b/dlls/mshtml/htmltextarea.c
index 32a574ebcd5..645da3696db 100644
--- a/dlls/mshtml/htmltextarea.c
+++ b/dlls/mshtml/htmltextarea.c
@@ -35,6 +35,7 @@ struct HTMLTextAreaElement {
     HTMLElement element;
 
     IHTMLTextAreaElement IHTMLTextAreaElement_iface;
+    IWineHTMLInputPrivate IWineHTMLInputPrivate_iface;
 
     nsIDOMHTMLTextAreaElement *nstextarea;
 };
@@ -384,6 +385,128 @@ static const IHTMLTextAreaElementVtbl HTMLTextAreaElementVtbl = {
     HTMLTextAreaElement_createTextRange
 };
 
+static inline HTMLTextAreaElement *impl_from_IWineHTMLInputPrivateVtbl(IWineHTMLInputPrivate *iface)
+{
+    return CONTAINING_RECORD(iface, HTMLTextAreaElement, IWineHTMLInputPrivate_iface);
+}
+
+static HRESULT WINAPI HTMLTextAreaElement_input_private_QueryInterface(IWineHTMLInputPrivate *iface,
+        REFIID riid, void **ppv)
+{
+    HTMLTextAreaElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IHTMLDOMNode_QueryInterface(&This->element.node.IHTMLDOMNode_iface, riid, ppv);
+}
+
+static ULONG WINAPI HTMLTextAreaElement_input_private_AddRef(IWineHTMLInputPrivate *iface)
+{
+    HTMLTextAreaElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IHTMLDOMNode_AddRef(&This->element.node.IHTMLDOMNode_iface);
+}
+
+static ULONG WINAPI HTMLTextAreaElement_input_private_Release(IWineHTMLInputPrivate *iface)
+{
+    HTMLTextAreaElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IHTMLDOMNode_Release(&This->element.node.IHTMLDOMNode_iface);
+}
+
+static HRESULT WINAPI HTMLTextAreaElement_input_private_GetTypeInfoCount(IWineHTMLInputPrivate *iface, UINT *pctinfo)
+{
+    HTMLTextAreaElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IDispatchEx_GetTypeInfoCount(&This->element.node.event_target.dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI HTMLTextAreaElement_input_private_GetTypeInfo(IWineHTMLInputPrivate *iface, UINT iTInfo,
+                                              LCID lcid, ITypeInfo **ppTInfo)
+{
+    HTMLTextAreaElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IDispatchEx_GetTypeInfo(&This->element.node.event_target.dispex.IDispatchEx_iface, iTInfo, lcid,
+            ppTInfo);
+}
+
+static HRESULT WINAPI HTMLTextAreaElement_input_private_GetIDsOfNames(IWineHTMLInputPrivate *iface, REFIID riid,
+                                                LPOLESTR *rgszNames, UINT cNames,
+                                                LCID lcid, DISPID *rgDispId)
+{
+    HTMLTextAreaElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IDispatchEx_GetIDsOfNames(&This->element.node.event_target.dispex.IDispatchEx_iface, riid, rgszNames,
+            cNames, lcid, rgDispId);
+}
+
+static HRESULT WINAPI HTMLTextAreaElement_input_private_Invoke(IWineHTMLInputPrivate *iface, DISPID dispIdMember,
+                            REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+                            VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    HTMLTextAreaElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    return IDispatchEx_Invoke(&This->element.node.event_target.dispex.IDispatchEx_iface, dispIdMember, riid,
+            lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI HTMLTextAreaElement_input_private_put_autofocus(IWineHTMLInputPrivate *iface, VARIANT_BOOL v)
+{
+    HTMLTextAreaElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%x)\n", This, v);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLTextAreaElement_input_private_get_autofocus(IWineHTMLInputPrivate *iface, VARIANT_BOOL *ret)
+{
+    HTMLTextAreaElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLTextAreaElement_input_private_get_validationMessage(IWineHTMLInputPrivate *iface, BSTR *ret)
+{
+    HTMLTextAreaElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLTextAreaElement_input_private_get_validity(IWineHTMLInputPrivate *iface, IDispatch **ret)
+{
+    HTMLTextAreaElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLTextAreaElement_input_private_get_willValidate(IWineHTMLInputPrivate *iface, VARIANT_BOOL *ret)
+{
+    HTMLTextAreaElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLTextAreaElement_input_private_setCustomValidity(IWineHTMLInputPrivate *iface, VARIANT *message)
+{
+    HTMLTextAreaElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_variant(message));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLTextAreaElement_input_private_checkValidity(IWineHTMLInputPrivate *iface, VARIANT_BOOL *ret)
+{
+    HTMLTextAreaElement *This = impl_from_IWineHTMLInputPrivateVtbl(iface);
+    FIXME("(%p)->(%p)\n", This, ret);
+    return E_NOTIMPL;
+}
+
+static const IWineHTMLInputPrivateVtbl WineHTMLInputPrivateVtbl = {
+    HTMLTextAreaElement_input_private_QueryInterface,
+    HTMLTextAreaElement_input_private_AddRef,
+    HTMLTextAreaElement_input_private_Release,
+    HTMLTextAreaElement_input_private_GetTypeInfoCount,
+    HTMLTextAreaElement_input_private_GetTypeInfo,
+    HTMLTextAreaElement_input_private_GetIDsOfNames,
+    HTMLTextAreaElement_input_private_Invoke,
+    HTMLTextAreaElement_input_private_put_autofocus,
+    HTMLTextAreaElement_input_private_get_autofocus,
+    HTMLTextAreaElement_input_private_get_validationMessage,
+    HTMLTextAreaElement_input_private_get_validity,
+    HTMLTextAreaElement_input_private_get_willValidate,
+    HTMLTextAreaElement_input_private_setCustomValidity,
+    HTMLTextAreaElement_input_private_checkValidity
+};
+
 static inline HTMLTextAreaElement *impl_from_HTMLDOMNode(HTMLDOMNode *iface)
 {
     return CONTAINING_RECORD(iface, HTMLTextAreaElement, element.node);
@@ -404,6 +527,9 @@ static HRESULT HTMLTextAreaElement_QI(HTMLDOMNode *iface, REFIID riid, void **pp
     }else if(IsEqualGUID(&IID_IHTMLTextAreaElement, riid)) {
         TRACE("(%p)->(IID_IHTMLTextAreaElement %p)\n", This, ppv);
         *ppv = &This->IHTMLTextAreaElement_iface;
+    }else if(IsEqualGUID(&IID_IWineHTMLInputPrivate, riid)) {
+        TRACE("(%p)->(IID_IWineHTMLInputPrivate_iface %p)\n", This, ppv);
+        *ppv = &This->IWineHTMLInputPrivate_iface;
     }
 
     if(*ppv) {
@@ -472,18 +598,27 @@ static const NodeImplVtbl HTMLTextAreaElementImplVtbl = {
     HTMLTextAreaElement_is_text_edit
 };
 
+static void HTMLTextAreaElement_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
+{
+    HTMLElement_init_dispex_info(info, mode);
+
+    if(mode >= COMPAT_MODE_IE10)
+        dispex_info_add_interface(info, IWineHTMLInputPrivate_tid, NULL);
+}
+
 static const tid_t HTMLTextAreaElement_iface_tids[] = {
     HTMLELEMENT_TIDS,
     IHTMLTextAreaElement_tid,
     0
 };
 
-static dispex_static_data_t HTMLTextAreaElement_dispex = {
+dispex_static_data_t HTMLTextAreaElement_dispex = {
     L"HTMLTextAreaElement",
     NULL,
+    PROTO_ID_HTMLTextAreaElement,
     DispHTMLTextAreaElement_tid,
     HTMLTextAreaElement_iface_tids,
-    HTMLElement_init_dispex_info
+    HTMLTextAreaElement_init_dispex_info
 };
 
 HRESULT HTMLTextAreaElement_Create(HTMLDocumentNode *doc, nsIDOMElement *nselem, HTMLElement **elem)
@@ -496,6 +631,7 @@ HRESULT HTMLTextAreaElement_Create(HTMLDocumentNode *doc, nsIDOMElement *nselem,
         return E_OUTOFMEMORY;
 
     ret->IHTMLTextAreaElement_iface.lpVtbl = &HTMLTextAreaElementVtbl;
+    ret->IWineHTMLInputPrivate_iface.lpVtbl = &WineHTMLInputPrivateVtbl;
     ret->element.node.vtbl = &HTMLTextAreaElementImplVtbl;
 
     HTMLElement_Init(&ret->element, doc, nselem, &HTMLTextAreaElement_dispex);
diff --git a/dlls/mshtml/htmltextnode.c b/dlls/mshtml/htmltextnode.c
index 373515be444..427c423ec49 100644
--- a/dlls/mshtml/htmltextnode.c
+++ b/dlls/mshtml/htmltextnode.c
@@ -25,6 +25,7 @@
 #include "winbase.h"
 #include "winuser.h"
 #include "ole2.h"
+#include "mshtmdid.h"
 
 #include "mshtml_private.h"
 
@@ -40,6 +41,27 @@ struct HTMLDOMTextNode {
     nsIDOMText *nstext;
 };
 
+/* dummy dispex used only for CharacterDataPrototype in prototype chain */
+static void DOMCharacterData_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
+{
+    static const dispex_hook_t textnode_hooks[] = {
+        {DISPID_IHTMLDOMTEXTNODE_TOSTRING},
+        {DISPID_IHTMLDOMTEXTNODE_SPLITTEXT},
+        {DISPID_UNKNOWN}
+    };
+    dispex_info_add_interface(info, IHTMLDOMTextNode_tid, textnode_hooks);
+    dispex_info_add_interface(info, IHTMLDOMTextNode2_tid, NULL);
+}
+
+dispex_static_data_t DOMCharacterData_dispex = {
+    L"CharacterData",
+    NULL,
+    PROTO_ID_DOMCharacterData,
+    NULL_tid,
+    no_iface_tids,
+    DOMCharacterData_init_dispex_info
+};
+
 static inline HTMLDOMTextNode *impl_from_IHTMLDOMTextNode(IHTMLDOMTextNode *iface)
 {
     return CONTAINING_RECORD(iface, HTMLDOMTextNode, IHTMLDOMTextNode_iface);
@@ -365,9 +387,10 @@ static const tid_t HTMLDOMTextNode_iface_tids[] = {
     IHTMLDOMTextNode2_tid,
     0
 };
-static dispex_static_data_t HTMLDOMTextNode_dispex = {
+dispex_static_data_t HTMLDOMTextNode_dispex = {
     L"Text",
     NULL,
+    PROTO_ID_HTMLDOMTextNode,
     DispHTMLDOMTextNode_tid,
     HTMLDOMTextNode_iface_tids,
     HTMLDOMNode_init_dispex_info
diff --git a/dlls/mshtml/htmlwindow.c b/dlls/mshtml/htmlwindow.c
index ecd530db7e2..7179ff48137 100644
--- a/dlls/mshtml/htmlwindow.c
+++ b/dlls/mshtml/htmlwindow.c
@@ -25,6 +25,7 @@
 #include "winuser.h"
 #include "ole2.h"
 #include "mshtmdid.h"
+#include "wininet.h"
 #include "shlguid.h"
 #include "shobjidl.h"
 #include "exdispid.h"
@@ -138,11 +139,244 @@ static void detach_inner_window(HTMLInnerWindow *window)
     window->base.outer_window = NULL;
 
     if(outer_window && outer_window->base.inner_window == window) {
+        IWineDispatchProxyCbPrivate *proxy = window->event_target.dispex.proxy;
+
+        if(proxy) {
+            /* NULL it first to prevent it from possibly unlinking the saved proxy */
+            window->event_target.dispex.proxy = NULL;
+            proxy->lpVtbl->Relinked(proxy, NULL);
+        }
+        outer_window->saved_proxy = proxy;
         outer_window->base.inner_window = NULL;
         IHTMLWindow2_Release(&window->base.IHTMLWindow2_iface);
     }
 }
 
+static HRESULT get_compat_ctor(HTMLInnerWindow *window, compat_ctor_id_t ctor_id, prototype_id_t prot_id,
+        dispex_static_data_t *dispex, const void *vtbl, IDispatch **ret)
+{
+    struct compat_ctor *ctor = window->compat_ctors[ctor_id];
+
+    if(!ctor) {
+        ctor = heap_alloc(sizeof(*ctor));
+        if(!ctor)
+            return E_OUTOFMEMORY;
+
+        ctor->IUnknown_iface.lpVtbl = vtbl;
+        ctor->ref = 1;
+        ctor->prot_id = prot_id;
+        ctor->window = window;
+        window->compat_ctors[ctor_id] = ctor;
+
+        init_dispatch(&ctor->dispex, &ctor->IUnknown_iface, dispex, NULL, dispex_compat_mode(&window->event_target.dispex));
+    }
+
+    *ret = (IDispatch*)&ctor->dispex.IDispatchEx_iface;
+    IDispatch_AddRef(*ret);
+    return S_OK;
+}
+
+static inline struct compat_ctor *compat_ctor_from_IUnknown(IUnknown *iface)
+{
+    return CONTAINING_RECORD(iface, struct compat_ctor, IUnknown_iface);
+}
+
+static inline struct compat_ctor *compat_ctor_from_IDispatch(IDispatch *iface)
+{
+    return CONTAINING_RECORD((IDispatchEx*)iface, struct compat_ctor, dispex.IDispatchEx_iface);
+}
+
+static HRESULT WINAPI compat_ctor_QueryInterface(IUnknown *iface, REFIID riid, void **ppv)
+{
+    struct compat_ctor *This = compat_ctor_from_IUnknown(iface);
+
+    TRACE("(%p)->(%s %p)\n", This, debugstr_mshtml_guid(riid), ppv);
+
+    if(IsEqualGUID(&IID_IUnknown, riid)) {
+        *ppv = &This->IUnknown_iface;
+    }else if(dispex_query_interface(&This->dispex, riid, ppv)) {
+        return *ppv ? S_OK : E_NOINTERFACE;
+    }else {
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown*)*ppv);
+    return S_OK;
+}
+
+static ULONG WINAPI compat_ctor_AddRef(IUnknown *iface)
+{
+    struct compat_ctor *This = compat_ctor_from_IUnknown(iface);
+    LONG ref = InterlockedIncrement(&This->ref);
+
+    TRACE("(%p) ref=%ld\n", This, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI compat_ctor_Release(IUnknown *iface)
+{
+    struct compat_ctor *This = compat_ctor_from_IUnknown(iface);
+    LONG ref = InterlockedDecrement(&This->ref);
+
+    TRACE("(%p) ref=%ld\n", This, ref);
+
+    if(!ref) {
+        release_dispex(&This->dispex);
+        heap_free(This);
+    }
+    return ref;
+}
+
+static const IUnknownVtbl compat_ctor_vtbl = {
+    compat_ctor_QueryInterface,
+    compat_ctor_AddRef,
+    compat_ctor_Release
+};
+
+static const dispex_static_data_vtbl_t compat_ctor_dispex_vtbl = {
+    compat_ctor_value,
+    compat_ctor_get_dispid,
+    compat_ctor_invoke,
+    compat_ctor_delete
+};
+
+static const struct {
+    const WCHAR *name;
+    prototype_id_t prototype_id;
+    prototype_id_t ctor_id;
+    dispex_static_data_t *dispex;
+    const void *vtbl;
+} special_ctor_static_data[] = {
+    { L"Image",             PROTO_ID_HTMLImgElement,        COMPAT_CTOR_ID_Image,               &HTMLImageCtor_dispex,          &HTMLImageElementFactoryVtbl },
+    { L"Option",            PROTO_ID_HTMLOptionElement,     COMPAT_CTOR_ID_Option,              &HTMLOptionCtor_dispex,         &HTMLOptionElementFactoryVtbl },
+ /* { L"XDomainRequest",    PROTO_ID_?,                     COMPAT_CTOR_ID_?,                   ?,                              ? } */
+    { L"XMLHttpRequest",    PROTO_ID_HTMLXMLHttpRequest,    COMPAT_CTOR_ID_HTMLXMLHttpRequest,  &HTMLXMLHttpRequestCtor_dispex, &HTMLXMLHttpRequestFactoryVtbl }
+};
+
+static struct {
+    dispex_static_data_t dispex;
+    prototype_id_t prototype_id;
+} compat_ctor_static_data[] = {
+#define X(name, proto_id)         \
+{                                 \
+    {                             \
+        L ## name,                \
+        &compat_ctor_dispex_vtbl, \
+        PROTO_ID_NULL,            \
+        NULL_tid,                 \
+        no_iface_tids             \
+    },                            \
+    proto_id                      \
+},
+    X("Attr",                        PROTO_ID_HTMLDOMAttribute)
+ /* X("BehaviorUrnsCollection",      PROTO_ID_?) */
+ /* X("BookmarkCollection",          PROTO_ID_?) */
+ /* X("CompatibleInfo",              PROTO_ID_?) */
+ /* X("CompatibleInfoCollection",    PROTO_ID_?) */
+ /* X("ControlRangeCollection",      PROTO_ID_?) */
+    X("CSSCurrentStyleDeclaration",  PROTO_ID_HTMLCurrentStyle)
+    X("CSSRuleList",                 PROTO_ID_HTMLStyleSheetRulesCollection)
+ /* X("CSSRuleStyleDeclaration",     PROTO_ID_?) */
+    X("CSSStyleDeclaration",         PROTO_ID_HTMLW3CComputedStyle)
+    X("CSSStyleRule",                PROTO_ID_HTMLStyleSheetRule)
+    X("CSSStyleSheet",               PROTO_ID_HTMLStyleSheet)
+ /* X("DataTransfer",                PROTO_ID_?) */
+    X("DOMImplementation",           PROTO_ID_HTMLDOMImplementation)
+    X("Element",                     PROTO_ID_HTMLElement)
+    X("Event",                       PROTO_ID_HTMLEventObj)
+    X("History",                     PROTO_ID_History)
+ /* X("HTCElementBehaviorDefaults",  PROTO_ID_?) */
+    X("HTMLAnchorElement",           PROTO_ID_HTMLAnchorElement)
+    X("HTMLAreaElement",             PROTO_ID_HTMLAreaElement)
+ /* X("HTMLAreasCollection",         PROTO_ID_?) */
+ /* X("HTMLBaseElement",             PROTO_ID_?) */
+ /* X("HTMLBaseFontElement",         PROTO_ID_?) */
+ /* X("HTMLBGSoundElement",          PROTO_ID_?) */
+ /* X("HTMLBlockElement",            PROTO_ID_?) */
+    X("HTMLBodyElement",             PROTO_ID_HTMLBodyElement)
+ /* X("HTMLBRElement",               PROTO_ID_?) */
+    X("HTMLButtonElement",           PROTO_ID_HTMLButtonElement)
+    X("HTMLCollection",              PROTO_ID_HTMLElementCollection)
+    X("HTMLCommentElement",          PROTO_ID_HTMLCommentElement)
+ /* X("HTMLDDElement",               PROTO_ID_?) */
+ /* X("HTMLDivElement",              PROTO_ID_?) */
+ /* X("HTMLDListElement",            PROTO_ID_?) */
+    X("HTMLDocument",                PROTO_ID_HTMLDocument)
+ /* X("HTMLDTElement",               PROTO_ID_?) */
+    X("HTMLEmbedElement",            PROTO_ID_HTMLEmbedElement)
+ /* X("HTMLFieldSetElement",         PROTO_ID_?) */
+ /* X("HTMLFontElement",             PROTO_ID_?) */
+    X("HTMLFormElement",             PROTO_ID_HTMLFormElement)
+    X("HTMLFrameElement",            PROTO_ID_HTMLFrameElement)
+ /* X("HTMLFrameSetElement",         PROTO_ID_?) */
+    X("HTMLGenericElement",          PROTO_ID_HTMLGenericElement)
+    X("HTMLHeadElement",             PROTO_ID_HTMLHeadElement)
+ /* X("HTMLHeadingElement",          PROTO_ID_?) */
+ /* X("HTMLHRElement",               PROTO_ID_?) */
+    X("HTMLHtmlElement",             PROTO_ID_HTMLHtmlElement)
+ /* X("HTMLIFrameElement",           PROTO_ID_?) */
+    X("HTMLImageElement",            PROTO_ID_HTMLImgElement)
+    X("HTMLInputElement",            PROTO_ID_HTMLInputElement)
+ /* X("HTMLIsIndexElement",          PROTO_ID_?) */
+    X("HTMLLabelElement",            PROTO_ID_HTMLLabelElement)
+ /* X("HTMLLegendElement",           PROTO_ID_?) */
+ /* X("HTMLLIElement",               PROTO_ID_?) */
+    X("HTMLLinkElement",             PROTO_ID_HTMLLinkElement)
+ /* X("HTMLMapElement",              PROTO_ID_?) */
+ /* X("HTMLMarqueeElement",          PROTO_ID_?) */
+    X("HTMLMetaElement",             PROTO_ID_HTMLMetaElement)
+ /* X("HTMLModelessDialog",          PROTO_ID_?) */
+ /* X("HTMLNamespaceInfo",           PROTO_ID_?) */
+    X("HTMLNamespaceInfoCollection", PROTO_ID_HTMLNamespaceCollection)
+ /* X("HTMLNextIdElement",           PROTO_ID_?) */
+ /* X("HTMLNoShowElement",           PROTO_ID_?) */
+    X("HTMLObjectElement",           PROTO_ID_HTMLObjectElement)
+ /* X("HTMLOListElement",            PROTO_ID_?) */
+    X("HTMLOptionElement",           PROTO_ID_HTMLOptionElement)
+ /* X("HTMLParagraphElement",        PROTO_ID_?) */
+ /* X("HTMLParamElement",            PROTO_ID_?) */
+ /* X("HTMLPhraseElement",           PROTO_ID_?) */
+    X("HTMLPluginsCollection",       PROTO_ID_HTMLPluginsCollection)
+ /* X("HTMLPopup",                   PROTO_ID_?) */
+    X("HTMLScriptElement",           PROTO_ID_HTMLScriptElement)
+    X("HTMLSelectElement",           PROTO_ID_HTMLSelectElement)
+ /* X("HTMLSpanElement",             PROTO_ID_?) */
+ /* X("HTMLStyleElement",            PROTO_ID_?) */
+ /* X("HTMLTableCaptionElement",     PROTO_ID_?) */
+    X("HTMLTableCellElement",        PROTO_ID_HTMLTableCellElement)
+ /* X("HTMLTableColElement",         PROTO_ID_?) */
+    X("HTMLTableElement",            PROTO_ID_HTMLTableElement)
+    X("HTMLTableRowElement",         PROTO_ID_HTMLTableRowElement)
+ /* X("HTMLTableSectionElement",     PROTO_ID_?) */
+    X("HTMLTextAreaElement",         PROTO_ID_HTMLTextAreaElement)
+ /* X("HTMLTextElement",             PROTO_ID_?) */
+    X("HTMLTitleElement",            PROTO_ID_HTMLTitleElement)
+ /* X("HTMLUListElement",            PROTO_ID_?) */
+    X("HTMLUnknownElement",          PROTO_ID_HTMLUnknownElement)
+    X("Location",                    PROTO_ID_HTMLLocation)
+    X("NamedNodeMap",                PROTO_ID_HTMLAttributeCollection)
+    X("Navigator",                   PROTO_ID_Navigator)
+    X("NodeList",                    PROTO_ID_HTMLDOMChildrenCollection)
+    X("Screen",                      PROTO_ID_HTMLScreen)
+    X("Selection",                   PROTO_ID_HTMLSelectionObject)
+ /* X("StaticNodeList",              PROTO_ID_?) */
+    X("Storage",                     PROTO_ID_HTMLStorage)
+    X("StyleSheetList",              PROTO_ID_HTMLStyleSheetsCollection)
+ /* X("StyleSheetPage",              PROTO_ID_?) */
+ /* X("StyleSheetPageList",          PROTO_ID_?) */
+    X("Text",                        PROTO_ID_HTMLDOMTextNode)
+    X("TextRange",                   PROTO_ID_HTMLTextRange)
+ /* X("TextRangeCollection",         PROTO_ID_?) */
+    X("TextRectangle",               PROTO_ID_HTMLRect)
+    X("TextRectangleList",           PROTO_ID_HTMLRectCollection)
+    X("Window",                      PROTO_ID_HTMLWindow)
+#undef X
+};
+
+enum { compat_ctor_props_num = ARRAY_SIZE(special_ctor_static_data) + ARRAY_SIZE(compat_ctor_static_data) };
+
 static inline HTMLWindow *impl_from_IHTMLWindow2(IHTMLWindow2 *iface)
 {
     return CONTAINING_RECORD(iface, HTMLWindow, IHTMLWindow2_iface);
@@ -160,6 +394,8 @@ static HRESULT WINAPI HTMLWindow2_QueryInterface(IHTMLWindow2 *iface, REFIID rii
         *ppv = &This->IHTMLWindow2_iface;
     }else if(IsEqualGUID(&IID_IDispatchEx, riid)) {
         *ppv = &This->IDispatchEx_iface;
+    }else if(IsEqualGUID(&IID_IWineDispatchProxyPrivate, riid)) {
+        *ppv = &This->IDispatchEx_iface;
     }else if(IsEqualGUID(&IID_IHTMLFramesCollection2, riid)) {
         *ppv = &This->IHTMLWindow2_iface;
     }else if(IsEqualGUID(&IID_IHTMLWindow2, riid)) {
@@ -236,6 +472,9 @@ static void release_outer_window(HTMLOuterWindow *This)
     if(This->base.inner_window)
         detach_inner_window(This->base.inner_window);
 
+    if(This->saved_proxy)
+        This->saved_proxy->lpVtbl->Unlinked(This->saved_proxy);
+
     if(This->frame_element)
         This->frame_element->content_window = NULL;
 
@@ -273,19 +512,18 @@ static void release_inner_window(HTMLInnerWindow *This)
         IHTMLLocation_Release(&This->location->IHTMLLocation_iface);
     }
 
-    if(This->image_factory) {
-        This->image_factory->window = NULL;
-        IHTMLImageElementFactory_Release(&This->image_factory->IHTMLImageElementFactory_iface);
-    }
-
-    if(This->option_factory) {
-        This->option_factory->window = NULL;
-        IHTMLOptionElementFactory_Release(&This->option_factory->IHTMLOptionElementFactory_iface);
+    for(i = 0; i < ARRAY_SIZE(This->compat_ctors); i++) {
+        if(This->compat_ctors[i]) {
+            This->compat_ctors[i]->window = NULL;
+            IUnknown_Release(&This->compat_ctors[i]->IUnknown_iface);
+        }
     }
 
-    if(This->xhr_factory) {
-        This->xhr_factory->window = NULL;
-        IHTMLXMLHttpRequestFactory_Release(&This->xhr_factory->IHTMLXMLHttpRequestFactory_iface);
+    for(i = 0; i < ARRAY_SIZE(This->compat_prototypes); i++) {
+        if(This->compat_prototypes[i]) {
+            This->compat_prototypes[i]->window = NULL;
+            IUnknown_Release(&This->compat_prototypes[i]->IUnknown_iface);
+        }
     }
 
     if(This->screen)
@@ -319,6 +557,8 @@ static ULONG WINAPI HTMLWindow2_Release(IHTMLWindow2 *iface)
     if(!ref) {
         if (This->console)
             IWineMSHTMLConsole_Release(This->console);
+        if (This->crypto)
+            IWineMSHTMLCrypto_Release(This->crypto);
 
         if(is_outer_window(This))
             release_outer_window(This->outer_window);
@@ -776,21 +1016,16 @@ static HRESULT WINAPI HTMLWindow2_get_Image(IHTMLWindow2 *iface, IHTMLImageEleme
 {
     HTMLWindow *This = impl_from_IHTMLWindow2(iface);
     HTMLInnerWindow *window = This->inner_window;
+    IDispatch *disp;
+    HRESULT hres;
 
     TRACE("(%p)->(%p)\n", This, p);
 
-    if(!window->image_factory) {
-        HRESULT hres;
-
-        hres = HTMLImageElementFactory_Create(window, &window->image_factory);
-        if(FAILED(hres))
-            return hres;
-    }
-
-    *p = &window->image_factory->IHTMLImageElementFactory_iface;
-    IHTMLImageElementFactory_AddRef(*p);
-
-    return S_OK;
+    hres = get_compat_ctor(window, COMPAT_CTOR_ID_Image_builtin, PROTO_ID_HTMLImgElement,
+                           &HTMLImageElementFactory_dispex, &HTMLImageElementFactoryVtbl, &disp);
+    if(SUCCEEDED(hres))
+        *p = &compat_ctor_from_IDispatch(disp)->IHTMLImageElementFactory_iface;
+    return hres;
 }
 
 static HRESULT WINAPI HTMLWindow2_get_location(IHTMLWindow2 *iface, IHTMLLocation **p)
@@ -931,7 +1166,7 @@ static HRESULT WINAPI HTMLWindow2_get_navigator(IHTMLWindow2 *iface, IOmNavigato
 
     if(!window->navigator) {
         HRESULT hres;
-        hres = create_navigator(dispex_compat_mode(&window->event_target.dispex), &window->navigator);
+        hres = create_navigator(window->doc, dispex_compat_mode(&window->event_target.dispex), &window->navigator);
         if(FAILED(hres))
             return hres;
     }
@@ -1320,7 +1555,7 @@ static HRESULT WINAPI HTMLWindow2_get_screen(IHTMLWindow2 *iface, IHTMLScreen **
     if(!window->screen) {
         HRESULT hres;
 
-        hres = create_html_screen(dispex_compat_mode(&window->event_target.dispex), &window->screen);
+        hres = create_html_screen(window->doc, dispex_compat_mode(&window->event_target.dispex), &window->screen);
         if(FAILED(hres))
             return hres;
     }
@@ -1334,21 +1569,16 @@ static HRESULT WINAPI HTMLWindow2_get_Option(IHTMLWindow2 *iface, IHTMLOptionEle
 {
     HTMLWindow *This = impl_from_IHTMLWindow2(iface);
     HTMLInnerWindow *window = This->inner_window;
+    IDispatch *disp;
+    HRESULT hres;
 
     TRACE("(%p)->(%p)\n", This, p);
 
-    if(!window->option_factory) {
-        HRESULT hres;
-
-        hres = HTMLOptionElementFactory_Create(window, &window->option_factory);
-        if(FAILED(hres))
-            return hres;
-    }
-
-    *p = &window->option_factory->IHTMLOptionElementFactory_iface;
-    IHTMLOptionElementFactory_AddRef(*p);
-
-    return S_OK;
+    hres = get_compat_ctor(window, COMPAT_CTOR_ID_Option_builtin, PROTO_ID_HTMLOptionElement,
+                           &HTMLOptionElementFactory_dispex, &HTMLOptionElementFactoryVtbl, &disp);
+    if(SUCCEEDED(hres))
+        *p = &compat_ctor_from_IDispatch(disp)->IHTMLOptionElementFactory_iface;
+    return hres;
 }
 
 static HRESULT WINAPI HTMLWindow2_focus(IHTMLWindow2 *iface)
@@ -2027,23 +2257,18 @@ static HRESULT WINAPI HTMLWindow5_get_XMLHttpRequest(IHTMLWindow5 *iface, VARIAN
 {
     HTMLWindow *This = impl_from_IHTMLWindow5(iface);
     HTMLInnerWindow *window = This->inner_window;
+    IDispatch *disp;
+    HRESULT hres;
 
     TRACE("(%p)->(%p)\n", This, p);
 
-    if(!window->xhr_factory) {
-        HRESULT hres;
-
-        hres = HTMLXMLHttpRequestFactory_Create(window, &window->xhr_factory);
-        if(FAILED(hres)) {
-            return hres;
-        }
+    hres = get_compat_ctor(window, COMPAT_CTOR_ID_HTMLXMLHttpRequest_builtin, PROTO_ID_HTMLXMLHttpRequest,
+                           &HTMLXMLHttpRequestFactory_dispex, &HTMLXMLHttpRequestFactoryVtbl, &disp);
+    if(SUCCEEDED(hres)) {
+        V_VT(p) = VT_DISPATCH;
+        V_DISPATCH(p) = (IDispatch*)&compat_ctor_from_IDispatch(disp)->IHTMLXMLHttpRequestFactory_iface;
     }
-
-    V_VT(p) = VT_DISPATCH;
-    V_DISPATCH(p) = (IDispatch*)&window->xhr_factory->IHTMLXMLHttpRequestFactory_iface;
-    IDispatch_AddRef(V_DISPATCH(p));
-
-    return S_OK;
+    return hres;
 }
 
 static const IHTMLWindow5Vtbl HTMLWindow5Vtbl = {
@@ -2143,7 +2368,7 @@ static HRESULT WINAPI HTMLWindow6_get_sessionStorage(IHTMLWindow6 *iface, IHTMLS
         HRESULT hres;
 
         hres = create_html_storage(dispex_compat_mode(&This->inner_window->event_target.dispex),
-                                   &This->inner_window->session_storage);
+                                   This->inner_window->doc, &This->inner_window->session_storage);
         if(FAILED(hres))
             return hres;
     }
@@ -2163,7 +2388,7 @@ static HRESULT WINAPI HTMLWindow6_get_localStorage(IHTMLWindow6 *iface, IHTMLSto
         HRESULT hres;
 
         hres = create_html_storage(dispex_compat_mode(&This->inner_window->event_target.dispex),
-                                   &This->inner_window->local_storage);
+                                   This->inner_window->doc, &This->inner_window->local_storage);
         if(FAILED(hres))
             return hres;
     }
@@ -2213,20 +2438,79 @@ static void post_message_destr(task_t *_task)
     IHTMLWindow2_Release(&task->window->base.IHTMLWindow2_iface);
 }
 
+static HRESULT check_target_origin(HTMLInnerWindow *window, const VARIANT *target_origin)
+{
+    URL_COMPONENTSW url = { sizeof(URL_COMPONENTSW) };
+    HRESULT hres;
+    DWORD port;
+    IUri *uri;
+    BSTR bstr;
+
+    if(V_VT(target_origin) != VT_BSTR)
+        return E_INVALIDARG;
+
+    if(!wcscmp(V_BSTR(target_origin), L"*"))
+        return S_OK;
+
+    url.dwSchemeLength = 1;
+    url.dwHostNameLength = 1;
+    if(!InternetCrackUrlW(V_BSTR(target_origin), 0, 0, &url)) {
+        SetLastError(ERROR_SUCCESS);
+        return E_INVALIDARG;
+    }
+
+    if(!window->base.outer_window || !(uri = window->base.outer_window->uri))
+        return S_OK;
+
+    hres = IUri_GetSchemeName(uri, &bstr);
+    if(FAILED(hres))
+        return hres;
+    if(SysStringLen(bstr) != url.dwSchemeLength || wcsnicmp(bstr, url.lpszScheme, url.dwSchemeLength))
+        hres = S_FALSE;
+    SysFreeString(bstr);
+    if(hres != S_OK)
+        return hres;
+
+    hres = IUri_GetHost(uri, &bstr);
+    if(FAILED(hres))
+        return hres;
+    if(SysStringLen(bstr) != url.dwHostNameLength || wcsnicmp(bstr, url.lpszHostName, url.dwHostNameLength))
+        hres = S_FALSE;
+    SysFreeString(bstr);
+    if(hres != S_OK)
+        return hres;
+
+    /* Legacy modes ignore port */
+    if(dispex_compat_mode(&window->event_target.dispex) < COMPAT_MODE_IE9)
+        return S_OK;
+
+    hres = IUri_GetPort(uri, &port);
+    if(FAILED(hres))
+        return hres;
+    return (port != url.nPort) ? S_FALSE : S_OK;
+}
+
 static HRESULT WINAPI HTMLWindow6_postMessage(IHTMLWindow6 *iface, BSTR msg, VARIANT targetOrigin)
 {
     HTMLWindow *This = impl_from_IHTMLWindow6(iface);
     DOMEvent *event;
     HRESULT hres;
+    VARIANT var;
+
+    TRACE("(%p)->(%s %s)\n", This, debugstr_w(msg), debugstr_variant(&targetOrigin));
 
-    FIXME("(%p)->(%s %s) semi-stub\n", This, debugstr_w(msg), debugstr_variant(&targetOrigin));
+    hres = check_target_origin(This->inner_window, &targetOrigin);
+    if(hres != S_OK)
+        return SUCCEEDED(hres) ? S_OK : hres;
 
     if(!This->inner_window->doc) {
         FIXME("No document\n");
         return E_FAIL;
     }
 
-    hres = create_message_event(This->inner_window->doc, msg, &event);
+    V_VT(&var) = VT_BSTR;
+    V_BSTR(&var) = msg;
+    hres = create_message_event(This->inner_window->doc, &var, &event);
     if(FAILED(hres))
         return hres;
 
@@ -2409,7 +2693,8 @@ static HRESULT WINAPI HTMLWindow7_getComputedStyle(IHTMLWindow7 *iface, IHTMLDOM
         return S_OK;
     }
 
-    hres = create_computed_style(nsstyle, dispex_compat_mode(&This->inner_window->event_target.dispex), p);
+    hres = create_computed_style(nsstyle, This->inner_window->doc,
+                                 dispex_compat_mode(&This->inner_window->event_target.dispex), p);
     nsIDOMCSSStyleDeclaration_Release(nsstyle);
     return hres;
 }
@@ -3152,6 +3437,20 @@ static HRESULT WINAPI window_private_requestAnimationFrame(IWineHTMLWindowPrivat
     return hres;
 }
 
+static HRESULT WINAPI window_private_cancelAnimationFrame(IWineHTMLWindowPrivate *iface, VARIANT timer_id)
+{
+    HTMLWindow *This = impl_from_IWineHTMLWindowPrivateVtbl(iface);
+    HRESULT hres;
+
+    TRACE("iface %p, timer_id %s\n", iface, debugstr_variant(&timer_id));
+
+    hres = VariantChangeType(&timer_id, &timer_id, 0, VT_I4);
+    if(SUCCEEDED(hres))
+        clear_animation_timer(This->inner_window, V_I4(&timer_id));
+
+    return S_OK;
+}
+
 static HRESULT WINAPI window_private_get_console(IWineHTMLWindowPrivate *iface, IDispatch **console)
 {
     HTMLWindow *This = impl_from_IWineHTMLWindowPrivateVtbl(iface);
@@ -3167,6 +3466,31 @@ static HRESULT WINAPI window_private_get_console(IWineHTMLWindowPrivate *iface,
     return S_OK;
 }
 
+static HRESULT WINAPI window_private_get_DOMParser(IWineHTMLWindowPrivate *iface, IDispatch **dom_parser)
+{
+    HTMLWindow *This = impl_from_IWineHTMLWindowPrivateVtbl(iface);
+
+    TRACE("iface %p, dom_parser %p.\n", iface, dom_parser);
+
+    return get_compat_ctor(This->inner_window, COMPAT_CTOR_ID_DOMParser, PROTO_ID_DOMParser,
+                           &DOMParserCtor_dispex, &compat_ctor_vtbl, dom_parser);
+}
+
+static HRESULT WINAPI window_private_get_msCrypto(IWineHTMLWindowPrivate *iface, IDispatch **crypto)
+{
+    HTMLWindow *This = impl_from_IWineHTMLWindowPrivateVtbl(iface);
+
+    TRACE("iface %p, crypto %p.\n", iface, crypto);
+
+    if(!This->crypto)
+        create_crypto(dispex_compat_mode(&This->inner_window->event_target.dispex), &This->crypto);
+
+    *crypto = (IDispatch*)This->crypto;
+    if(This->crypto)
+        IWineMSHTMLCrypto_AddRef(This->crypto);
+    return S_OK;
+}
+
 static const IWineHTMLWindowPrivateVtbl WineHTMLWindowPrivateVtbl = {
     window_private_QueryInterface,
     window_private_AddRef,
@@ -3176,7 +3500,10 @@ static const IWineHTMLWindowPrivateVtbl WineHTMLWindowPrivateVtbl = {
     window_private_GetIDsOfNames,
     window_private_Invoke,
     window_private_requestAnimationFrame,
+    window_private_cancelAnimationFrame,
     window_private_get_console,
+    window_private_get_DOMParser,
+    window_private_get_msCrypto,
 };
 
 static inline HTMLWindow *impl_from_IWineHTMLWindowCompatPrivateVtbl(IWineHTMLWindowCompatPrivate *iface)
@@ -3317,9 +3644,13 @@ static HRESULT WINAPI WindowDispEx_GetIDsOfNames(IDispatchEx *iface, REFIID riid
                                                  LCID lcid, DISPID *rgDispId)
 {
     HTMLWindow *This = impl_from_IDispatchEx(iface);
+    IWineDispatchProxyCbPrivate *proxy = This->inner_window->event_target.dispex.proxy;
     UINT i;
     HRESULT hres;
 
+    if(proxy)
+        return IDispatchEx_GetIDsOfNames((IDispatchEx*)proxy, riid, rgszNames, cNames, lcid, rgDispId);
+
     WARN("(%p)->(%s %p %u %lu %p)\n", This, debugstr_guid(riid), rgszNames, cNames, lcid, rgDispId);
 
     for(i=0; i < cNames; i++) {
@@ -3337,6 +3668,11 @@ static HRESULT WINAPI WindowDispEx_Invoke(IDispatchEx *iface, DISPID dispIdMembe
                             VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
 {
     HTMLWindow *This = impl_from_IDispatchEx(iface);
+    IWineDispatchProxyCbPrivate *proxy = This->inner_window->event_target.dispex.proxy;
+
+    if(proxy)
+        return IDispatchEx_Invoke((IDispatchEx*)proxy, dispIdMember, riid, lcid, wFlags,
+                                  pDispParams, pVarResult, pExcepInfo, puArgErr);
 
     TRACE("(%p)->(%ld %s %ld %d %p %p %p %p)\n", This, dispIdMember, debugstr_guid(riid),
           lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
@@ -3349,6 +3685,9 @@ static HRESULT WINAPI WindowDispEx_Invoke(IDispatchEx *iface, DISPID dispIdMembe
 
 static global_prop_t *alloc_global_prop(HTMLInnerWindow *This, global_prop_type_t type, BSTR name)
 {
+    if(This->global_prop_cnt > MSHTML_CUSTOM_DISPID_CNT - compat_ctor_props_num)
+        return NULL;
+
     if(This->global_prop_cnt == This->global_prop_size) {
         global_prop_t *new_props;
         DWORD new_size;
@@ -3410,26 +3749,44 @@ HRESULT search_window_props(HTMLInnerWindow *This, BSTR bstrName, DWORD grfdex,
     return DISP_E_UNKNOWNNAME;
 }
 
-static HRESULT WINAPI WindowDispEx_GetDispID(IDispatchEx *iface, BSTR bstrName, DWORD grfdex, DISPID *pid)
+static DISPID lookup_compat_ctor_prop(HTMLInnerWindow *window, BSTR name)
 {
-    HTMLWindow *This = impl_from_IDispatchEx(iface);
-    HTMLInnerWindow *window = This->inner_window;
-    HRESULT hres;
+    DWORD i, a = 0, b = ARRAY_SIZE(special_ctor_static_data);
+    int c;
 
-    TRACE("(%p)->(%s %lx %p)\n", This, debugstr_w(bstrName), grfdex, pid);
+    while(a < b) {
+        i = (a + b) / 2;
+        c = wcscmp(special_ctor_static_data[i].name, name);
+        if(!c)
+            return i + (MSHTML_DISPID_CUSTOM_MAX - compat_ctor_props_num + 1);
+        if(c > 0) b = i;
+        else      a = i + 1;
+    }
 
-    hres = search_window_props(window, bstrName, grfdex, pid);
-    if(hres != DISP_E_UNKNOWNNAME)
-        return hres;
+    if(dispex_compat_mode(&window->event_target.dispex) != COMPAT_MODE_IE8)
+        return DISPID_UNKNOWN;
+
+    a = 0, b = ARRAY_SIZE(compat_ctor_static_data);
+    while(a < b) {
+        i = (a + b) / 2;
+        c = wcscmp(compat_ctor_static_data[i].dispex.name, name);
+        if(!c)
+            return i + (MSHTML_DISPID_CUSTOM_MAX - ARRAY_SIZE(compat_ctor_static_data) + 1);
+        if(c > 0) b = i;
+        else      a = i + 1;
+    }
+    return DISPID_UNKNOWN;
+}
 
-    hres = IDispatchEx_GetDispID(&window->base.inner_window->event_target.dispex.IDispatchEx_iface, bstrName, grfdex, pid);
-    if(hres != DISP_E_UNKNOWNNAME)
-        return hres;
+static HRESULT lookup_custom_prop(HTMLWindow *html_window, BSTR bstrName, DISPID *pid)
+{
+    HTMLInnerWindow *window = html_window->inner_window;
+    HRESULT hres;
 
-    if(This->outer_window) {
+    if(html_window->outer_window) {
         HTMLOuterWindow *frame;
 
-        hres = get_frame_by_name(This->outer_window, bstrName, FALSE, &frame);
+        hres = get_frame_by_name(html_window->outer_window, bstrName, FALSE, &frame);
         if(SUCCEEDED(hres) && frame) {
             global_prop_t *prop;
 
@@ -3465,73 +3822,78 @@ static HRESULT WINAPI WindowDispEx_GetDispID(IDispatchEx *iface, BSTR bstrName,
     return DISP_E_UNKNOWNNAME;
 }
 
-static HRESULT WINAPI WindowDispEx_InvokeEx(IDispatchEx *iface, DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp,
-        VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
+static HRESULT WINAPI WindowDispEx_GetDispID(IDispatchEx *iface, BSTR bstrName, DWORD grfdex, DISPID *pid)
 {
     HTMLWindow *This = impl_from_IDispatchEx(iface);
     HTMLInnerWindow *window = This->inner_window;
+    IWineDispatchProxyCbPrivate *proxy = window->event_target.dispex.proxy;
+    HRESULT hres;
+    DISPID id;
 
-    TRACE("(%p)->(%lx %lx %x %p %p %p %p)\n", This, id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
-
-    switch(id) {
-    case DISPID_IHTMLWINDOW2_LOCATION: {
-        HTMLLocation *location;
-        HRESULT hres;
-
-        if(!(wFlags & DISPATCH_PROPERTYPUT))
-            break;
-
-        TRACE("forwarding to location.href\n");
+    if(proxy)
+        return IDispatchEx_GetDispID((IDispatchEx*)proxy, bstrName, grfdex, pid);
 
-        hres = get_location(window, &location);
-        if(FAILED(hres))
-            return hres;
+    TRACE("(%p)->(%s %lx %p)\n", This, debugstr_w(bstrName), grfdex, pid);
 
-        hres = IDispatchEx_InvokeEx(&location->dispex.IDispatchEx_iface, DISPID_VALUE, lcid,
-                wFlags, pdp, pvarRes, pei, pspCaller);
-        IHTMLLocation_Release(&location->IHTMLLocation_iface);
+    hres = search_window_props(window, bstrName, grfdex, pid);
+    if(hres != DISP_E_UNKNOWNNAME)
         return hres;
+
+    id = lookup_compat_ctor_prop(window, bstrName);
+    if(id != DISPID_UNKNOWN) {
+        *pid = id;
+        return S_OK;
     }
-    case DISPID_IHTMLWINDOW2_SETTIMEOUT:
-    case DISPID_IHTMLWINDOW3_SETTIMEOUT: {
-        VARIANT args[2];
-        DISPPARAMS dp = {args, NULL, 2, 0};
 
-        /*
-         * setTimeout calls should use default value 0 for the second argument if only one is provided,
-         * but IDL file does not reflect that. We fixup arguments here instead.
-         */
-        if(!(wFlags & DISPATCH_METHOD) || pdp->cArgs != 1 || pdp->cNamedArgs)
-            break;
+    hres = IDispatchEx_GetDispID(&window->base.inner_window->event_target.dispex.IDispatchEx_iface, bstrName, grfdex, pid);
+    if(hres != DISP_E_UNKNOWNNAME)
+        return hres;
 
-        TRACE("Fixing args\n");
+    return lookup_custom_prop(This, bstrName, pid);
+}
 
-        V_VT(args) = VT_I4;
-        V_I4(args) = 0;
-        args[1] = *pdp->rgvarg;
-        return IDispatchEx_InvokeEx(&window->event_target.dispex.IDispatchEx_iface, id, lcid,
-                wFlags, &dp, pvarRes, pei, pspCaller);
-    }
-    }
+static HRESULT WINAPI WindowDispEx_InvokeEx(IDispatchEx *iface, DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp,
+        VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
+{
+    HTMLWindow *This = impl_from_IDispatchEx(iface);
 
-    return IDispatchEx_InvokeEx(&window->event_target.dispex.IDispatchEx_iface, id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
+    return IDispatchEx_InvokeEx(&This->inner_window->event_target.dispex.IDispatchEx_iface, id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
 }
 
 static HRESULT WINAPI WindowDispEx_DeleteMemberByName(IDispatchEx *iface, BSTR bstrName, DWORD grfdex)
 {
     HTMLWindow *This = impl_from_IDispatchEx(iface);
+    IWineDispatchProxyCbPrivate *proxy = This->inner_window->event_target.dispex.proxy;
+
+    if(proxy)
+        return IDispatchEx_DeleteMemberByName((IDispatchEx*)proxy, bstrName, grfdex);
 
     TRACE("(%p)->(%s %lx)\n", This, debugstr_w(bstrName), grfdex);
 
+    if(lookup_compat_ctor_prop(This->inner_window, bstrName) != DISPID_UNKNOWN)
+        return MSHTML_E_INVALID_ACTION;
+
     return IDispatchEx_DeleteMemberByName(&This->inner_window->event_target.dispex.IDispatchEx_iface, bstrName, grfdex);
 }
 
 static HRESULT WINAPI WindowDispEx_DeleteMemberByDispID(IDispatchEx *iface, DISPID id)
 {
     HTMLWindow *This = impl_from_IDispatchEx(iface);
+    IWineDispatchProxyCbPrivate *proxy = This->inner_window->event_target.dispex.proxy;
+    DWORD idx;
+
+    if(proxy)
+        return IDispatchEx_DeleteMemberByDispID((IDispatchEx*)proxy, id);
 
     TRACE("(%p)->(%lx)\n", This, id);
 
+    idx = id - (MSHTML_DISPID_CUSTOM_MAX - compat_ctor_props_num + 1);
+    if(idx < compat_ctor_props_num) {
+        if(idx < ARRAY_SIZE(special_ctor_static_data) ||
+           dispex_compat_mode(&This->inner_window->event_target.dispex) == COMPAT_MODE_IE8)
+            return MSHTML_E_INVALID_ACTION;
+    }
+
     return IDispatchEx_DeleteMemberByDispID(&This->inner_window->event_target.dispex.IDispatchEx_iface, id);
 }
 
@@ -3573,7 +3935,136 @@ static HRESULT WINAPI WindowDispEx_GetNameSpaceParent(IDispatchEx *iface, IUnkno
     return S_OK;
 }
 
-static const IDispatchExVtbl WindowDispExVtbl = {
+static inline HTMLWindow *impl_from_IWineDispatchProxyPrivate(IWineDispatchProxyPrivate *iface)
+{
+    return impl_from_IDispatchEx((IDispatchEx*)iface);
+}
+
+static IWineDispatchProxyCbPrivate** WINAPI WindowWineDispProxyPrivate_GetProxyFieldRef(IWineDispatchProxyPrivate *iface)
+{
+    HTMLWindow *This = impl_from_IWineDispatchProxyPrivate(iface);
+    return &This->inner_window->event_target.dispex.proxy;
+}
+
+static IDispatch* WINAPI WindowWineDispProxyPrivate_GetDefaultPrototype(IWineDispatchProxyPrivate *iface, struct proxy_prototypes **prots_ref)
+{
+    HTMLWindow *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->inner_window->event_target.dispex.IDispatchEx_iface;
+
+    return itf->lpVtbl->GetDefaultPrototype(itf, prots_ref);
+}
+
+static IDispatch* WINAPI WindowWineDispProxyPrivate_GetDefaultConstructor(IWineDispatchProxyPrivate *iface, struct proxy_prototypes *prots)
+{
+    HTMLWindow *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->inner_window->event_target.dispex.IDispatchEx_iface;
+
+    return itf->lpVtbl->GetDefaultConstructor(itf, prots);
+}
+
+static HRESULT WINAPI WindowWineDispProxyPrivate_DefineConstructors(IWineDispatchProxyPrivate *iface, struct proxy_prototypes **prots_ref)
+{
+    HTMLWindow *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->inner_window->event_target.dispex.IDispatchEx_iface;
+
+    return itf->lpVtbl->DefineConstructors(itf, prots_ref);
+}
+
+static BOOL WINAPI WindowWineDispProxyPrivate_IsPrototype(IWineDispatchProxyPrivate *iface)
+{
+    HTMLWindow *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->inner_window->event_target.dispex.IDispatchEx_iface;
+
+    return itf->lpVtbl->IsPrototype(itf);
+}
+
+static BOOL WINAPI WindowWineDispProxyPrivate_IsConstructor(IWineDispatchProxyPrivate *iface)
+{
+    HTMLWindow *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->inner_window->event_target.dispex.IDispatchEx_iface;
+
+    return itf->lpVtbl->IsConstructor(itf);
+}
+
+static DWORD WINAPI WindowWineDispProxyPrivate_PropFlags(IWineDispatchProxyPrivate *iface, DISPID id)
+{
+    HTMLWindow *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->inner_window->event_target.dispex.IDispatchEx_iface;
+
+    switch(id) {
+    case DISPID_IHTMLWINDOW2_LOCATION: return PROPF_PROXY_ACCESSOR | PROPF_WRITABLE | PROPF_ENUMERABLE;
+    }
+
+    return itf->lpVtbl->PropFlags(itf, id);
+}
+
+static HRESULT WINAPI WindowWineDispProxyPrivate_PropGetID(IWineDispatchProxyPrivate *iface, WCHAR *name, DISPID *id)
+{
+    HTMLWindow *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->inner_window->event_target.dispex.IDispatchEx_iface;
+    HRESULT hres;
+
+    hres = search_window_props(This->inner_window, name, fdexNameCaseSensitive, id);
+    if(hres != DISP_E_UNKNOWNNAME)
+        return hres;
+
+    hres = itf->lpVtbl->PropGetID(itf, name, id);
+    if(hres != DISP_E_UNKNOWNNAME)
+        return hres;
+
+    return lookup_custom_prop(This, name, id);
+}
+
+static HRESULT WINAPI WindowWineDispProxyPrivate_PropInvoke(IWineDispatchProxyPrivate *iface, IDispatch *this_obj, DISPID id,
+        LCID lcid, DWORD flags, DISPPARAMS *dp, VARIANT *ret, EXCEPINFO *ei, IServiceProvider *caller)
+{
+    HTMLWindow *This = impl_from_IWineDispatchProxyPrivate(iface);
+
+    return dispex_invoke(&This->inner_window->event_target.dispex, this_obj, id, lcid, flags, dp, ret, ei, caller);
+}
+
+static HRESULT WINAPI WindowWineDispProxyPrivate_PropDelete(IWineDispatchProxyPrivate *iface, DISPID id)
+{
+    HTMLWindow *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->inner_window->event_target.dispex.IDispatchEx_iface;
+
+    return itf->lpVtbl->PropDelete(itf, id);
+}
+
+static HRESULT WINAPI WindowWineDispProxyPrivate_FuncInfo(IWineDispatchProxyPrivate *iface, DISPID id, struct proxy_func_invoker *ret)
+{
+    HTMLWindow *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->inner_window->event_target.dispex.IDispatchEx_iface;
+
+    return itf->lpVtbl->FuncInfo(itf, id, ret);
+}
+
+static HRESULT WINAPI WindowWineDispProxyPrivate_AccessorInfo(IWineDispatchProxyPrivate *iface, DISPID id, struct proxy_func_invoker *ret)
+{
+    HTMLWindow *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->inner_window->event_target.dispex.IDispatchEx_iface;
+
+    return itf->lpVtbl->AccessorInfo(itf, id, ret);
+}
+
+static HRESULT WINAPI WindowWineDispProxyPrivate_ToString(IWineDispatchProxyPrivate *iface, BSTR *string)
+{
+    HTMLWindow *This = impl_from_IWineDispatchProxyPrivate(iface);
+    IWineDispatchProxyPrivate *itf = (IWineDispatchProxyPrivate*)&This->inner_window->event_target.dispex.IDispatchEx_iface;
+
+    return itf->lpVtbl->ToString(itf, string);
+}
+
+static BOOL WINAPI WindowWineDispProxyPrivate_CanGC(IWineDispatchProxyPrivate *iface)
+{
+    HTMLWindow *This = impl_from_IWineDispatchProxyPrivate(iface);
+
+    /* Allow garbage collection only if the proxy is the only one holding a ref to us */
+    return This->ref == 1;
+}
+
+static const IWineDispatchProxyPrivateVtbl WindowDispExVtbl = {
+    {
     WindowDispEx_QueryInterface,
     WindowDispEx_AddRef,
     WindowDispEx_Release,
@@ -3589,6 +4080,23 @@ static const IDispatchExVtbl WindowDispExVtbl = {
     WindowDispEx_GetMemberName,
     WindowDispEx_GetNextDispID,
     WindowDispEx_GetNameSpaceParent
+    },
+
+    /* IWineDispatchProxyPrivate extension */
+    WindowWineDispProxyPrivate_GetProxyFieldRef,
+    WindowWineDispProxyPrivate_GetDefaultPrototype,
+    WindowWineDispProxyPrivate_GetDefaultConstructor,
+    WindowWineDispProxyPrivate_DefineConstructors,
+    WindowWineDispProxyPrivate_IsPrototype,
+    WindowWineDispProxyPrivate_IsConstructor,
+    WindowWineDispProxyPrivate_PropFlags,
+    WindowWineDispProxyPrivate_PropGetID,
+    WindowWineDispProxyPrivate_PropInvoke,
+    WindowWineDispProxyPrivate_PropDelete,
+    WindowWineDispProxyPrivate_FuncInfo,
+    WindowWineDispProxyPrivate_AccessorInfo,
+    WindowWineDispProxyPrivate_ToString,
+    WindowWineDispProxyPrivate_CanGC
 };
 
 static inline HTMLWindow *impl_from_IServiceProvider(IServiceProvider *iface)
@@ -3644,8 +4152,8 @@ static inline HTMLInnerWindow *impl_from_DispatchEx(DispatchEx *iface)
     return CONTAINING_RECORD(iface, HTMLInnerWindow, event_target.dispex);
 }
 
-static HRESULT HTMLWindow_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
-        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+static HRESULT HTMLWindow_invoke(DispatchEx *dispex, IDispatch *this_obj, DISPID id, LCID lcid, WORD flags,
+        DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
     HTMLInnerWindow *This = impl_from_DispatchEx(dispex);
     global_prop_t *prop;
@@ -3653,8 +4161,43 @@ static HRESULT HTMLWindow_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD
     HRESULT hres;
 
     idx = id - MSHTML_DISPID_CUSTOM_MIN;
-    if(idx >= This->global_prop_cnt)
-        return DISP_E_MEMBERNOTFOUND;
+    if(idx >= This->global_prop_cnt) {
+        idx = id - (MSHTML_DISPID_CUSTOM_MAX - compat_ctor_props_num + 1);
+        if(idx >= compat_ctor_props_num || (idx >= ARRAY_SIZE(special_ctor_static_data) &&
+           dispex_compat_mode(&This->event_target.dispex) != COMPAT_MODE_IE8))
+            return DISP_E_MEMBERNOTFOUND;
+
+        switch(flags) {
+        case DISPATCH_METHOD|DISPATCH_PROPERTYGET:
+            if(!res)
+                return E_INVALIDARG;
+            /* fall through */
+        case DISPATCH_METHOD:
+        case DISPATCH_CONSTRUCT:
+            return MSHTML_E_INVALID_ACTION;
+        case DISPATCH_PROPERTYGET:
+            if(idx < ARRAY_SIZE(special_ctor_static_data))
+                hres = get_compat_ctor(This, special_ctor_static_data[idx].ctor_id, special_ctor_static_data[idx].prototype_id,
+                                       special_ctor_static_data[idx].dispex, special_ctor_static_data[idx].vtbl, &V_DISPATCH(res));
+            else {
+                /* For these generic constructors, COMPAT_CTOR_ID is the same as the PROTO_ID */
+                idx -= ARRAY_SIZE(special_ctor_static_data);
+                hres = get_compat_ctor(This, compat_ctor_static_data[idx].prototype_id, compat_ctor_static_data[idx].prototype_id,
+                                       &compat_ctor_static_data[idx].dispex, &compat_ctor_vtbl, &V_DISPATCH(res));
+            }
+            if(FAILED(hres))
+                return hres;
+            V_VT(res) = VT_DISPATCH;
+            break;
+        case DISPATCH_PROPERTYPUTREF|DISPATCH_PROPERTYPUT:
+        case DISPATCH_PROPERTYPUTREF:
+        case DISPATCH_PROPERTYPUT:
+            break;
+        default:
+            return E_INVALIDARG;
+        }
+        return S_OK;
+    }
 
     prop = This->global_props+idx;
 
@@ -3709,7 +4252,7 @@ static HRESULT HTMLWindow_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD
 
             prop->type = GLOBAL_DISPEXVAR;
             prop->id = dispex_id;
-            return IDispatchEx_InvokeEx(&This->event_target.dispex.IDispatchEx_iface, dispex_id, 0, flags, params, res, ei, caller);
+            return dispex_invoke(&This->event_target.dispex, this_obj, dispex_id, 0, flags, params, res, ei, caller);
         }
         default:
             FIXME("Not supported flags: %x\n", flags);
@@ -3740,7 +4283,7 @@ static HRESULT HTMLWindow_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD
             return E_NOTIMPL;
         }
     case GLOBAL_DISPEXVAR:
-        return IDispatchEx_InvokeEx(&This->event_target.dispex.IDispatchEx_iface, prop->id, 0, flags, params, res, ei, caller);
+        return dispex_invoke(&This->event_target.dispex, this_obj, prop->id, 0, flags, params, res, ei, caller);
     default:
         ERR("invalid type %d\n", prop->type);
         hres = DISP_E_MEMBERNOTFOUND;
@@ -3767,16 +4310,173 @@ static void HTMLWindow_bind_event(DispatchEx *dispex, eventid_t eid)
     ensure_doc_nsevent_handler(This->doc, NULL, eid);
 }
 
+static HRESULT IHTMLWindow2_location_hook(DispatchEx *dispex, WORD flags, DISPPARAMS *dp, VARIANT *res,
+        EXCEPINFO *ei, IServiceProvider *caller)
+{
+    HTMLInnerWindow *This = impl_from_DispatchEx(dispex);
+    HTMLLocation *location;
+    HRESULT hres;
+
+    if(!(flags & DISPATCH_PROPERTYPUT))
+        return S_FALSE;
+
+    TRACE("forwarding to location.href\n");
+
+    hres = get_location(This, &location);
+    if(FAILED(hres))
+        return hres;
+
+    hres = dispex_invoke(&location->dispex, (IDispatch*)&This->base.IHTMLWindow2_iface,
+                         DISPID_VALUE, 0, flags, dp, res, ei, caller);
+    IHTMLLocation_Release(&location->IHTMLLocation_iface);
+    return hres;
+}
+
+static HRESULT IHTMLWindow3_setTimeout_hook(DispatchEx *dispex, WORD flags, DISPPARAMS *dp, VARIANT *res,
+        EXCEPINFO *ei, IServiceProvider *caller)
+{
+    VARIANT args[2];
+    DISPPARAMS new_dp = { args, NULL, 2, 0 };
+
+    /*
+     * setTimeout calls should use default value 0 for the second argument if only one is provided,
+     * but IDL file does not reflect that. We fixup arguments here instead.
+     */
+    if(!(flags & DISPATCH_METHOD) || dp->cArgs != 1 || dp->cNamedArgs)
+        return S_FALSE;
+
+    TRACE("Fixing args\n");
+
+    V_VT(args) = VT_I4;
+    V_I4(args) = 0;
+    args[1] = dp->rgvarg[0];
+    return dispex_call_builtin(dispex, DISPID_IHTMLWINDOW3_SETTIMEOUT, &new_dp, res, ei, caller);
+}
+
+static HRESULT IHTMLWindow6_postMessage_hook(DispatchEx *dispex, WORD flags, DISPPARAMS *dp, VARIANT *res,
+        EXCEPINFO *ei, IServiceProvider *caller)
+{
+    HTMLInnerWindow *This = impl_from_DispatchEx(dispex);
+    VARIANT msg, targetOrigin_var, *targetOrigin, *transfer;
+    struct post_message_task *task;
+    DOMEvent *event;
+    HRESULT hres;
+
+    if(!(flags & DISPATCH_METHOD) || dp->cArgs < 2 || dp->cNamedArgs)
+        return S_FALSE;
+    msg = dp->rgvarg[dp->cArgs - 1];
+    targetOrigin = &dp->rgvarg[dp->cArgs - 2];
+    transfer = (dp->cArgs > 2) ? &dp->rgvarg[dp->cArgs - 3] : NULL;
+
+    TRACE("(%p)->(%s %s %s)\n", This, debugstr_variant(&msg), debugstr_variant(targetOrigin), debugstr_variant(transfer));
+
+    if(transfer)
+        FIXME("transfer not implemented, ignoring\n");
+
+    V_VT(&targetOrigin_var) = VT_EMPTY;
+    if(V_VT(targetOrigin) != VT_BSTR) {
+        hres = change_type(&targetOrigin_var, targetOrigin, VT_BSTR, caller);
+        if(FAILED(hres))
+            return hres;
+        targetOrigin = &targetOrigin_var;
+    }
+
+    hres = check_target_origin(This, targetOrigin);
+    VariantClear(&targetOrigin_var);
+    if(hres != S_OK)
+        return SUCCEEDED(hres) ? S_OK : hres;
+
+    switch(V_VT(&msg)) {
+        case VT_EMPTY:
+        case VT_NULL:
+        case VT_VOID:
+        case VT_I1:
+        case VT_I2:
+        case VT_I4:
+        case VT_I8:
+        case VT_UI1:
+        case VT_UI2:
+        case VT_UI4:
+        case VT_UI8:
+        case VT_INT:
+        case VT_UINT:
+        case VT_R4:
+        case VT_R8:
+        case VT_BOOL:
+        case VT_BSTR:
+        case VT_CY:
+        case VT_DATE:
+        case VT_DECIMAL:
+        case VT_HRESULT:
+            break;
+        case VT_ERROR:
+            V_VT(&msg) = VT_EMPTY;
+            break;
+        default:
+            FIXME("Unsupported vt %d\n", V_VT(&msg));
+            return E_NOTIMPL;
+    }
+
+    if(!This->doc) {
+        FIXME("No document\n");
+        return E_FAIL;
+    }
+
+    hres = create_message_event(This->doc, &msg, &event);
+    if(FAILED(hres))
+        return hres;
+
+    if(!(task = heap_alloc(sizeof(*task)))) {
+        IDOMEvent_Release(&event->IDOMEvent_iface);
+        return E_OUTOFMEMORY;
+    }
+
+    task->event = event;
+    task->window = This;
+    IHTMLWindow2_AddRef(&task->window->base.IHTMLWindow2_iface);
+    return push_task(&task->header, post_message_proc, post_message_destr, This->task_magic);
+}
+
 static void HTMLWindow_init_dispex_info(dispex_data_t *info, compat_mode_t compat_mode)
 {
-    if(compat_mode >= COMPAT_MODE_IE9)
+    static const dispex_hook_t window2_hooks[] = {
+        {DISPID_IHTMLWINDOW2_LOCATION, IHTMLWindow2_location_hook},
+        /* DispHTMLWindow2 uses these from IHTMLWindow3 */
+        {DISPID_IHTMLWINDOW2_SETTIMEOUT},
+        {DISPID_IHTMLWINDOW2_SETINTERVAL},
+        {DISPID_UNKNOWN}
+    };
+    static const dispex_hook_t window3_hooks[] = {
+        {DISPID_IHTMLWINDOW3_SETTIMEOUT, IHTMLWindow3_setTimeout_hook},
+        {DISPID_UNKNOWN}
+    };
+    static const dispex_hook_t window6_ie10_hooks[] = {
+        {DISPID_IHTMLWINDOW6_POSTMESSAGE, IHTMLWindow6_postMessage_hook},
+        {DISPID_UNKNOWN}
+    };
+    static const dispex_hook_t private_ie9_hooks[] = {
+        {DISPID_IWINEHTMLWINDOWPRIVATE_REQUESTANIMATIONFRAME},
+        {DISPID_IWINEHTMLWINDOWPRIVATE_CANCELANIMATIONFRAME},
+        {DISPID_IWINEHTMLWINDOWPRIVATE_CONSOLE},
+
+        /* IE10 only */
+        {DISPID_IWINEHTMLWINDOWPRIVATE_MSCRYPTO},
+        {DISPID_UNKNOWN}
+    };
+    const dispex_hook_t *const private_ie10_hooks = private_ie9_hooks + 3;
+
+    if(compat_mode >= COMPAT_MODE_IE9) {
         dispex_info_add_interface(info, IHTMLWindow7_tid, NULL);
-    else
+        dispex_info_add_interface(info, IWineHTMLWindowPrivate_tid,
+                                  compat_mode == COMPAT_MODE_IE9  ? private_ie9_hooks  :
+                                  compat_mode == COMPAT_MODE_IE10 ? private_ie10_hooks : NULL);
+    }else
         dispex_info_add_interface(info, IWineHTMLWindowCompatPrivate_tid, NULL);
-    if(compat_mode >= COMPAT_MODE_IE10)
-        dispex_info_add_interface(info, IWineHTMLWindowPrivate_tid, NULL);
 
     dispex_info_add_interface(info, IHTMLWindow5_tid, NULL);
+    dispex_info_add_interface(info, IHTMLWindow2_tid, window2_hooks);
+    dispex_info_add_interface(info, IHTMLWindow3_tid, window3_hooks);
+    dispex_info_add_interface(info, IHTMLWindow6_tid, compat_mode >= COMPAT_MODE_IE10 ? window6_ie10_hooks : NULL);
     EventTarget_init_dispex_info(info, compat_mode);
 }
 
@@ -3791,6 +4491,8 @@ static const event_target_vtbl_t HTMLWindow_event_target_vtbl = {
         NULL,
         NULL,
         HTMLWindow_invoke,
+        NULL,
+        NULL,
         HTMLWindow_get_compat_mode,
         NULL
     },
@@ -3803,16 +4505,14 @@ static const event_target_vtbl_t HTMLWindow_event_target_vtbl = {
 };
 
 static const tid_t HTMLWindow_iface_tids[] = {
-    IHTMLWindow2_tid,
-    IHTMLWindow3_tid,
     IHTMLWindow4_tid,
-    IHTMLWindow6_tid,
     0
 };
 
-static dispex_static_data_t HTMLWindow_dispex = {
+dispex_static_data_t HTMLWindow_dispex = {
     L"Window",
     &HTMLWindow_event_target_vtbl.dispex_vtbl,
+    PROTO_ID_HTMLWindow,
     DispHTMLWindow2_tid,
     HTMLWindow_iface_tids,
     HTMLWindow_init_dispex_info
@@ -3833,7 +4533,7 @@ static void *alloc_window(size_t size)
     window->IHTMLWindow6_iface.lpVtbl = &HTMLWindow6Vtbl;
     window->IHTMLWindow7_iface.lpVtbl = &HTMLWindow7Vtbl;
     window->IHTMLPrivateWindow_iface.lpVtbl = &HTMLPrivateWindowVtbl;
-    window->IDispatchEx_iface.lpVtbl = &WindowDispExVtbl;
+    window->IDispatchEx_iface.lpVtbl = (const IDispatchExVtbl*)&WindowDispExVtbl;
     window->IServiceProvider_iface.lpVtbl = &ServiceProviderVtbl;
     window->ITravelLogClient_iface.lpVtbl = &TravelLogClientVtbl;
     window->IObjectIdentity_iface.lpVtbl = &ObjectIdentityVtbl;
@@ -3862,7 +4562,7 @@ static HRESULT create_inner_window(HTMLOuterWindow *outer_window, IMoniker *mon,
     window->base.inner_window = window;
 
     EventTarget_Init(&window->event_target, (IUnknown*)&window->base.IHTMLWindow2_iface,
-                     &HTMLWindow_dispex, COMPAT_MODE_NONE);
+                     &HTMLWindow_dispex, NULL);
 
     window->task_magic = get_task_target_magic();
 
@@ -3950,7 +4650,7 @@ HRESULT update_window_doc(HTMLInnerWindow *window)
 {
     HTMLOuterWindow *outer_window = window->base.outer_window;
     compat_mode_t parent_mode = COMPAT_MODE_QUIRKS;
-    nsIDOMHTMLDocument *nshtmldoc;
+    IWineDispatchProxyCbPrivate *proxy;
     nsIDOMDocument *nsdoc;
     nsresult nsres;
     HRESULT hres;
@@ -3966,18 +4666,11 @@ HRESULT update_window_doc(HTMLInnerWindow *window)
         return E_FAIL;
     }
 
-    nsres = nsIDOMDocument_QueryInterface(nsdoc, &IID_nsIDOMHTMLDocument, (void**)&nshtmldoc);
-    nsIDOMDocument_Release(nsdoc);
-    if(NS_FAILED(nsres)) {
-        ERR("Could not get nsIDOMHTMLDocument iface: %08lx\n", nsres);
-        return E_FAIL;
-    }
-
     if(outer_window->parent)
         parent_mode = outer_window->parent->base.inner_window->doc->document_mode;
 
-    hres = create_document_node(nshtmldoc, outer_window->browser, window, parent_mode, &window->doc);
-    nsIDOMHTMLDocument_Release(nshtmldoc);
+    hres = create_document_node(nsdoc, outer_window->browser, window, DOCTYPE_HTML, parent_mode, &window->doc);
+    nsIDOMDocument_Release(nsdoc);
     if(FAILED(hres))
         return hres;
 
@@ -3991,6 +4684,18 @@ HRESULT update_window_doc(HTMLInnerWindow *window)
     outer_window->base.inner_window = window;
     outer_window->pending_window = NULL;
 
+    assert(!window->event_target.dispex.proxy);
+    proxy = window->event_target.dispex.proxy = outer_window->saved_proxy;
+    outer_window->saved_proxy = NULL;
+    if(proxy) {
+        proxy->lpVtbl->Relinked(proxy, (IWineDispatchProxyPrivate*)&window->event_target.dispex.IDispatchEx_iface);
+        if(window->doc->document_mode_locked) {
+            hres = proxy->lpVtbl->HostUpdated(proxy, NULL);
+            if(FAILED(hres))
+                WARN("Proxy->HostUpdated failed: %08lx\n", hres);
+        }
+    }
+
     if(is_main_content_window(outer_window) || !outer_window->browser->content_window) {
         HTMLDocumentObj *doc_obj = outer_window->browser->doc;
         if(doc_obj->basedoc.doc_node)
diff --git a/dlls/mshtml/main.c b/dlls/mshtml/main.c
index bbaed1f1967..05b68ac61bc 100644
--- a/dlls/mshtml/main.c
+++ b/dlls/mshtml/main.c
@@ -48,6 +48,8 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(mshtml);
 
+#define CHARS_IN_GUID 39
+
 HINSTANCE hInst;
 DWORD mshtml_tls = TLS_OUT_OF_INDEXES;
 
@@ -126,6 +128,70 @@ BSTR charset_string_from_cp(UINT cp)
     return SysAllocString(info.wszWebCharset);
 }
 
+HRESULT get_mime_type_display_name(const WCHAR *content_type, BSTR *ret)
+{
+    WCHAR buffer[128], *str;
+    WCHAR *const clsid_str = buffer + sizeof("CLSID\\")-1;
+    DWORD type, size, len;
+    HKEY key, type_key;
+    LSTATUS status;
+
+    status = RegOpenKeyExW(HKEY_CLASSES_ROOT, L"MIME\\Database\\Content Type", 0, 0, &key);
+    if(status != ERROR_SUCCESS)
+        goto fail;
+
+    RegOpenKeyExW(key, content_type, 0, KEY_QUERY_VALUE, &type_key);
+    RegCloseKey(key);
+    if(status != ERROR_SUCCESS)
+        goto fail;
+
+    size = CHARS_IN_GUID * sizeof(WCHAR);
+    status = RegQueryValueExW(type_key, L"CLSID", NULL, &type, (BYTE*)clsid_str, &size);
+    RegCloseKey(type_key);
+    if(status != ERROR_SUCCESS || type != REG_SZ || size != CHARS_IN_GUID * sizeof(WCHAR) ||
+       clsid_str[0] != '{' || clsid_str[CHARS_IN_GUID-2] != '}' || clsid_str[CHARS_IN_GUID-1])
+        goto fail;
+
+    memcpy(buffer, L"CLSID\\", sizeof(L"CLSID\\")-sizeof(WCHAR));
+    status = RegOpenKeyExW(HKEY_CLASSES_ROOT, buffer, 0, KEY_QUERY_VALUE, &key);
+    if(status != ERROR_SUCCESS)
+        goto fail;
+
+    size = sizeof(buffer);
+    str = buffer;
+    for(;;) {
+        status = RegQueryValueExW(key, NULL, NULL, &type, (BYTE*)str, &size);
+        if(status == ERROR_SUCCESS && type == REG_SZ && size >= sizeof(WCHAR))
+            break;
+        if(str != buffer)
+            heap_free(str);
+        if(status != ERROR_MORE_DATA) {
+            RegCloseKey(key);
+            goto fail;
+        }
+        if(!(str = heap_alloc(size))) {
+            RegCloseKey(key);
+            return E_OUTOFMEMORY;
+        }
+    }
+    RegCloseKey(key);
+
+    len  = size / sizeof(WCHAR);
+    len -= !str[len - 1];
+    *ret = SysAllocStringLen(str, len);
+    if(str != buffer)
+        heap_free(str);
+
+    return *ret ? S_OK : E_OUTOFMEMORY;
+
+fail:
+    WARN("Did not find MIME in database for %s\n", debugstr_w(content_type));
+
+    /* native seems to return "File" when it doesn't know the content type */
+    *ret = SysAllocString(L"File");
+    return *ret ? S_OK : E_OUTOFMEMORY;
+}
+
 IInternetSecurityManager *get_security_manager(void)
 {
     if(!security_manager) {
diff --git a/dlls/mshtml/mshtml.inf b/dlls/mshtml/mshtml.inf
index 4a650b444fc..fc010bcc593 100644
--- a/dlls/mshtml/mshtml.inf
+++ b/dlls/mshtml/mshtml.inf
@@ -49,6 +49,16 @@ HKCR,"CLSID\%CLSID_Scriptlet%\Programmable",,16
 HKCR,"CLSID\%CLSID_Scriptlet%\ToolboxBitmap32",,,"%16422%\Internet Explorer\iexplore.exe,1"
 HKCR,"MIME\Database\Content Type\text/x-scriptlet","CLSID",,"%CLSID_Scriptlet%"
 
+;; SVGDocument
+HKCR,"CLSID\{30590066-98B5-11CF-BB82-00AA00BDCE0B}\BrowseInPlace",,16
+HKCR,"CLSID\{30590066-98B5-11CF-BB82-00AA00BDCE0B}\DefaultIcon",,0x00020000,"%16422%\Internet Explorer\iexplore.exe,1"
+HKCR,"CLSID\{30590066-98B5-11CF-BB82-00AA00BDCE0B}\MiscStatus",,,"2228625"
+
+;; XHTMLDocument
+HKCR,"CLSID\{30590067-98B5-11CF-BB82-00AA00BDCE0B}\BrowseInPlace",,16
+HKCR,"CLSID\{30590067-98B5-11CF-BB82-00AA00BDCE0B}\DefaultIcon",,0x00020000,"%16422%\Internet Explorer\iexplore.exe,1"
+HKCR,"CLSID\{30590067-98B5-11CF-BB82-00AA00BDCE0B}\MiscStatus",,,"2228625"
+
 
 [Protocols.Reg]
 HKCR,"PROTOCOLS\Handler\javascript","CLSID",,"%CLSID_JSProtocol%"
@@ -241,6 +251,12 @@ HKCR,".ai","Content Type",,"application/postscript"
 HKCR,".eps","Content Type",,"application/postscript"
 HKCR,".ps","Content Type",,"application/postscript"
 
+;; SVG
+HKCR,"MIME\Database\Content Type\image/svg+xml","CLSID",,"{30590066-98B5-11CF-BB82-00AA00BDCE0B}"
+HKCR,"MIME\Database\Content Type\image/svg+xml","Extension",,".svg"
+HKCR,".svg",,,"svgfile"
+HKCR,".svg","Content Type",,"image/svg+xml"
+
 ;; TAR
 HKCR,"MIME\Database\Content Type\application/x-tar","Extension",,".tar"
 HKCR,".tar","Content Type",,"application/x-tar"
@@ -278,6 +294,14 @@ HKCR,"xbmfile\shell\open\ddeexec\Application",,,"IExplore"
 HKCR,"xbmfile\shell\open\ddeexec\Topic",,,"WWW_OpenURL"
 ;; HKCR,"xbmfile\DefaultIcon",,,"%16422%\Internet Explorer\iexplore.exe,9"
 
+;; XHTML
+HKCR,"MIME\Database\Content Type\application/xhtml+xml","CLSID",,"{30590067-98B5-11CF-BB82-00AA00BDCE0B}"
+HKCR,"MIME\Database\Content Type\application/xhtml+xml","Extension",,".xht"
+HKCR,".xht",,,"xhtmlfile"
+HKCR,".xht","Content Type",,"application/xhtml+xml"
+HKCR,".xhtml",,,"xhtmlfile"
+HKCR,".xhtml","Content Type",,"application/xhtml+xml"
+
 ;; XML
 HKCR,"MIME\Database\Content Type\application/xml","CLSID",,"{48123BC4-99D9-11D1-A6B3-00C04FD91555}"
 HKCR,"MIME\Database\Content Type\application/xml","Extension",,".xml"
diff --git a/dlls/mshtml/mshtml_classes.idl b/dlls/mshtml/mshtml_classes.idl
index b84a50f1cf1..13fe655b0c0 100644
--- a/dlls/mshtml/mshtml_classes.idl
+++ b/dlls/mshtml/mshtml_classes.idl
@@ -295,6 +295,15 @@ coclass ResProtocol { }
 ]
 coclass Scriptlet { }
 
+[
+    helpstring("SVG Document"),
+    progid("svgfile"),
+    threading(apartment),
+    version(1.0),
+    uuid(30590066-98b5-11cf-bb82-00aa00bdce0b)
+]
+coclass SVGDocumentClass { }
+
 [
     helpstring("Microsoft HTML Resource Pluggable Protocol"),
     threading(apartment),
@@ -308,3 +317,12 @@ coclass SysimageProtocol { }
     uuid(429af92c-a51f-11d2-861e-00c04fa35c89)
 ]
 coclass TridentAPI { }
+
+[
+    helpstring("XHTML Document"),
+    progid("xhtmlfile"),
+    threading(apartment),
+    version(1.0),
+    uuid(30590067-98b5-11cf-bb82-00aa00bdce0b)
+]
+coclass XHTMLDocumentClass { }
diff --git a/dlls/mshtml/mshtml_private.h b/dlls/mshtml/mshtml_private.h
index a94f1be1969..2a1c674ff1b 100644
--- a/dlls/mshtml/mshtml_private.h
+++ b/dlls/mshtml/mshtml_private.h
@@ -25,6 +25,7 @@
 #include "hlink.h"
 #include "perhist.h"
 #include "dispex.h"
+#include "activscp.h"
 #include "objsafe.h"
 #include "htiframe.h"
 #include "tlogstg.h"
@@ -44,6 +45,80 @@
 
 #include <assert.h>
 
+/* NOTE: Keep in sync with jscript.h in jscript.dll */
+DEFINE_GUID(IID_IWineDispatchProxyPrivate, 0xd359f2fe,0x5531,0x741b,0xa4,0x1a,0x5c,0xf9,0x2e,0xdc,0x97,0x1b);
+typedef struct _IWineDispatchProxyPrivate IWineDispatchProxyPrivate;
+typedef struct _IWineDispatchProxyCbPrivate IWineDispatchProxyCbPrivate;
+
+struct proxy_prototypes
+{
+    unsigned int num;
+    struct {
+        IDispatch *prototype;
+        IDispatch *ctor;
+    } disp[];
+};
+
+struct proxy_func_invoker
+{
+    HRESULT (STDMETHODCALLTYPE *invoke)(IDispatch*,void*,DISPPARAMS*,VARIANT*,EXCEPINFO*,IServiceProvider*);
+    void *context;
+    const WCHAR *name;
+};
+
+typedef struct {
+    IDispatchExVtbl dispex;
+    IWineDispatchProxyCbPrivate** (STDMETHODCALLTYPE *GetProxyFieldRef)(IWineDispatchProxyPrivate *This);
+    IDispatch* (STDMETHODCALLTYPE *GetDefaultPrototype)(IWineDispatchProxyPrivate *This, struct proxy_prototypes **prots_ref);
+    IDispatch* (STDMETHODCALLTYPE *GetDefaultConstructor)(IWineDispatchProxyPrivate *This, struct proxy_prototypes *prots);
+    HRESULT (STDMETHODCALLTYPE *DefineConstructors)(IWineDispatchProxyPrivate *This, struct proxy_prototypes **prots_ref);
+    BOOL (STDMETHODCALLTYPE *IsPrototype)(IWineDispatchProxyPrivate *This);
+    BOOL (STDMETHODCALLTYPE *IsConstructor)(IWineDispatchProxyPrivate *This);
+    DWORD (STDMETHODCALLTYPE *PropFlags)(IWineDispatchProxyPrivate *This, DISPID id);
+    HRESULT (STDMETHODCALLTYPE *PropGetID)(IWineDispatchProxyPrivate *This, WCHAR *name, DISPID *id);
+    HRESULT (STDMETHODCALLTYPE *PropInvoke)(IWineDispatchProxyPrivate *This, IDispatch *this_obj, DISPID id, LCID lcid,
+                                            DWORD flags, DISPPARAMS *dp, VARIANT *ret, EXCEPINFO *ei, IServiceProvider *caller);
+    HRESULT (STDMETHODCALLTYPE *PropDelete)(IWineDispatchProxyPrivate *This, DISPID id);
+    HRESULT (STDMETHODCALLTYPE *FuncInfo)(IWineDispatchProxyPrivate *This, DISPID id, struct proxy_func_invoker *ret);
+    HRESULT (STDMETHODCALLTYPE *AccessorInfo)(IWineDispatchProxyPrivate *This, DISPID id, struct proxy_func_invoker *ret);
+    HRESULT (STDMETHODCALLTYPE *ToString)(IWineDispatchProxyPrivate *This, BSTR *string);
+    BOOL (STDMETHODCALLTYPE *CanGC)(IWineDispatchProxyPrivate *This);
+} IWineDispatchProxyPrivateVtbl;
+
+typedef struct {
+    IDispatchExVtbl dispex;
+    void (STDMETHODCALLTYPE *Unlinked)(IWineDispatchProxyCbPrivate *This);
+    void (STDMETHODCALLTYPE *Relinked)(IWineDispatchProxyCbPrivate *This, IWineDispatchProxyPrivate *proxy);
+    HRESULT (STDMETHODCALLTYPE *HostUpdated)(IWineDispatchProxyCbPrivate *This, IActiveScript *script);
+    DISPID (STDMETHODCALLTYPE *GetUnderlyingDispID)(IWineDispatchProxyCbPrivate *This, DISPID id);
+    IDispatch* (STDMETHODCALLTYPE *CreateConstructor)(IWineDispatchProxyCbPrivate *This, DISPID id, const WCHAR *name);
+    HRESULT (STDMETHODCALLTYPE *DefineConstructor)(IWineDispatchProxyCbPrivate *This, const WCHAR *name, IDispatch *prot, DISPID);
+    HRESULT (STDMETHODCALLTYPE *GetRandomValues)(IDispatch *typedarr);
+    void (STDMETHODCALLTYPE *Traverse)(IWineDispatchProxyCbPrivate *This,
+                                       void (STDMETHODCALLTYPE *note_cc_edge)(IDispatch*,void*), void *cb);
+} IWineDispatchProxyCbPrivateVtbl;
+
+struct _IWineDispatchProxyPrivate {
+    const IWineDispatchProxyPrivateVtbl *lpVtbl;
+};
+
+struct _IWineDispatchProxyCbPrivate {
+    const IWineDispatchProxyCbPrivateVtbl *lpVtbl;
+};
+
+#define PROPF_ARGMASK       0x00ff
+#define PROPF_METHOD        0x0100
+#define PROPF_CONSTR        0x0200
+
+#define PROPF_ENUMERABLE    0x0400
+#define PROPF_WRITABLE      0x0800
+#define PROPF_CONFIGURABLE  0x1000
+#define PROPF_ALL           (PROPF_ENUMERABLE | PROPF_WRITABLE | PROPF_CONFIGURABLE)
+
+#define PROPF_PROXY_ACCESSOR 0x8000
+
+
+
 #define NS_ERROR_GENERATE_FAILURE(module,code) \
     ((nsresult) (((UINT32)(1u<<31)) | ((UINT32)(module+0x45)<<16) | ((UINT32)(code))))
 #define NS_ERROR_GENERATE_SUCCESS(module,code) \
@@ -72,7 +147,10 @@
 
 #define NSAPI WINAPI
 
-#define MSHTML_E_NODOC    0x800a025c
+#define MSHTML_E_INVALID_PROPERTY 0x800a01b6
+#define MSHTML_E_INVALID_ACTION   0x800a01bd
+#define MSHTML_E_NODOC            0x800a025c
+#define MSHTML_E_SYNTAX           0x800a03ea
 
 typedef struct HTMLDOMNode HTMLDOMNode;
 typedef struct ConnectionPoint ConnectionPoint;
@@ -90,6 +168,7 @@ typedef struct EventTarget EventTarget;
     XDIID(DispDOMMessageEvent) \
     XDIID(DispDOMMouseEvent) \
     XDIID(DispDOMUIEvent) \
+    XDIID(DispDOMParser) \
     XDIID(DispHTMLAnchorElement) \
     XDIID(DispHTMLAreaElement) \
     XDIID(DispHTMLAttributeCollection) \
@@ -151,6 +230,7 @@ typedef struct EventTarget EventTarget;
     XIID(IDOMMessageEvent) \
     XIID(IDOMMouseEvent) \
     XIID(IDOMUIEvent) \
+    XIID(IDOMParser) \
     XIID(IDocumentEvent) \
     XIID(IDocumentRange) \
     XIID(IDocumentSelector) \
@@ -246,6 +326,7 @@ typedef struct EventTarget EventTarget;
     XIID(IHTMLStyleSheet) \
     XIID(IHTMLStyleSheet4) \
     XIID(IHTMLStyleSheetRule) \
+    XIID(IHTMLCSSRule) \
     XIID(IHTMLStyleSheetRulesCollection) \
     XIID(IHTMLStyleSheetsCollection) \
     XIID(IHTMLTable) \
@@ -277,9 +358,14 @@ typedef struct EventTarget EventTarget;
 #define PRIVATE_TID_LIST \
     XIID(IWineDOMTokenList) \
     XIID(IWineHTMLElementPrivate) \
+    XIID(IWineHTMLInputPrivate) \
+    XIID(IWineHTMLFormPrivate) \
+    XIID(IWineHTMLParentFormPrivate) \
     XIID(IWineHTMLWindowPrivate) \
     XIID(IWineHTMLWindowCompatPrivate) \
-    XIID(IWineMSHTMLConsole)
+    XIID(IWineMSHTMLConsole) \
+    XIID(IWineMSHTMLCrypto) \
+    XIID(IWineMSHTMLSubtleCrypto)
 
 typedef enum {
 #define XIID(iface) iface ## _tid,
@@ -292,6 +378,127 @@ PRIVATE_TID_LIST
     LAST_tid
 } tid_t;
 
+extern const tid_t no_iface_tids[1];
+
+#define COMPAT_ONLY_PROTOTYPE_LIST \
+    X(HTMLLocation,                   "Location",                     HTMLLocation_compat_dispex,             NULL) \
+    X(HTMLUnknownElement,             "HTMLUnknownElement",           HTMLUnknownElement_dispex,              NULL)
+
+#define COMPAT_PROTOTYPE_LIST \
+    X(DOMParser,                      "DOMParser",                    DOMParser_dispex,                       Object) \
+    X(History,                        "History",                      OmHistory_dispex,                       Object) \
+    X(Navigator,                      "Navigator",                    OmNavigator_dispex,                     Object) \
+    X(HTMLDOMAttribute,               "Attr",                         HTMLDOMAttribute_dispex,                HTMLDOMNode) \
+    X(HTMLDOMChildrenCollection,      "NodeList",                     HTMLDOMChildrenCollection_dispex,       Object) \
+    X(HTMLDOMImplementation,          "DOMImplementation",            HTMLDOMImplementation_dispex,           Object) \
+    X(HTMLDOMTextNode,                "Text",                         HTMLDOMTextNode_dispex,                 DOMCharacterData) \
+    X(HTMLDocument,                   "HTMLDocument",                 HTMLDocumentNode_dispex,                Document) \
+    X(HTMLWindow,                     "Window",                       HTMLWindow_dispex,                      Object) \
+    X(HTMLAttributeCollection,        "NamedNodeMap",                 HTMLAttributeCollection_dispex,         Object) \
+    X(HTMLElementCollection,          "HTMLCollection",               HTMLElementCollection_dispex,           Object) \
+    X(HTMLNamespaceCollection,        "MSNamespaceInfoCollection",    HTMLNamespaceCollection_dispex,         Object) \
+    X(HTMLPluginsCollection,          "PluginArray",                  HTMLPluginsCollection_dispex,           Object) \
+    X(HTMLRectCollection,             "ClientRectList",               HTMLRectCollection_dispex,              Object) \
+    X(HTMLStyleSheetsCollection,      "StyleSheetList",               HTMLStyleSheetsCollection_dispex,       Object) \
+    X(HTMLStyleSheetRulesCollection,  "MSCSSRuleList",                HTMLStyleSheetRulesCollection_dispex,   Object) \
+    X(HTMLEventObj,                   "MSEventObj",                   HTMLEventObj_dispex,                    Object) \
+    X(HTMLRect,                       "ClientRect",                   HTMLRect_dispex,                        Object) \
+    X(HTMLScreen,                     "Screen",                       HTMLScreen_dispex,                      Object) \
+    X(HTMLSelectionObject,            "MSSelection",                  HTMLSelectionObject_dispex,             Object) \
+    X(HTMLStorage,                    "Storage",                      HTMLStorage_dispex,                     Object) \
+    X(HTMLTextRange,                  "TextRange",                    HTMLTxtRange_dispex,                    Object) \
+    X(HTMLXMLHttpRequest,             "XMLHttpRequest",               HTMLXMLHttpRequest_dispex,              Object) \
+    X(HTMLCurrentStyle,               "MSCurrentStyleCSSProperties",  HTMLCurrentStyle_dispex,                HTMLCSSProperties) \
+    X(HTMLW3CComputedStyle,           "CSSStyleDeclaration",          HTMLW3CComputedStyle_dispex,            Object) \
+    X(HTMLStyleSheet,                 "CSSStyleSheet",                HTMLStyleSheet_dispex,                  StyleSheet) \
+    X(HTMLStyleSheetRule,             "CSSStyleRule",                 HTMLStyleSheetRule_dispex,              CSSRule) \
+    X(HTMLElement,                    "HTMLElement",                  HTMLElement_dispex,                     DOMElement) \
+    X(HTMLGenericElement,             "HTMLUnknownElement",           HTMLGenericElement_dispex,              HTMLElement) \
+    X(HTMLAnchorElement,              "HTMLAnchorElement",            HTMLAnchorElement_dispex,               HTMLElement) \
+    X(HTMLAreaElement,                "HTMLAreaElement",              HTMLAreaElement_dispex,                 HTMLElement) \
+    X(HTMLBodyElement,                "HTMLBodyElement",              HTMLBodyElement_dispex,                 HTMLElement) \
+    X(HTMLButtonElement,              "HTMLButtonElement",            HTMLButtonElement_dispex,               HTMLElement) \
+    X(HTMLCommentElement,             "Comment",                      HTMLCommentElement_dispex,              DOMCharacterData) \
+    X(HTMLEmbedElement,               "HTMLEmbedElement",             HTMLEmbedElement_dispex,                HTMLElement) \
+    X(HTMLFormElement,                "HTMLFormElement",              HTMLFormElement_dispex,                 HTMLElement) \
+    X(HTMLFrameElement,               "HTMLFrameElement",             HTMLFrameElement_dispex,                HTMLElement) \
+    X(HTMLHeadElement,                "HTMLHeadElement",              HTMLHeadElement_dispex,                 HTMLElement) \
+    X(HTMLHtmlElement,                "HTMLHtmlElement",              HTMLHtmlElement_dispex,                 HTMLElement) \
+    X(HTMLIFrameElement,              "HTMLIFrameElement",            HTMLIFrame_dispex,                      HTMLElement) \
+    X(HTMLImgElement,                 "HTMLImageElement",             HTMLImgElement_dispex,                  HTMLElement) \
+    X(HTMLInputElement,               "HTMLInputElement",             HTMLInputElement_dispex,                HTMLElement) \
+    X(HTMLLabelElement,               "HTMLLabelElement",             HTMLLabelElement_dispex,                HTMLElement) \
+    X(HTMLLinkElement,                "HTMLLinkElement",              HTMLLinkElement_dispex,                 HTMLElement) \
+    X(HTMLMetaElement,                "HTMLMetaElement",              HTMLMetaElement_dispex,                 HTMLElement) \
+    X(HTMLObjectElement,              "HTMLObjectElement",            HTMLObjectElement_dispex,               HTMLElement) \
+    X(HTMLOptionElement,              "HTMLOptionElement",            HTMLOptionElement_dispex,               HTMLElement) \
+    X(HTMLScriptElement,              "HTMLScriptElement",            HTMLScriptElement_dispex,               HTMLElement) \
+    X(HTMLSelectElement,              "HTMLSelectElement",            HTMLSelectElement_dispex,               HTMLElement) \
+    X(HTMLStyleElement,               "HTMLStyleElement",             HTMLStyleElement_dispex,                HTMLElement) \
+    X(HTMLTableElement,               "HTMLTableElement",             HTMLTable_dispex,                       HTMLElement) \
+    X(HTMLTableCellElement,           "HTMLTableDataCellElement",     HTMLTableCell_dispex,                   HTMLTableCellProt) \
+    X(HTMLTableRowElement,            "HTMLTableRowElement",          HTMLTableRow_dispex,                    HTMLElement) \
+    X(HTMLTextAreaElement,            "HTMLTextAreaElement",          HTMLTextAreaElement_dispex,             HTMLElement) \
+    X(HTMLTitleElement,               "HTMLTitleElement",             HTMLTitleElement_dispex,                HTMLElement)
+
+#define PROXY_PROTOTYPE_LIST \
+    X(Console,                        "Console",                      console_dispex,                         Object) \
+    X(Crypto,                         "Crypto",                       crypto_dispex,                          Object) \
+    X(SubtleCrypto,                   "SubtleCrypto",                 crypto_subtle_dispex,                   Object) \
+    X(DOMEvent,                       "Event",                        DOMEvent_dispex,                        Object) \
+    X(DOMCustomEvent,                 "CustomEvent",                  DOMCustomEvent_dispex,                  DOMEvent) \
+    X(DOMKeyboardEvent,               "KeyboardEvent",                DOMKeyboardEvent_dispex,                DOMUIEvent) \
+    X(DOMMessageEvent,                "MessageEvent",                 DOMMessageEvent_dispex,                 DOMEvent) \
+    X(DOMMouseEvent,                  "MouseEvent",                   DOMMouseEvent_dispex,                   DOMUIEvent) \
+    X(DOMUIEvent,                     "UIEvent",                      DOMUIEvent_dispex,                      DOMEvent) \
+    X(DOMCharacterData,               "CharacterData",                DOMCharacterData_dispex,                HTMLDOMNode) \
+    X(Document,                       "Document",                     DocumentNode_dispex,                    HTMLDOMNode) \
+    X(XMLDocument,                    "XMLDocument",                  XMLDocumentNode_dispex,                 Document) \
+    X(DOMElement,                     "Element",                      DOMElement_dispex,                      HTMLDOMNode) \
+    X(CSSRule,                        "CSSRule",                      CSSRule_dispex,                         Object) \
+    X(StyleSheet,                     "StyleSheet",                   StyleSheet_dispex,                      Object) \
+    X(DOMTokenList,                   "DOMTokenList",                 DOMTokenList_dispex,                    Object) \
+    X(HTMLDOMNode,                    "Node",                         HTMLDOMNode_dispex,                     Object) \
+    X(HTMLDOMRange,                   "Range",                        HTMLDOMRange_dispex,                    Object) \
+    X(HTMLFiltersCollection,          "FiltersCollection",            HTMLFiltersCollection_dispex,           Object) \
+    X(HTMLMimeTypesCollection,        "MimeTypeArray",                HTMLMimeTypesCollection_dispex,         Object) \
+    X(HTMLPerformance,                "Performance",                  HTMLPerformance_dispex,                 Object) \
+    X(HTMLPerformanceNavigation,      "PerformanceNavigation",        HTMLPerformanceNavigation_dispex,       Object) \
+    X(HTMLPerformanceTiming,          "PerformanceTiming",            HTMLPerformanceTiming_dispex,           Object) \
+    X(HTMLCSSProperties,              "MSCSSProperties",              HTMLCSSProperties_dispex,               HTMLW3CComputedStyle) \
+    X(HTMLStyle,                      "MSStyleCSSProperties",         HTMLStyle_dispex,                       HTMLCSSProperties) \
+    X(HTMLTableCellProt,              "HTMLTableCellElement",         HTMLTableCellProt_dispex,               HTMLElement)
+
+typedef enum {
+    PROTO_ID_NULL = -2,
+    PROTO_ID_Object = -1,  /* jscript Object.prototype */
+#define X(id, name, dispex, proto_id) PROTO_ID_ ## id,
+COMPAT_ONLY_PROTOTYPE_LIST
+    COMPAT_ONLY_PROTOTYPE_COUNT,
+    PROTO_ID_LAST_COMPAT_ONLY = COMPAT_ONLY_PROTOTYPE_COUNT - 1,
+COMPAT_PROTOTYPE_LIST
+    COMPAT_PROTOTYPE_COUNT,
+    PROTO_ID_LAST_COMPAT = COMPAT_PROTOTYPE_COUNT - 1,
+PROXY_PROTOTYPE_LIST
+#undef X
+} prototype_id_t;
+
+typedef enum {
+#define X(id, name, dispex, proto_id) COMPAT_CTOR_ID_ ## id,
+COMPAT_ONLY_PROTOTYPE_LIST
+COMPAT_PROTOTYPE_LIST
+#undef X
+    /* extra ctors that share prototypes */
+    COMPAT_CTOR_ID_Image,
+    COMPAT_CTOR_ID_Option,
+
+    COMPAT_CTOR_ID_Image_builtin,
+    COMPAT_CTOR_ID_Option_builtin,
+    COMPAT_CTOR_ID_HTMLXMLHttpRequest_builtin,
+
+    COMPAT_CTOR_COUNT
+} compat_ctor_id_t;
+
 typedef enum {
     COMPAT_MODE_QUIRKS,
     COMPAT_MODE_IE5,
@@ -319,12 +526,16 @@ typedef struct dispex_dynamic_data_t dispex_dynamic_data_t;
 #define MSHTML_DISPID_CUSTOM_MAX 0x6fffffff
 #define MSHTML_CUSTOM_DISPID_CNT (MSHTML_DISPID_CUSTOM_MAX-MSHTML_DISPID_CUSTOM_MIN)
 
+typedef struct HTMLDocumentNode HTMLDocumentNode;
 typedef struct DispatchEx DispatchEx;
+struct compat_prototype;
 
 typedef struct {
     HRESULT (*value)(DispatchEx*,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,IServiceProvider*);
     HRESULT (*get_dispid)(DispatchEx*,BSTR,DWORD,DISPID*);
-    HRESULT (*invoke)(DispatchEx*,DISPID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,IServiceProvider*);
+    HRESULT (*invoke)(DispatchEx*,IDispatch*,DISPID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,IServiceProvider*);
+    HRESULT (*delete)(DispatchEx*,DISPID);
+    HRESULT (*get_static_dispid)(compat_mode_t,BSTR,DWORD,DISPID*);
     compat_mode_t (*get_compat_mode)(DispatchEx*);
     HRESULT (*populate_props)(DispatchEx*);
 } dispex_static_data_vtbl_t;
@@ -332,6 +543,7 @@ typedef struct {
 typedef struct {
     const WCHAR *name;
     const dispex_static_data_vtbl_t *vtbl;
+    const prototype_id_t prototype_id;
     const tid_t disp_tid;
     const tid_t* const iface_tids;
     void (*init_info)(dispex_data_t*,compat_mode_t);
@@ -351,6 +563,8 @@ struct DispatchEx {
     IDispatchEx IDispatchEx_iface;
 
     IUnknown *outer;
+    IWineDispatchProxyCbPrivate *proxy;
+    struct compat_prototype *prototype;
 
     dispex_data_t *info;
     dispex_dynamic_data_t *dynamic_data;
@@ -383,14 +597,18 @@ extern void (__cdecl *ccp_init)(ExternalCycleCollectionParticipant*,const CCObjC
 extern void (__cdecl *describe_cc_node)(nsCycleCollectingAutoRefCnt*,const char*,nsCycleCollectionTraversalCallback*) DECLSPEC_HIDDEN;
 extern void (__cdecl *note_cc_edge)(nsISupports*,const char*,nsCycleCollectionTraversalCallback*) DECLSPEC_HIDDEN;
 
-void init_dispatch(DispatchEx*,IUnknown*,dispex_static_data_t*,compat_mode_t) DECLSPEC_HIDDEN;
+void init_dispatch(DispatchEx*,IUnknown*,dispex_static_data_t*,HTMLDocumentNode*,compat_mode_t) DECLSPEC_HIDDEN;
 void release_dispex(DispatchEx*) DECLSPEC_HIDDEN;
+void update_dispex(DispatchEx*,dispex_static_data_t*,HTMLDocumentNode*,compat_mode_t) DECLSPEC_HIDDEN;
 BOOL dispex_query_interface(DispatchEx*,REFIID,void**) DECLSPEC_HIDDEN;
 HRESULT change_type(VARIANT*,VARIANT*,VARTYPE,IServiceProvider*) DECLSPEC_HIDDEN;
 HRESULT dispex_get_dprop_ref(DispatchEx*,const WCHAR*,BOOL,VARIANT**) DECLSPEC_HIDDEN;
 HRESULT get_dispids(tid_t,DWORD*,DISPID**) DECLSPEC_HIDDEN;
+BOOL is_custom_attribute(DispatchEx*,const WCHAR*) DECLSPEC_HIDDEN;
 HRESULT remove_attribute(DispatchEx*,DISPID,VARIANT_BOOL*) DECLSPEC_HIDDEN;
 HRESULT dispex_get_dynid(DispatchEx*,const WCHAR*,DISPID*) DECLSPEC_HIDDEN;
+HRESULT dispex_invoke(DispatchEx*,IDispatch*,DISPID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,IServiceProvider*) DECLSPEC_HIDDEN;
+HRESULT dispex_delete_prop(DispatchEx*,DISPID) DECLSPEC_HIDDEN;
 void dispex_traverse(DispatchEx*,nsCycleCollectionTraversalCallback*) DECLSPEC_HIDDEN;
 void dispex_unlink(DispatchEx*) DECLSPEC_HIDDEN;
 void release_typelib(void) DECLSPEC_HIDDEN;
@@ -401,6 +619,9 @@ compat_mode_t dispex_compat_mode(DispatchEx*) DECLSPEC_HIDDEN;
 HRESULT dispex_to_string(DispatchEx*,BSTR*) DECLSPEC_HIDDEN;
 HRESULT dispex_call_builtin(DispatchEx *dispex, DISPID id, DISPPARAMS *dp,
                             VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller) DECLSPEC_HIDDEN;
+BOOL dispex_is_builtin_attribute(DispatchEx*,DISPID); DECLSPEC_HIDDEN;
+BOOL dispex_is_builtin_method(DispatchEx*,DISPID) DECLSPEC_HIDDEN;
+BOOL dispex_is_builtin_value(DispatchEx*,DISPID) DECLSPEC_HIDDEN;
 
 typedef enum {
     DISPEXPROP_CUSTOM,
@@ -413,7 +634,6 @@ dispex_prop_type_t get_dispid_type(DISPID) DECLSPEC_HIDDEN;
 typedef struct HTMLWindow HTMLWindow;
 typedef struct HTMLInnerWindow HTMLInnerWindow;
 typedef struct HTMLOuterWindow HTMLOuterWindow;
-typedef struct HTMLDocumentNode HTMLDocumentNode;
 typedef struct HTMLDocumentObj HTMLDocumentObj;
 typedef struct HTMLFrameBase HTMLFrameBase;
 typedef struct GeckoBrowser GeckoBrowser;
@@ -421,6 +641,29 @@ typedef struct HTMLAttributeCollection HTMLAttributeCollection;
 
 typedef struct ScriptHost ScriptHost;
 
+struct compat_ctor {
+    DispatchEx dispex;
+    union {
+        IUnknown IUnknown_iface;
+        IHTMLOptionElementFactory IHTMLOptionElementFactory_iface;
+        IHTMLImageElementFactory IHTMLImageElementFactory_iface;
+        IHTMLXMLHttpRequestFactory IHTMLXMLHttpRequestFactory_iface;
+    };
+
+    LONG ref;
+
+    prototype_id_t prot_id;
+    HTMLInnerWindow *window;
+};
+
+struct compat_prototype {
+    IUnknown IUnknown_iface;
+    DispatchEx dispex;
+    LONG ref;
+
+    HTMLInnerWindow *window;
+};
+
 typedef enum {
     GLOBAL_SCRIPTVAR,
     GLOBAL_ELEMENTVAR,
@@ -441,33 +684,6 @@ struct EventTarget {
     struct wine_rb_tree handler_map;
 };
 
-typedef struct {
-    DispatchEx dispex;
-    IHTMLOptionElementFactory IHTMLOptionElementFactory_iface;
-
-    LONG ref;
-
-    HTMLInnerWindow *window;
-} HTMLOptionElementFactory;
-
-typedef struct {
-    DispatchEx dispex;
-    IHTMLImageElementFactory IHTMLImageElementFactory_iface;
-
-    LONG ref;
-
-    HTMLInnerWindow *window;
-} HTMLImageElementFactory;
-
-typedef struct {
-    DispatchEx dispex;
-    IHTMLXMLHttpRequestFactory IHTMLXMLHttpRequestFactory_iface;
-
-    LONG ref;
-
-    HTMLInnerWindow *window;
-} HTMLXMLHttpRequestFactory;
-
 struct HTMLLocation {
     DispatchEx dispex;
     IHTMLLocation IHTMLLocation_iface;
@@ -505,6 +721,7 @@ struct HTMLWindow {
     IWineHTMLWindowCompatPrivate IWineHTMLWindowCompatPrivate_iface;
 
     IWineMSHTMLConsole *console;
+    IWineMSHTMLCrypto *crypto;
 
     LONG ref;
 
@@ -521,6 +738,7 @@ struct HTMLOuterWindow {
     mozIDOMWindowProxy *window_proxy;
     HTMLOuterWindow *parent;
     HTMLFrameBase *frame_element;
+    IWineDispatchProxyCbPrivate *saved_proxy;
 
     GeckoBrowser *browser;
     struct list browser_entry;
@@ -551,9 +769,6 @@ struct HTMLInnerWindow {
 
     IHTMLEventObj *event;
 
-    HTMLImageElementFactory *image_factory;
-    HTMLOptionElementFactory *option_factory;
-    HTMLXMLHttpRequestFactory *xhr_factory;
     IHTMLScreen *screen;
     OmHistory *history;
     IOmNavigator *navigator;
@@ -577,6 +792,9 @@ struct HTMLInnerWindow {
     IMoniker *mon;
     nsChannelBSC *bscallback;
     struct list bindings;
+
+    struct compat_ctor *compat_ctors[COMPAT_CTOR_COUNT];
+    struct compat_prototype *compat_prototypes[COMPAT_PROTOTYPE_COUNT];
 };
 
 typedef enum {
@@ -623,6 +841,18 @@ struct  ConnectionPoint {
     cp_static_data_t *data;
 };
 
+typedef enum {
+    DOCTYPE_INVALID = -1,
+    DOCTYPE_HTML,
+    DOCTYPE_XHTML,
+    DOCTYPE_XML,
+    DOCTYPE_SVG,
+    DOCTYPE_COUNT
+} document_type_t;
+
+extern dispex_static_data_t *const dispex_from_document_type[DOCTYPE_COUNT] DECLSPEC_HIDDEN;
+extern const WCHAR *const content_type_from_document_type[DOCTYPE_COUNT] DECLSPEC_HIDDEN;
+
 struct HTMLDocument {
     IHTMLDocument2              IHTMLDocument2_iface;
     IHTMLDocument3              IHTMLDocument3_iface;
@@ -656,8 +886,10 @@ struct HTMLDocument {
     IDisplayServices            IDisplayServices_iface;
     IDocumentRange              IDocumentRange_iface;
 
+    document_type_t doc_type;
+
     IUnknown *outer_unk;
-    IDispatchEx *dispex;
+    DispatchEx *dispex;
 
     HTMLDocumentObj *doc_obj;
     HTMLDocumentNode *doc_node;
@@ -794,7 +1026,7 @@ typedef struct {
     HRESULT (*get_document)(HTMLDOMNode*,IDispatch**);
     HRESULT (*get_readystate)(HTMLDOMNode*,BSTR*);
     HRESULT (*get_dispid)(HTMLDOMNode*,BSTR,DWORD,DISPID*);
-    HRESULT (*invoke)(HTMLDOMNode*,DISPID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,IServiceProvider*);
+    HRESULT (*invoke)(HTMLDOMNode*,IDispatch*,DISPID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,IServiceProvider*);
     HRESULT (*bind_to_tree)(HTMLDOMNode*);
     void (*traverse)(HTMLDOMNode*,nsCycleCollectionTraversalCallback*);
     void (*unlink)(HTMLDOMNode*);
@@ -815,6 +1047,8 @@ struct HTMLDOMNode {
     HTMLDocumentNode *doc;
 };
 
+HTMLDOMNode *unsafe_impl_from_IHTMLDOMNode(IHTMLDOMNode*) DECLSPEC_HIDDEN;
+
 static inline void node_addref(HTMLDOMNode *node)
 {
     IHTMLDOMNode_AddRef(&node->IHTMLDOMNode_iface);
@@ -894,7 +1128,8 @@ struct HTMLDocumentNode {
     compat_mode_t document_mode;
     BOOL document_mode_locked;
 
-    nsIDOMHTMLDocument *nsdoc;
+    nsIDOMDocument *nsdoc;
+    nsIDOMHTMLDocument *nshtmldoc;
     BOOL content_ready;
 
     IHTMLDOMImplementation *dom_implementation;
@@ -922,26 +1157,29 @@ struct HTMLDocumentNode {
 HRESULT HTMLDocument_Create(IUnknown*,REFIID,void**) DECLSPEC_HIDDEN;
 HRESULT MHTMLDocument_Create(IUnknown*,REFIID,void**) DECLSPEC_HIDDEN;
 HRESULT HTMLLoadOptions_Create(IUnknown*,REFIID,void**) DECLSPEC_HIDDEN;
-HRESULT create_document_node(nsIDOMHTMLDocument*,GeckoBrowser*,HTMLInnerWindow*,
-                             compat_mode_t,HTMLDocumentNode**) DECLSPEC_HIDDEN;
+HRESULT create_document_node(nsIDOMDocument*,GeckoBrowser*,HTMLInnerWindow*,
+                             document_type_t,compat_mode_t,HTMLDocumentNode**) DECLSPEC_HIDDEN;
+HRESULT create_xml_document(BSTR,HTMLDocumentNode*,document_type_t,BOOL,IDispatch**) DECLSPEC_HIDDEN;
+HRESULT create_marshaled_doc(HWND,REFIID,void**) DECLSPEC_HIDDEN;
 
 HRESULT create_outer_window(GeckoBrowser*,mozIDOMWindowProxy*,HTMLOuterWindow*,HTMLOuterWindow**) DECLSPEC_HIDDEN;
 HRESULT update_window_doc(HTMLInnerWindow*) DECLSPEC_HIDDEN;
 HTMLOuterWindow *mozwindow_to_window(const mozIDOMWindowProxy*) DECLSPEC_HIDDEN;
 void get_top_window(HTMLOuterWindow*,HTMLOuterWindow**) DECLSPEC_HIDDEN;
-HRESULT HTMLOptionElementFactory_Create(HTMLInnerWindow*,HTMLOptionElementFactory**) DECLSPEC_HIDDEN;
-HRESULT HTMLImageElementFactory_Create(HTMLInnerWindow*,HTMLImageElementFactory**) DECLSPEC_HIDDEN;
-HRESULT HTMLXMLHttpRequestFactory_Create(HTMLInnerWindow*,HTMLXMLHttpRequestFactory**) DECLSPEC_HIDDEN;
+HRESULT compat_ctor_value(DispatchEx*,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,IServiceProvider*);
+HRESULT compat_ctor_get_dispid(DispatchEx*,BSTR,DWORD,DISPID*) DECLSPEC_HIDDEN;
+HRESULT compat_ctor_invoke(DispatchEx*,IDispatch*,DISPID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,IServiceProvider*) DECLSPEC_HIDDEN;
+HRESULT compat_ctor_delete(DispatchEx*,DISPID) DECLSPEC_HIDDEN;
 HRESULT HTMLLocation_Create(HTMLInnerWindow*,HTMLLocation**) DECLSPEC_HIDDEN;
-HRESULT create_navigator(compat_mode_t,IOmNavigator**) DECLSPEC_HIDDEN;
-HRESULT create_html_screen(compat_mode_t,IHTMLScreen**) DECLSPEC_HIDDEN;
+HRESULT create_navigator(HTMLDocumentNode*,compat_mode_t,IOmNavigator**) DECLSPEC_HIDDEN;
+HRESULT create_html_screen(HTMLDocumentNode*,compat_mode_t,IHTMLScreen**) DECLSPEC_HIDDEN;
 HRESULT create_performance(compat_mode_t,IHTMLPerformance**) DECLSPEC_HIDDEN;
 HRESULT create_history(HTMLInnerWindow*,OmHistory**) DECLSPEC_HIDDEN;
-HRESULT create_namespace_collection(compat_mode_t,IHTMLNamespaceCollection**) DECLSPEC_HIDDEN;
+HRESULT create_namespace_collection(HTMLDocumentNode*,IHTMLNamespaceCollection**) DECLSPEC_HIDDEN;
 HRESULT create_dom_implementation(HTMLDocumentNode*,IHTMLDOMImplementation**) DECLSPEC_HIDDEN;
 void detach_dom_implementation(IHTMLDOMImplementation*) DECLSPEC_HIDDEN;
 
-HRESULT create_html_storage(compat_mode_t,IHTMLStorage**) DECLSPEC_HIDDEN;
+HRESULT create_html_storage(compat_mode_t,HTMLDocumentNode*,IHTMLStorage**) DECLSPEC_HIDDEN;
 
 void HTMLDocument_Persist_Init(HTMLDocument*) DECLSPEC_HIDDEN;
 void HTMLDocument_OleCmd_Init(HTMLDocument*) DECLSPEC_HIDDEN;
@@ -966,7 +1204,7 @@ compat_mode_t lock_document_mode(HTMLDocumentNode*) DECLSPEC_HIDDEN;
 void init_mutation(nsIComponentManager*) DECLSPEC_HIDDEN;
 void init_document_mutation(HTMLDocumentNode*) DECLSPEC_HIDDEN;
 void release_document_mutation(HTMLDocumentNode*) DECLSPEC_HIDDEN;
-JSContext *get_context_from_document(nsIDOMHTMLDocument*) DECLSPEC_HIDDEN;
+JSContext *get_context_from_document(nsIDOMDocument*) DECLSPEC_HIDDEN;
 
 void HTMLDocument_LockContainer(HTMLDocumentObj*,BOOL) DECLSPEC_HIDDEN;
 void show_context_menu(HTMLDocumentObj*,DWORD,POINT*,IDispatch*) DECLSPEC_HIDDEN;
@@ -1025,6 +1263,7 @@ HRESULT nsnode_to_nsstring(nsIDOMNode*,nsAString*) DECLSPEC_HIDDEN;
 void setup_editor_controller(GeckoBrowser*) DECLSPEC_HIDDEN;
 nsresult get_nsinterface(nsISupports*,REFIID,void**) DECLSPEC_HIDDEN;
 nsIWritableVariant *create_nsvariant(void) DECLSPEC_HIDDEN;
+nsIDOMParser *create_nsdomparser(HTMLDocumentNode*) DECLSPEC_HIDDEN;
 nsIXMLHttpRequest *create_nsxhr(nsIDOMWindow *nswindow) DECLSPEC_HIDDEN;
 nsresult create_nsfile(const PRUnichar*,nsIFile**) DECLSPEC_HIDDEN;
 char *get_nscategory_entry(const char*,const char*) DECLSPEC_HIDDEN;
@@ -1041,8 +1280,8 @@ HRESULT get_readystate_string(READYSTATE,BSTR*) DECLSPEC_HIDDEN;
 
 HRESULT HTMLSelectionObject_Create(HTMLDocumentNode*,nsISelection*,IHTMLSelectionObject**) DECLSPEC_HIDDEN;
 HRESULT HTMLTxtRange_Create(HTMLDocumentNode*,nsIDOMRange*,IHTMLTxtRange**) DECLSPEC_HIDDEN;
-HRESULT create_style_sheet(nsIDOMStyleSheet*,compat_mode_t,IHTMLStyleSheet**) DECLSPEC_HIDDEN;
-HRESULT create_style_sheet_collection(nsIDOMStyleSheetList*,compat_mode_t,
+HRESULT create_style_sheet(nsIDOMStyleSheet*,HTMLDocumentNode*,IHTMLStyleSheet**) DECLSPEC_HIDDEN;
+HRESULT create_style_sheet_collection(nsIDOMStyleSheetList*,HTMLDocumentNode*,
                                       IHTMLStyleSheetsCollection**) DECLSPEC_HIDDEN;
 HRESULT create_dom_range(nsIDOMRange*,compat_mode_t,IHTMLDOMRange**) DECLSPEC_HIDDEN;
 HRESULT create_markup_pointer(IMarkupPointer**) DECLSPEC_HIDDEN;
@@ -1051,7 +1290,7 @@ void detach_document_node(HTMLDocumentNode*) DECLSPEC_HIDDEN;
 void detach_selection(HTMLDocumentNode*) DECLSPEC_HIDDEN;
 void detach_ranges(HTMLDocumentNode*) DECLSPEC_HIDDEN;
 HRESULT get_node_text(HTMLDOMNode*,BSTR*) DECLSPEC_HIDDEN;
-HRESULT replace_node_by_html(nsIDOMHTMLDocument*,nsIDOMNode*,const WCHAR*) DECLSPEC_HIDDEN;
+HRESULT replace_node_by_html(nsIDOMDocument*,nsIDOMNode*,const WCHAR*) DECLSPEC_HIDDEN;
 
 HRESULT create_nselem(HTMLDocumentNode*,const WCHAR*,nsIDOMElement**) DECLSPEC_HIDDEN;
 HRESULT create_element(HTMLDocumentNode*,const WCHAR*,HTMLElement**) DECLSPEC_HIDDEN;
@@ -1074,12 +1313,15 @@ struct HTMLAttributeCollection {
 
     LONG ref;
 
+    nsIDOMMozNamedAttrMap *nsattrs;
     HTMLElement *elem;
     struct list attrs;
 };
 
 typedef struct {
-    DispatchEx dispex;
+    /* valid only when attribute nodes are used (node.nsnode) */
+    HTMLDOMNode node;
+
     IHTMLDOMAttribute IHTMLDOMAttribute_iface;
     IHTMLDOMAttribute2 IHTMLDOMAttribute2_iface;
 
@@ -1097,7 +1339,8 @@ typedef struct {
 
 HTMLDOMAttribute *unsafe_impl_from_IHTMLDOMAttribute(IHTMLDOMAttribute*) DECLSPEC_HIDDEN;
 
-HRESULT HTMLDOMAttribute_Create(const WCHAR*,HTMLElement*,DISPID,compat_mode_t,HTMLDOMAttribute**) DECLSPEC_HIDDEN;
+HRESULT HTMLDOMAttribute_Create(const WCHAR*,HTMLDocumentNode*,HTMLElement*,DISPID,nsIDOMAttr*,
+                                compat_mode_t,HTMLDOMAttribute**) DECLSPEC_HIDDEN;
 
 HRESULT HTMLElement_Create(HTMLDocumentNode*,nsIDOMNode*,BOOL,HTMLElement**) DECLSPEC_HIDDEN;
 HRESULT HTMLCommentElement_Create(HTMLDocumentNode*,nsIDOMNode*,HTMLElement**) DECLSPEC_HIDDEN;
@@ -1133,7 +1376,7 @@ HRESULT create_svg_element(HTMLDocumentNode*,nsIDOMSVGElement*,const WCHAR*,HTML
 void HTMLDOMNode_Init(HTMLDocumentNode*,HTMLDOMNode*,nsIDOMNode*,dispex_static_data_t*) DECLSPEC_HIDDEN;
 void HTMLElement_Init(HTMLElement*,HTMLDocumentNode*,nsIDOMElement*,dispex_static_data_t*) DECLSPEC_HIDDEN;
 
-void EventTarget_Init(EventTarget*,IUnknown*,dispex_static_data_t*,compat_mode_t) DECLSPEC_HIDDEN;
+void EventTarget_Init(EventTarget*,IUnknown*,dispex_static_data_t*,HTMLDocumentNode*) DECLSPEC_HIDDEN;
 HRESULT EventTarget_QI(EventTarget*,REFIID,void**) DECLSPEC_HIDDEN;
 void EventTarget_init_dispex_info(dispex_data_t*,compat_mode_t) DECLSPEC_HIDDEN;
 
@@ -1163,9 +1406,9 @@ HRESULT handle_link_click_event(HTMLElement*,nsAString*,nsAString*,nsIDOMEvent*,
 HRESULT wrap_iface(IUnknown*,IUnknown*,IUnknown**) DECLSPEC_HIDDEN;
 
 IHTMLElementCollection *create_all_collection(HTMLDOMNode*,BOOL) DECLSPEC_HIDDEN;
-IHTMLElementCollection *create_collection_from_nodelist(nsIDOMNodeList*,compat_mode_t) DECLSPEC_HIDDEN;
-IHTMLElementCollection *create_collection_from_htmlcol(nsIDOMHTMLCollection*,compat_mode_t) DECLSPEC_HIDDEN;
-HRESULT create_child_collection(nsIDOMNodeList*,compat_mode_t,IHTMLDOMChildrenCollection**) DECLSPEC_HIDDEN;
+IHTMLElementCollection *create_collection_from_nodelist(nsIDOMNodeList*,HTMLDocumentNode*) DECLSPEC_HIDDEN;
+IHTMLElementCollection *create_collection_from_htmlcol(nsIDOMHTMLCollection*,HTMLDocumentNode*) DECLSPEC_HIDDEN;
+HRESULT create_child_collection(nsIDOMNodeList*,HTMLDocumentNode*,IHTMLDOMChildrenCollection**) DECLSPEC_HIDDEN;
 
 HRESULT attr_value_to_string(VARIANT*) DECLSPEC_HIDDEN;
 HRESULT get_elem_attr_value_by_dispid(HTMLElement*,DISPID,VARIANT*) DECLSPEC_HIDDEN;
@@ -1247,6 +1490,7 @@ enum timer_type {
 
 HRESULT set_task_timer(HTMLInnerWindow*,LONG,enum timer_type,IDispatch*,LONG*) DECLSPEC_HIDDEN;
 HRESULT clear_task_timer(HTMLInnerWindow*,DWORD) DECLSPEC_HIDDEN;
+HRESULT clear_animation_timer(HTMLInnerWindow*,DWORD) DECLSPEC_HIDDEN;
 
 BOOL parse_compat_version(const WCHAR*,compat_mode_t*) DECLSPEC_HIDDEN;
 
@@ -1388,11 +1632,11 @@ static inline char *heap_strndupWtoU(LPCWSTR str, unsigned len)
     char *ret = NULL;
     DWORD size;
 
-    if(str && len) {
-        size = WideCharToMultiByte(CP_UTF8, 0, str, len, NULL, 0, NULL, NULL);
+    if(str) {
+        size = len ? WideCharToMultiByte(CP_UTF8, 0, str, len, NULL, 0, NULL, NULL) : 0;
         ret = heap_alloc(size + 1);
         if(ret) {
-            WideCharToMultiByte(CP_UTF8, 0, str, len, ret, size, NULL, NULL);
+            if(len) WideCharToMultiByte(CP_UTF8, 0, str, len, ret, size, NULL, NULL);
             ret[size] = '\0';
         }
     }
@@ -1417,9 +1661,28 @@ extern void *call_thiscall_func;
 compat_mode_t get_max_compat_mode(IUri*) DECLSPEC_HIDDEN;
 UINT cp_from_charset_string(BSTR) DECLSPEC_HIDDEN;
 BSTR charset_string_from_cp(UINT) DECLSPEC_HIDDEN;
+HRESULT get_mime_type_display_name(const WCHAR*,BSTR*) DECLSPEC_HIDDEN;
 HINSTANCE get_shdoclc(void) DECLSPEC_HIDDEN;
 void set_statustext(HTMLDocumentObj*,INT,LPCWSTR) DECLSPEC_HIDDEN;
 IInternetSecurityManager *get_security_manager(void) DECLSPEC_HIDDEN;
 
 extern HINSTANCE hInst DECLSPEC_HIDDEN;
 void create_console(compat_mode_t compat_mode, IWineMSHTMLConsole **ret) DECLSPEC_HIDDEN;
+void create_crypto(compat_mode_t compat_mode, IWineMSHTMLCrypto **ret) DECLSPEC_HIDDEN;
+
+extern const IHTMLImageElementFactoryVtbl HTMLImageElementFactoryVtbl DECLSPEC_HIDDEN;
+extern const IHTMLOptionElementFactoryVtbl HTMLOptionElementFactoryVtbl DECLSPEC_HIDDEN;
+extern const IHTMLXMLHttpRequestFactoryVtbl HTMLXMLHttpRequestFactoryVtbl DECLSPEC_HIDDEN;
+extern dispex_static_data_t HTMLImageElementFactory_dispex DECLSPEC_HIDDEN;
+extern dispex_static_data_t HTMLOptionElementFactory_dispex DECLSPEC_HIDDEN;
+extern dispex_static_data_t HTMLXMLHttpRequestFactory_dispex DECLSPEC_HIDDEN;
+extern dispex_static_data_t HTMLImageCtor_dispex DECLSPEC_HIDDEN;
+extern dispex_static_data_t HTMLOptionCtor_dispex DECLSPEC_HIDDEN;
+extern dispex_static_data_t HTMLXMLHttpRequestCtor_dispex DECLSPEC_HIDDEN;
+extern dispex_static_data_t DOMParserCtor_dispex DECLSPEC_HIDDEN;
+
+#define X(id, name, dispex, proto_id) extern dispex_static_data_t dispex DECLSPEC_HIDDEN;
+COMPAT_ONLY_PROTOTYPE_LIST
+COMPAT_PROTOTYPE_LIST
+PROXY_PROTOTYPE_LIST
+#undef X
diff --git a/dlls/mshtml/mshtml_private_iface.idl b/dlls/mshtml/mshtml_private_iface.idl
index b9039c956db..aa28d1620f2 100644
--- a/dlls/mshtml/mshtml_private_iface.idl
+++ b/dlls/mshtml/mshtml_private_iface.idl
@@ -76,6 +76,66 @@ interface IWineMSHTMLConsole : IDispatch
     HRESULT warn([in, optional] VARIANT *varargStart);
 }
 
+[
+    odl,
+    oleautomation,
+    dual,
+    hidden,
+    uuid(fd55b4b6-2813-4fb4-829d-380099474ab2)
+]
+interface IWineMSHTMLCrypto : IDispatch
+{
+    [propget, id(1)]
+    HRESULT subtle([retval, out] IDispatch **subtle);
+    [id(2)]
+    HRESULT getRandomValues([in] VARIANT *typedArray, [retval, out] IDispatch **ret);
+}
+
+[
+    odl,
+    oleautomation,
+    dual,
+    hidden,
+    uuid(fd55b4b6-2813-4fb4-829d-380099474ab3)
+]
+interface IWineMSHTMLSubtleCrypto : IDispatch
+{
+    [id(1)]
+    HRESULT encrypt([in] VARIANT *algorithm, [in] VARIANT *key, [in] VARIANT *data, [retval, out] IDispatch **result);
+    [id(2)]
+    HRESULT decrypt([in] VARIANT *algorithm, [in] VARIANT *key, [in] VARIANT *data, [retval, out] IDispatch **result);
+    [id(3)]
+    HRESULT sign([in] VARIANT *algorithm, [in] VARIANT *key, [in] VARIANT *data, [retval, out] IDispatch **signature);
+    [id(4)]
+    HRESULT verify([in] VARIANT *algorithm, [in] VARIANT *key, [in] VARIANT *signature, [in] VARIANT *data,
+                   [retval, out] IDispatch **result);
+    [id(5)]
+    HRESULT digest([in] VARIANT *algorithm, [in] VARIANT *data, [retval, out] IDispatch **digest);
+    [id(6)]
+    HRESULT generateKey([in] VARIANT *algorithm, VARIANT_BOOL extractable, [in] VARIANT *keyUsages,
+                        [retval, out] IDispatch **result);
+    [id(7)]
+    HRESULT deriveKey([in] VARIANT *algorithm, [in] VARIANT *baseKey, [in] VARIANT *derivedKeyAlgorithm,
+                      VARIANT_BOOL extractable, [in] VARIANT *keyUsages, [retval, out] IDispatch **result);
+    [id(8)]
+    HRESULT importKey([in] BSTR format, [in] VARIANT *keyData, [in] VARIANT *algorithm, VARIANT_BOOL extractable,
+                      [in] VARIANT *keyUsages, [retval, out] IDispatch **result);
+    [id(9)]
+    HRESULT exportKey([in] BSTR format, [in] VARIANT *key, [retval, out] IDispatch **result);
+    [id(10)]
+    HRESULT wrapKey([in] BSTR format, [in] VARIANT *key, [in] VARIANT *wrappingKey, [in] VARIANT *wrapAlgo,
+                    [retval, out] IDispatch **result);
+    [id(11)]
+    HRESULT unwrapKey([in] BSTR format, [in] VARIANT *wrappedKey, [in] VARIANT *unwrappingKey,
+                      [in] VARIANT *unwrapAlgo, [in] VARIANT *unwrappedKeyAlgo, VARIANT_BOOL extractable,
+                      [in] VARIANT *keyUsages, [retval, out] IDispatch **result);
+}
+
+const long DISPID_IWINEHTMLWINDOWPRIVATE_REQUESTANIMATIONFRAME = 50;
+const long DISPID_IWINEHTMLWINDOWPRIVATE_CANCELANIMATIONFRAME = 51;
+const long DISPID_IWINEHTMLWINDOWPRIVATE_CONSOLE = 52;
+const long DISPID_IWINEHTMLWINDOWPRIVATE_DOMPARSER = 53;
+const long DISPID_IWINEHTMLWINDOWPRIVATE_MSCRYPTO = 54;
 [
     odl,
     oleautomation,
@@ -85,10 +145,16 @@ interface IWineMSHTMLConsole : IDispatch
 ]
 interface IWineHTMLWindowPrivate : IDispatch
 {
-    [id(50)]
+    [id(DISPID_IWINEHTMLWINDOWPRIVATE_REQUESTANIMATIONFRAME)]
     HRESULT requestAnimationFrame([in] VARIANT *expr, [retval, out] VARIANT *timer_id);
-    [propget, id(51)]
+    [id(DISPID_IWINEHTMLWINDOWPRIVATE_CANCELANIMATIONFRAME)]
+    HRESULT cancelAnimationFrame([in] VARIANT timer_id);
+    [propget, id(DISPID_IWINEHTMLWINDOWPRIVATE_CONSOLE)]
     HRESULT console([retval, out] IDispatch **console);
+    [propget, id(DISPID_IWINEHTMLWINDOWPRIVATE_DOMPARSER)]
+    HRESULT DOMParser([retval, out] IDispatch **dom_parser);
+    [propget, id(DISPID_IWINEHTMLWINDOWPRIVATE_MSCRYPTO)]
+    HRESULT msCrypto([retval, out] IDispatch **crypto);
 }
 
 [
@@ -120,6 +186,86 @@ interface IWineHTMLElementPrivate : IDispatch
     HRESULT classList([retval, out] IDispatch **class_list);
 }
 
+const long DISPID_IWINEHTMLFORMPRIVATE_NOVALIDATE = 51;
+const long DISPID_IWINEHTMLFORMPRIVATE_CHECKVALIDITY = 52;
+[
+    odl,
+    oleautomation,
+    dual,
+    hidden,
+    uuid(465908fd-f394-489f-b7a3-4c00fbbe9eed)
+]
+interface IWineHTMLFormPrivate : IDispatch
+{
+    [propput, id(50)]
+    HRESULT enctype([in] BSTR v);
+    [propget, id(50)]
+    HRESULT enctype([retval, out] BSTR *ret);
+    [propput, id(DISPID_IWINEHTMLFORMPRIVATE_NOVALIDATE)]
+    HRESULT noValidate([in] VARIANT_BOOL v);
+    [propget, id(DISPID_IWINEHTMLFORMPRIVATE_NOVALIDATE)]
+    HRESULT noValidate([retval, out] VARIANT_BOOL *ret);
+    [id(DISPID_IWINEHTMLFORMPRIVATE_CHECKVALIDITY)]
+    HRESULT checkValidity([retval, out] VARIANT_BOOL *ret);
+}
+
+[
+    odl,
+    oleautomation,
+    dual,
+    hidden,
+    uuid(465908fd-f394-489f-b7a3-4c00fbbe9eee)
+]
+interface IWineHTMLParentFormPrivate : IDispatch
+{
+    [propput, id(60)]
+    HRESULT formAction([in] BSTR v);
+    [propget, id(60)]
+    HRESULT formAction([retval, out] BSTR *ret);
+    [propput, id(61)]
+    HRESULT formEnctype([in] BSTR v);
+    [propget, id(61)]
+    HRESULT formEnctype([retval, out] BSTR *ret);
+    [propput, id(62)]
+    HRESULT formMethod([in] BSTR v);
+    [propget, id(62)]
+    HRESULT formMethod([retval, out] BSTR *ret);
+    [propput, id(63)]
+    HRESULT formNoValidate([in] VARIANT_BOOL v);
+    [propget, id(63)]
+    HRESULT formNoValidate([retval, out] VARIANT_BOOL *ret);
+    [propput, id(64)]
+    HRESULT formTarget([in] BSTR v);
+    [propget, id(64)]
+    HRESULT formTarget([retval, out] BSTR *ret);
+}
+
+const long DISPID_IWINEHTMLINPUTPRIVATE_AUTOFOCUS = 50;
+[
+    odl,
+    oleautomation,
+    dual,
+    hidden,
+    uuid(465908fd-f394-489f-b7a3-4c00fbbe9eef)
+]
+interface IWineHTMLInputPrivate : IDispatch
+{
+    [propput, id(DISPID_IWINEHTMLINPUTPRIVATE_AUTOFOCUS)]
+    HRESULT autofocus([in] VARIANT_BOOL v);
+    [propget, id(DISPID_IWINEHTMLINPUTPRIVATE_AUTOFOCUS)]
+    HRESULT autofocus([retval, out] VARIANT_BOOL *ret);
+    [propget, id(51)]
+    HRESULT validationMessage([retval, out] BSTR *ret);
+    [propget, id(52)]
+    HRESULT validity([retval, out] IDispatch **ret);
+    [propget, id(53)]
+    HRESULT willValidate([retval, out] VARIANT_BOOL *ret);
+    [id(54)]
+    HRESULT setCustomValidity([in] VARIANT *message);
+    [id(55)]
+    HRESULT checkValidity([retval, out] VARIANT_BOOL *ret);
+}
+
 [
     odl,
     oleautomation,
diff --git a/dlls/mshtml/mutation.c b/dlls/mshtml/mutation.c
index 3355139ad31..57e4de28380 100644
--- a/dlls/mshtml/mutation.c
+++ b/dlls/mshtml/mutation.c
@@ -374,6 +374,7 @@ compat_mode_t lock_document_mode(HTMLDocumentNode *doc)
 
 static void set_document_mode(HTMLDocumentNode *doc, compat_mode_t document_mode, BOOL lock)
 {
+    dispex_static_data_t *dispex_data = &HTMLDocumentNode_dispex;
     compat_mode_t max_compat_mode;
 
     if(doc->document_mode_locked) {
@@ -395,6 +396,25 @@ static void set_document_mode(HTMLDocumentNode *doc, compat_mode_t document_mode
     doc->document_mode = document_mode;
     if(lock)
         lock_document_mode(doc);
+
+    if(doc->basedoc.doc_type != DOCTYPE_HTML)
+        return;
+
+    /* The prototype and dispex need to be changed since they depend on mode */
+    if(doc->window && doc->window->compat_prototypes[PROTO_ID_HTMLDocument]) {
+        IUnknown_Release(&doc->window->compat_prototypes[PROTO_ID_HTMLDocument]->IUnknown_iface);
+        doc->window->compat_prototypes[PROTO_ID_HTMLDocument] = NULL;
+    }
+
+    if(doc->node.event_target.dispex.prototype) {
+        IUnknown_Release(&doc->node.event_target.dispex.prototype->IUnknown_iface);
+        doc->node.event_target.dispex.prototype = NULL;
+    }
+
+    if(COMPAT_MODE_IE9 <= document_mode && document_mode < COMPAT_MODE_IE11)
+        dispex_data = &DocumentNode_dispex;
+
+    update_dispex(&doc->node.event_target.dispex, dispex_data, doc, document_mode);
 }
 
 BOOL parse_compat_version(const WCHAR *version_string, compat_mode_t *r)
@@ -937,7 +957,7 @@ void init_document_mutation(HTMLDocumentNode *doc)
 
     doc->nsIDocumentObserver_iface.lpVtbl = &nsDocumentObserverVtbl;
 
-    nsres = nsIDOMHTMLDocument_QueryInterface(doc->nsdoc, &IID_nsIDocument, (void**)&nsdoc);
+    nsres = nsIDOMDocument_QueryInterface(doc->nsdoc, &IID_nsIDocument, (void**)&nsdoc);
     if(NS_FAILED(nsres)) {
         ERR("Could not get nsIDocument: %08lx\n", nsres);
         return;
@@ -952,7 +972,7 @@ void release_document_mutation(HTMLDocumentNode *doc)
     nsIDocument *nsdoc;
     nsresult nsres;
 
-    nsres = nsIDOMHTMLDocument_QueryInterface(doc->nsdoc, &IID_nsIDocument, (void**)&nsdoc);
+    nsres = nsIDOMDocument_QueryInterface(doc->nsdoc, &IID_nsIDocument, (void**)&nsdoc);
     if(NS_FAILED(nsres)) {
         ERR("Could not get nsIDocument: %08lx\n", nsres);
         return;
@@ -962,13 +982,13 @@ void release_document_mutation(HTMLDocumentNode *doc)
     nsIDocument_Release(nsdoc);
 }
 
-JSContext *get_context_from_document(nsIDOMHTMLDocument *nsdoc)
+JSContext *get_context_from_document(nsIDOMDocument *nsdoc)
 {
     nsIDocument *doc;
     JSContext *ctx;
     nsresult nsres;
 
-    nsres = nsIDOMHTMLDocument_QueryInterface(nsdoc, &IID_nsIDocument, (void**)&doc);
+    nsres = nsIDOMDocument_QueryInterface(nsdoc, &IID_nsIDocument, (void**)&doc);
     assert(nsres == NS_OK);
 
     ctx = nsIContentUtils_GetContextFromDocument(content_utils, doc);
diff --git a/dlls/mshtml/navigate.c b/dlls/mshtml/navigate.c
index e750ff28ee1..6be331cacbd 100644
--- a/dlls/mshtml/navigate.c
+++ b/dlls/mshtml/navigate.c
@@ -981,6 +981,10 @@ static HRESULT on_start_nsrequest(nsChannelBSC *This)
 {
     nsresult nsres;
 
+    /* Async request can be cancelled before we got to it */
+    if(NS_FAILED(This->nschannel->status))
+        return E_ABORT; /* FIXME: map status to HRESULT */
+
     This->nschannel->binding = This;
 
     /* FIXME: it's needed for http connections from BindToObject. */
@@ -1690,8 +1694,9 @@ static HRESULT process_response_status_text(const WCHAR *header, const WCHAR *he
         return E_FAIL;
     header = wcschr(header + 1, ' ');
     if(!header || header >= header_end)
-        return E_FAIL;
-    ++header;
+        header = header_end;
+    else
+        ++header;
 
     *status_text = heap_strndupWtoU(header, header_end - header);
 
@@ -2087,7 +2092,7 @@ static HRESULT navigate_fragment(HTMLOuterWindow *window, IUri *uri)
         swprintf(selector, ARRAY_SIZE(selector_formatW)+SysStringLen(frag), selector_formatW, frag);
         nsAString_InitDepend(&selector_str, selector);
         /* NOTE: Gecko doesn't set result to NULL if there is no match, so nselem must be initialized */
-        nsres = nsIDOMHTMLDocument_QuerySelector(window->base.inner_window->doc->nsdoc, &selector_str, &nselem);
+        nsres = nsIDOMDocument_QuerySelector(window->base.inner_window->doc->nsdoc, &selector_str, &nselem);
         nsAString_Finish(&selector_str);
         heap_free(selector);
         if(NS_SUCCEEDED(nsres) && nselem) {
@@ -2396,6 +2401,7 @@ static HRESULT navigate_uri(HTMLOuterWindow *window, IUri *uri, const WCHAR *dis
         DWORD post_data_len = request_data ? request_data->post_data_len : 0;
         void *post_data = post_data_len ? request_data->post_data : NULL;
         const WCHAR *headers = request_data ? request_data->headers : NULL;
+        DWORD scheme;
 
         if(!(flags & BINDING_REFRESH)) {
             BSTR frame_name = NULL;
@@ -2418,6 +2424,12 @@ static HRESULT navigate_uri(HTMLOuterWindow *window, IUri *uri, const WCHAR *dis
 
         if(is_main_content_window(window))
             return super_navigate(window, uri, flags, headers, post_data, post_data_len);
+
+        hres = IUri_GetScheme(uri, &scheme);
+        if(SUCCEEDED(hres) && scheme == URL_SCHEME_JAVASCRIPT) {
+            FIXME("HACK Using super_navigate for javascript: navigation\n");
+            return super_navigate(window, uri, flags, headers, post_data, post_data_len);
+        }
     }
 
     if(is_main_content_window(window)) {
diff --git a/dlls/mshtml/nsembed.c b/dlls/mshtml/nsembed.c
index e34861b13fa..0d13b7604d8 100644
--- a/dlls/mshtml/nsembed.c
+++ b/dlls/mshtml/nsembed.c
@@ -42,6 +42,7 @@ WINE_DECLARE_DEBUG_CHANNEL(gecko);
 #define NS_WEBBROWSER_CONTRACTID "@mozilla.org/embedding/browser/nsWebBrowser;1"
 #define NS_COMMANDPARAMS_CONTRACTID "@mozilla.org/embedcomp/command-params;1"
 #define NS_HTMLSERIALIZER_CONTRACTID "@mozilla.org/layout/contentserializer;1?mimetype=text/html"
+#define NS_DOMPARSER_CONTRACTID "@mozilla.org/xmlextras/domparser;1"
 #define NS_EDITORCONTROLLER_CONTRACTID "@mozilla.org/editor/editorcontroller;1"
 #define NS_PREFERENCES_CONTRACTID "@mozilla.org/preferences;1"
 #define NS_VARIANT_CONTRACTID "@mozilla.org/variant;1"
@@ -917,7 +918,6 @@ HRESULT map_nsresult(nsresult nsres)
 HRESULT return_nsstr(nsresult nsres, nsAString *nsstr, BSTR *p)
 {
     const PRUnichar *str;
-    HRESULT hres = S_OK;
 
     if(NS_FAILED(nsres)) {
         WARN("failed: %08lx\n", nsres);
@@ -930,13 +930,13 @@ HRESULT return_nsstr(nsresult nsres, nsAString *nsstr, BSTR *p)
     if(*str) {
         *p = SysAllocString(str);
         if(!*p)
-            hres = E_OUTOFMEMORY;
+            return E_OUTOFMEMORY;
     }else {
         *p = NULL;
     }
 
     nsAString_Finish(nsstr);
-    return hres;
+    return S_OK;
 }
 
 HRESULT return_nsstr_variant(nsresult nsres, nsAString *nsstr, unsigned flags, VARIANT *p)
@@ -1660,7 +1660,7 @@ static nsresult NSAPI nsContextMenuListener_OnShowContextMenu(nsIContextMenuList
     if(FAILED(hres))
         return NS_ERROR_FAILURE;
 
-    hres = create_event_from_nsevent(aEvent, dispex_compat_mode(&node->event_target.dispex), &event);
+    hres = create_event_from_nsevent(aEvent, node->doc, dispex_compat_mode(&node->event_target.dispex), &event);
     if(SUCCEEDED(hres)) {
         dispatch_event(&node->event_target, event);
         IDOMEvent_Release(&event->IDOMEvent_iface);
@@ -1679,7 +1679,12 @@ static nsresult NSAPI nsContextMenuListener_OnShowContextMenu(nsIContextMenuList
     case CONTEXT_TEXT: {
         nsISelection *selection;
 
-        nsres = nsIDOMHTMLDocument_GetSelection(This->doc->basedoc.doc_node->nsdoc, &selection);
+        if(!This->doc->basedoc.doc_node->nshtmldoc) {
+            FIXME("Not implemented for XML document\n");
+            break;
+        }
+
+        nsres = nsIDOMHTMLDocument_GetSelection(This->doc->basedoc.doc_node->nshtmldoc, &selection);
         if(NS_SUCCEEDED(nsres) && selection) {
             cpp_bool is_collapsed;
 
@@ -2406,6 +2411,53 @@ __ASM_GLOBAL_FUNC(call_thiscall_func,
 #define nsIScriptObjectPrincipal_GetPrincipal(this) ((void* (WINAPI*)(void*,void*))&call_thiscall_func)((this)->lpVtbl->GetPrincipal,this)
 #endif
 
+nsIDOMParser *create_nsdomparser(HTMLDocumentNode *doc_node)
+{
+    nsIScriptObjectPrincipal *sop;
+    mozIDOMWindow *inner_window;
+    nsIGlobalObject *nsglo;
+    nsIDOMParser *nsparser;
+    nsIPrincipal *nspri;
+    nsresult nsres;
+
+    if(!doc_node->basedoc.window) {
+        FIXME("No window\n");
+        return NULL;
+    }
+
+    nsres = nsIDOMWindow_GetInnerWindow(doc_node->basedoc.window->nswindow, &inner_window);
+    if(NS_FAILED(nsres)) {
+        ERR("Could not get inner window: %08lx\n", nsres);
+        return NULL;
+    }
+
+    nsres = mozIDOMWindow_QueryInterface(inner_window, &IID_nsIGlobalObject, (void**)&nsglo);
+    mozIDOMWindow_Release(inner_window);
+    assert(nsres == NS_OK);
+
+    nsres = nsIGlobalObject_QueryInterface(nsglo, &IID_nsIScriptObjectPrincipal, (void**)&sop);
+    assert(nsres == NS_OK);
+
+    nspri = nsIScriptObjectPrincipal_GetPrincipal(sop);
+    nsIScriptObjectPrincipal_Release(sop);
+
+    nsres = nsIComponentManager_CreateInstanceByContractID(pCompMgr,
+            NS_DOMPARSER_CONTRACTID, NULL, &IID_nsIDOMParser, (void**)&nsparser);
+    if(NS_SUCCEEDED(nsres)) {
+        nsres = nsIDOMParser_Init(nsparser, nspri, NULL, NULL, nsglo);
+        if(NS_FAILED(nsres))
+            nsIDOMParser_Release(nsparser);
+    }
+    nsISupports_Release(nspri);
+    nsIGlobalObject_Release(nsglo);
+    if(NS_FAILED(nsres)) {
+        ERR("nsIDOMParser_Init failed: %08lx\n", nsres);
+        return NULL;
+    }
+
+    return nsparser;
+}
+
 nsIXMLHttpRequest *create_nsxhr(nsIDOMWindow *nswindow)
 {
     nsIScriptObjectPrincipal *sop;
diff --git a/dlls/mshtml/nsevents.c b/dlls/mshtml/nsevents.c
index e7d99151669..41dd9761e6a 100644
--- a/dlls/mshtml/nsevents.c
+++ b/dlls/mshtml/nsevents.c
@@ -269,7 +269,7 @@ static nsresult NSAPI handle_load(nsIDOMEventListener *iface, nsIDOMEvent *event
     }
 
     if(doc->window) {
-        hres = create_event_from_nsevent(event, dispex_compat_mode(&doc->node.event_target.dispex), &load_event);
+        hres = create_event_from_nsevent(event, doc, dispex_compat_mode(&doc->node.event_target.dispex), &load_event);
         if(SUCCEEDED(hres)) {
             dispatch_event(&doc->window->event_target, load_event);
             IDOMEvent_Release(&load_event->IDOMEvent_iface);
@@ -318,7 +318,7 @@ static nsresult NSAPI handle_htmlevent(nsIDOMEventListener *iface, nsIDOMEvent *
     if(FAILED(hres))
         return NS_OK;
 
-    hres = create_event_from_nsevent(nsevent, dispex_compat_mode(&doc->node.event_target.dispex), &event);
+    hres = create_event_from_nsevent(nsevent, doc, dispex_compat_mode(&doc->node.event_target.dispex), &event);
     if(FAILED(hres)) {
         node_release(node);
         return NS_OK;
diff --git a/dlls/mshtml/nsiface.idl b/dlls/mshtml/nsiface.idl
index 2ecd8d93854..86a59369eb6 100644
--- a/dlls/mshtml/nsiface.idl
+++ b/dlls/mshtml/nsiface.idl
@@ -160,7 +160,6 @@ typedef nsISupports nsITransferable;
 typedef nsISupports nsIDOMFileList;
 typedef nsISupports nsIDOMFile;
 typedef nsISupports nsIControllers;
-typedef nsISupports nsIDOMValidityState;
 typedef nsISupports nsIPluginInstanceOwner;
 typedef nsISupports nsIPluginStreamListener;
 typedef nsISupports nsIContentSink;
@@ -929,6 +928,25 @@ interface nsIDOMMozNamedAttrMap : nsISupports
     nsresult RemoveNamedItemNS(const nsAString *namespaceURI, const nsAString *localName, nsIDOMAttr **_retval);
 }
 
+[
+    object,
+    uuid(00bed276-f1f7-492f-a039-dbd9b9efc10b),
+    local
+]
+interface nsIDOMValidityState : nsISupports
+{
+    nsresult GetValueMissing(bool *_retval);
+    nsresult GetTypeMismatch(bool *_retval);
+    nsresult GetPatternMismatch(bool *_retval);
+    nsresult GetTooLong(bool *_retval);
+    nsresult GetRangeUnderflow(bool *_retval);
+    nsresult GetRangeOverflow(bool *_retval);
+    nsresult GetStepMismatch(bool *_retval);
+    nsresult GetBadInput(bool *_retval);
+    nsresult GetCustomError(bool *_retval);
+    nsresult GetValid(bool *_retval);
+}
+
 [
     object,
     uuid(cc35b412-009b-46a3-9be0-76448f12548d),
@@ -4252,6 +4270,19 @@ interface nsIScriptObjectPrincipal : nsISupports
     nsIPrincipal* /* thiscall */ GetPrincipal();
 }
 
+[
+    object,
+    uuid(70b9600e-8622-4c93-9ad8-22c28058dc44),
+    local
+]
+interface nsIDOMParser : nsISupports
+{
+    nsresult ParseFromString(const char16_t *str, const char *contentType, nsIDOMDocument **_retval);
+    nsresult ParseFromBuffer(const uint8_t *buf, uint32_t bufLen, const char *aContentType, nsIDOMDocument **_retval);
+    nsresult ParseFromStream(nsIInputStream *stream, const char *charset, int32_t contentLength, const char *contentType, nsIDOMDocument **_retval);
+    nsresult Init(nsIPrincipal *principal, nsIURI *documentURI, nsIURI *baseURI, nsIGlobalObject *scriptObject);
+}
+
 [
     object,
     uuid(6f54214c-7175-498d-9d2d-0429e38c2869),
diff --git a/dlls/mshtml/nsio.c b/dlls/mshtml/nsio.c
index e0b8bedf79c..3f5658f6d72 100644
--- a/dlls/mshtml/nsio.c
+++ b/dlls/mshtml/nsio.c
@@ -275,6 +275,50 @@ static nsresult before_async_open(nsChannel *channel, GeckoBrowser *container, B
     return NS_OK;
 }
 
+static nsresult fire_before_navigate(nsChannel *channel, HTMLOuterWindow *window, BOOL *cancel)
+{
+    BSTR frame_name = NULL;
+    OLECHAR *new_url;
+    BSTR uri_str;
+    HRESULT hres;
+
+    hres = IUri_GetDisplayUri(channel->uri->uri, &uri_str);
+    if(FAILED(hres))
+    {
+        ERR("IUri_GetDisplayUri failed, hres %#x.\n", hres);
+        return NS_ERROR_FAILURE;
+    }
+    if(window->browser->doc->hostui)
+    {
+        hres = IDocHostUIHandler_TranslateUrl(window->browser->doc->hostui, 0, uri_str, &new_url);
+        if(hres == S_OK && new_url)
+        {
+            if(wcscmp(uri_str, new_url))
+            {
+                FIXME("TranslateUrl returned new URL %s -> %s.\n", debugstr_w(uri_str), debugstr_w(new_url));
+                CoTaskMemFree(new_url);
+                *cancel = TRUE;
+                SysFreeString(uri_str);
+                return NS_OK;
+            }
+            CoTaskMemFree(new_url);
+        }
+    }
+
+    hres = IHTMLWindow2_get_name(&window->base.IHTMLWindow2_iface, &frame_name);
+    if (FAILED(hres))
+    {
+        SysFreeString(uri_str);
+        return NS_ERROR_FAILURE;
+    }
+
+    hres = IDocObjectService_FireBeforeNavigate2(window->browser->doc->doc_object_service, NULL, uri_str, 0x40,
+            frame_name, NULL, 0, NULL, TRUE, cancel);
+    SysFreeString(frame_name);
+    SysFreeString(uri_str);
+    return SUCCEEDED(hres) ? NS_OK : NS_ERROR_FAILURE;
+}
+
 HRESULT load_nsuri(HTMLOuterWindow *window, nsWineURI *uri, nsIInputStream *post_stream,
         nsChannelBSC *channelbsc, DWORD flags)
 {
@@ -599,9 +643,9 @@ static nsresult NSAPI nsChannel_GetStatus(nsIHttpChannel *iface, nsresult *aStat
 {
     nsChannel *This = impl_from_nsIHttpChannel(iface);
 
-    WARN("(%p)->(%p) returning NS_OK\n", This, aStatus);
+    TRACE("(%p)->(%p) returning %#lx\n", This, aStatus, This->status);
 
-    return *aStatus = NS_OK;
+    return *aStatus = This->status;
 }
 
 static nsresult NSAPI nsChannel_Cancel(nsIHttpChannel *iface, nsresult aStatus)
@@ -610,6 +654,9 @@ static nsresult NSAPI nsChannel_Cancel(nsIHttpChannel *iface, nsresult aStatus)
 
     TRACE("(%p)->(%08lx)\n", This, aStatus);
 
+    if(NS_FAILED(aStatus))
+        This->status = aStatus;
+
     if(This->binding && This->binding->bsc.binding)
         IBinding_Abort(This->binding->bsc.binding);
     else
@@ -1077,6 +1124,27 @@ static nsresult NSAPI nsChannel_AsyncOpen(nsIHttpChannel *iface, nsIStreamListen
                 This->content_type = heap_strdupWtoA(window->browser->doc->mime);
             }
         }
+        else if (window->browser && window->frame_element && window->browser->doc
+                && window->browser->doc->doc_object_service)
+        {
+            IUnknown *unk;
+            if (SUCCEEDED(IHTMLFrameBase_QueryInterface(&window->frame_element->IHTMLFrameBase_iface,
+                    &IID_IHTMLIFrameElement, (void **)&unk)))
+            {
+                IUnknown_Release(unk);
+                nsres = fire_before_navigate(This, window, &cancel);
+                if(NS_SUCCEEDED(nsres) && cancel)
+                {
+                    TRACE("canceled.\n");
+                    nsres = NS_BINDING_ABORTED;
+                }
+                else
+                {
+                    FIXME("fire_before_navigate returned error %#x.\n", nsres);
+                    nsres = NS_OK;
+                }
+            }
+        }
     }
 
     if(!cancel)
diff --git a/dlls/mshtml/omnavigator.c b/dlls/mshtml/omnavigator.c
index 9962cc20dc7..08dd2a7451b 100644
--- a/dlls/mshtml/omnavigator.c
+++ b/dlls/mshtml/omnavigator.c
@@ -31,6 +31,45 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(mshtml);
 
+dispex_static_data_t *const dispex_from_document_type[DOCTYPE_COUNT] = {
+    [DOCTYPE_HTML]  = &HTMLDocumentNode_dispex,
+    [DOCTYPE_XHTML] = &XMLDocumentNode_dispex,
+    [DOCTYPE_XML]   = &XMLDocumentNode_dispex,
+    [DOCTYPE_SVG]   = &XMLDocumentNode_dispex,
+};
+
+const WCHAR *const content_type_from_document_type[DOCTYPE_COUNT] = {
+    [DOCTYPE_HTML]  = L"text/html",
+    [DOCTYPE_XHTML] = L"application/xhtml+xml",
+    [DOCTYPE_XML]   = L"text/xml",
+    [DOCTYPE_SVG]   = L"image/svg+xml",
+};
+
+static document_type_t document_type_from_content_type(const WCHAR *content_type)
+{
+    static const struct {
+        const WCHAR *content_type;
+        document_type_t doc_type;
+    } table[] = {
+        { L"application/xhtml+xml", DOCTYPE_XHTML },
+        { L"application/xml",       DOCTYPE_XML },
+        { L"image/svg+xml",         DOCTYPE_SVG },
+        { L"text/html",             DOCTYPE_HTML },
+        { L"text/xml",              DOCTYPE_XML },
+    };
+    unsigned int i, a = 0, b = ARRAY_SIZE(table);
+    int c;
+
+    while(a < b) {
+        i = (a + b) / 2;
+        c = wcsicmp(table[i].content_type, content_type);
+        if(!c) return table[i].doc_type;
+        if(c > 0) b = i;
+        else      a = i + 1;
+    }
+    return DOCTYPE_INVALID;
+}
+
 typedef struct HTMLPluginsCollection HTMLPluginsCollection;
 typedef struct HTMLMimeTypesCollection HTMLMimeTypesCollection;
 
@@ -40,6 +79,7 @@ typedef struct {
 
     LONG ref;
 
+    HTMLDocumentNode *doc;
     HTMLPluginsCollection *plugins;
     HTMLMimeTypesCollection *mime_types;
 } OmNavigator;
@@ -242,7 +282,6 @@ static HRESULT WINAPI HTMLDOMImplementation2_createHTMLDocument(IHTMLDOMImplemen
 {
     HTMLDOMImplementation *This = impl_from_IHTMLDOMImplementation2(iface);
     HTMLDocumentNode *new_document_node;
-    nsIDOMHTMLDocument *html_doc;
     nsIDOMDocument *doc;
     nsAString title_str;
     nsresult nsres;
@@ -261,12 +300,8 @@ static HRESULT WINAPI HTMLDOMImplementation2_createHTMLDocument(IHTMLDOMImplemen
         return E_FAIL;
     }
 
-    nsres = nsIDOMDocument_QueryInterface(doc, &IID_nsIDOMHTMLDocument, (void**)&html_doc);
+    hres = create_document_node(doc, This->browser, NULL, DOCTYPE_HTML, dispex_compat_mode(&This->dispex), &new_document_node);
     nsIDOMDocument_Release(doc);
-    assert(nsres == NS_OK);
-
-    hres = create_document_node(html_doc, This->browser, NULL, dispex_compat_mode(&This->dispex), &new_document_node);
-    nsIDOMHTMLDocument_Release(html_doc);
     if(FAILED(hres))
         return hres;
 
@@ -299,15 +334,23 @@ static const IHTMLDOMImplementation2Vtbl HTMLDOMImplementation2Vtbl = {
     HTMLDOMImplementation2_hasFeature
 };
 
+static void HTMLDOMImplementation_init_dispex_info(dispex_data_t *info, compat_mode_t compat_mode)
+{
+    if(compat_mode >= COMPAT_MODE_IE9)
+        dispex_info_add_interface(info, IHTMLDOMImplementation2_tid, NULL);
+}
+
 static const tid_t HTMLDOMImplementation_iface_tids[] = {
     IHTMLDOMImplementation_tid,
     0
 };
-static dispex_static_data_t HTMLDOMImplementation_dispex = {
+dispex_static_data_t HTMLDOMImplementation_dispex = {
     L"DOMImplementation",
     NULL,
+    PROTO_ID_HTMLDOMImplementation,
     DispHTMLDOMImplementation_tid,
-    HTMLDOMImplementation_iface_tids
+    HTMLDOMImplementation_iface_tids,
+    HTMLDOMImplementation_init_dispex_info
 };
 
 HRESULT create_dom_implementation(HTMLDocumentNode *doc_node, IHTMLDOMImplementation **ret)
@@ -328,9 +371,9 @@ HRESULT create_dom_implementation(HTMLDocumentNode *doc_node, IHTMLDOMImplementa
     dom_implementation->browser = doc_node->browser;
 
     init_dispatch(&dom_implementation->dispex, (IUnknown*)&dom_implementation->IHTMLDOMImplementation_iface,
-                  &HTMLDOMImplementation_dispex, doc_node->document_mode);
+                  &HTMLDOMImplementation_dispex, doc_node, doc_node->document_mode);
 
-    nsres = nsIDOMHTMLDocument_GetImplementation(doc_node->nsdoc, &dom_implementation->implementation);
+    nsres = nsIDOMDocument_GetImplementation(doc_node->nsdoc, &dom_implementation->implementation);
     if(NS_FAILED(nsres)) {
         ERR("GetDOMImplementation failed: %08lx\n", nsres);
         IHTMLDOMImplementation_Release(&dom_implementation->IHTMLDOMImplementation_iface);
@@ -347,6 +390,229 @@ void detach_dom_implementation(IHTMLDOMImplementation *iface)
     dom_implementation->browser = NULL;
 }
 
+struct dom_parser {
+    IDOMParser IDOMParser_iface;
+    DispatchEx dispex;
+    LONG ref;
+
+    HTMLDocumentNode *doc;
+};
+
+static inline struct dom_parser *impl_from_IDOMParser(IDOMParser *iface)
+{
+    return CONTAINING_RECORD(iface, struct dom_parser, IDOMParser_iface);
+}
+
+static HRESULT WINAPI DOMParser_QueryInterface(IDOMParser *iface, REFIID riid, void **ppv)
+{
+    struct dom_parser *This = impl_from_IDOMParser(iface);
+
+    TRACE("(%p)->(%s %p)\n", This, debugstr_mshtml_guid(riid), ppv);
+
+    if(IsEqualGUID(&IID_IUnknown, riid) || IsEqualGUID(&IID_IDOMParser, riid)) {
+        *ppv = &This->IDOMParser_iface;
+    }else if(dispex_query_interface(&This->dispex, riid, ppv)) {
+        return *ppv ? S_OK : E_NOINTERFACE;
+    }else {
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown*)*ppv);
+    return S_OK;
+}
+
+static ULONG WINAPI DOMParser_AddRef(IDOMParser *iface)
+{
+    struct dom_parser *This = impl_from_IDOMParser(iface);
+    LONG ref = InterlockedIncrement(&This->ref);
+
+    TRACE("(%p) ref=%ld\n", This, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI DOMParser_Release(IDOMParser *iface)
+{
+    struct dom_parser *This = impl_from_IDOMParser(iface);
+    LONG ref = InterlockedDecrement(&This->ref);
+
+    TRACE("(%p) ref=%ld\n", This, ref);
+
+    if(!ref) {
+        htmldoc_release(&This->doc->basedoc);
+        release_dispex(&This->dispex);
+        heap_free(This);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI DOMParser_GetTypeInfoCount(IDOMParser *iface, UINT *pctinfo)
+{
+    struct dom_parser *This = impl_from_IDOMParser(iface);
+
+    return IDispatchEx_GetTypeInfoCount(&This->dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI DOMParser_GetTypeInfo(IDOMParser *iface, UINT iTInfo,
+        LCID lcid, ITypeInfo **ppTInfo)
+{
+    struct dom_parser *This = impl_from_IDOMParser(iface);
+
+    return IDispatchEx_GetTypeInfo(&This->dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
+}
+
+static HRESULT WINAPI DOMParser_GetIDsOfNames(IDOMParser *iface, REFIID riid,
+        LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
+{
+    struct dom_parser *This = impl_from_IDOMParser(iface);
+
+    return IDispatchEx_GetIDsOfNames(&This->dispex.IDispatchEx_iface, riid, rgszNames, cNames,
+                                     lcid, rgDispId);
+}
+
+static HRESULT WINAPI DOMParser_Invoke(IDOMParser *iface, DISPID dispIdMember,
+        REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+        VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    struct dom_parser *This = impl_from_IDOMParser(iface);
+
+    return IDispatchEx_Invoke(&This->dispex.IDispatchEx_iface, dispIdMember, riid, lcid, wFlags,
+                              pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI DOMParser_parseFromString(IDOMParser *iface, BSTR string, BSTR mimeType, IHTMLDocument2 **ppNode)
+{
+    struct dom_parser *This = impl_from_IDOMParser(iface);
+    document_type_t doc_type;
+    IDispatch *disp;
+    HRESULT hres;
+
+    TRACE("(%p)->(%s %s %p)\n", This, debugstr_w(string), debugstr_w(mimeType), ppNode);
+
+    if(!string || !mimeType || (doc_type = document_type_from_content_type(mimeType)) == DOCTYPE_INVALID)
+        return E_INVALIDARG;
+
+    if(doc_type == DOCTYPE_HTML) {
+        IHTMLDOMImplementation *impl_iface;
+        HTMLDOMImplementation *impl;
+        IHTMLDocument7 *html_doc;
+        IHTMLElement *html_elem;
+        HTMLDocument *doc;
+
+        hres = IHTMLDocument5_get_implementation(&This->doc->basedoc.IHTMLDocument5_iface, &impl_iface);
+        if(FAILED(hres))
+            return hres;
+
+        impl = impl_from_IHTMLDOMImplementation(impl_iface);
+        hres = HTMLDOMImplementation2_createHTMLDocument(&impl->IHTMLDOMImplementation2_iface, NULL, &html_doc);
+        HTMLDOMImplementation_Release(impl_iface);
+        if(FAILED(hres))
+            return hres;
+        doc = CONTAINING_RECORD(html_doc, HTMLDocument, IHTMLDocument7_iface);
+
+        hres = IHTMLDocument3_get_documentElement(&doc->IHTMLDocument3_iface, &html_elem);
+        if(FAILED(hres)) {
+            IHTMLDocument7_Release(html_doc);
+            return hres;
+        }
+
+        hres = IHTMLElement_put_innerHTML(html_elem, string);
+        IHTMLElement_Release(html_elem);
+        if(FAILED(hres)) {
+            IHTMLDocument7_Release(html_doc);
+            return hres;
+        }
+
+        *ppNode = &doc->IHTMLDocument2_iface;
+        return hres;
+    }
+
+    hres = create_xml_document(string, This->doc, doc_type, TRUE, &disp);
+    if(FAILED(hres))
+        return hres;
+
+    hres = IDispatch_QueryInterface(disp, &IID_IHTMLDocument2, (void**)ppNode);
+    IDispatch_Release(disp);
+    return hres;
+}
+
+static const IDOMParserVtbl DOMParserVtbl = {
+    DOMParser_QueryInterface,
+    DOMParser_AddRef,
+    DOMParser_Release,
+    DOMParser_GetTypeInfoCount,
+    DOMParser_GetTypeInfo,
+    DOMParser_GetIDsOfNames,
+    DOMParser_Invoke,
+    DOMParser_parseFromString
+};
+
+static const tid_t DOMParser_iface_tids[] = {
+    IDOMParser_tid,
+    0
+};
+
+dispex_static_data_t DOMParser_dispex = {
+    L"DOMParser",
+    NULL,
+    PROTO_ID_DOMParser,
+    DispDOMParser_tid,
+    DOMParser_iface_tids
+};
+
+static HRESULT DOMParserCtor_value(DispatchEx *iface, LCID lcid, WORD flags, DISPPARAMS *params,
+        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+{
+    struct compat_ctor *This = CONTAINING_RECORD(iface, struct compat_ctor, dispex);
+    struct dom_parser *ret;
+
+    TRACE("\n");
+
+    switch(flags) {
+    case DISPATCH_METHOD|DISPATCH_PROPERTYGET:
+        if(!res)
+            return E_INVALIDARG;
+        /* fall through */
+    case DISPATCH_METHOD:
+    case DISPATCH_CONSTRUCT:
+        break;
+    default:
+        return compat_ctor_value(iface, lcid, flags, params, res, ei, caller);
+    }
+
+    if(!(ret = heap_alloc_zero(sizeof(*ret))))
+        return E_OUTOFMEMORY;
+
+    ret->IDOMParser_iface.lpVtbl = &DOMParserVtbl;
+    ret->ref = 1;
+    ret->doc = This->window->doc;
+    htmldoc_addref(&ret->doc->basedoc);
+
+    init_dispatch(&ret->dispex, (IUnknown*)&ret->IDOMParser_iface, &DOMParser_dispex,
+                  This->window->doc, dispex_compat_mode(&This->dispex));
+
+    V_VT(res) = VT_DISPATCH;
+    V_DISPATCH(res) = (IDispatch*)&ret->IDOMParser_iface;
+    return S_OK;
+}
+
+static const dispex_static_data_vtbl_t DOMParserCtor_dispex_vtbl = {
+    DOMParserCtor_value,
+    compat_ctor_get_dispid,
+    compat_ctor_invoke,
+    compat_ctor_delete
+};
+
+dispex_static_data_t DOMParserCtor_dispex = {
+    L"DOMParser",
+    &DOMParserCtor_dispex_vtbl,
+    PROTO_ID_NULL,
+    NULL_tid,
+    no_iface_tids
+};
+
 typedef struct {
     DispatchEx dispex;
     IHTMLScreen IHTMLScreen_iface;
@@ -555,14 +821,15 @@ static const tid_t HTMLScreen_iface_tids[] = {
     IHTMLScreen_tid,
     0
 };
-static dispex_static_data_t HTMLScreen_dispex = {
+dispex_static_data_t HTMLScreen_dispex = {
     L"Screen",
     NULL,
+    PROTO_ID_HTMLScreen,
     DispHTMLScreen_tid,
     HTMLScreen_iface_tids
 };
 
-HRESULT create_html_screen(compat_mode_t compat_mode, IHTMLScreen **ret)
+HRESULT create_html_screen(HTMLDocumentNode *doc_node, compat_mode_t compat_mode, IHTMLScreen **ret)
 {
     HTMLScreen *screen;
 
@@ -573,7 +840,7 @@ HRESULT create_html_screen(compat_mode_t compat_mode, IHTMLScreen **ret)
     screen->IHTMLScreen_iface.lpVtbl = &HTMLSreenVtbl;
     screen->ref = 1;
 
-    init_dispatch(&screen->dispex, (IUnknown*)&screen->IHTMLScreen_iface, &HTMLScreen_dispex, compat_mode);
+    init_dispatch(&screen->dispex, (IUnknown*)&screen->IHTMLScreen_iface, &HTMLScreen_dispex, doc_node, compat_mode);
 
     *ret = &screen->IHTMLScreen_iface;
     return S_OK;
@@ -719,9 +986,10 @@ static const tid_t OmHistory_iface_tids[] = {
     IOmHistory_tid,
     0
 };
-static dispex_static_data_t OmHistory_dispex = {
+dispex_static_data_t OmHistory_dispex = {
     L"History",
     NULL,
+    PROTO_ID_History,
     DispHTMLHistory_tid,
     OmHistory_iface_tids
 };
@@ -736,7 +1004,7 @@ HRESULT create_history(HTMLInnerWindow *window, OmHistory **ret)
         return E_OUTOFMEMORY;
 
     init_dispatch(&history->dispex, (IUnknown*)&history->IOmHistory_iface, &OmHistory_dispex,
-                  dispex_compat_mode(&window->event_target.dispex));
+                  window->doc, dispex_compat_mode(&window->event_target.dispex));
     history->IOmHistory_iface.lpVtbl = &OmHistoryVtbl;
     history->ref = 1;
 
@@ -876,9 +1144,10 @@ static const tid_t HTMLPluginsCollection_iface_tids[] = {
     IHTMLPluginsCollection_tid,
     0
 };
-static dispex_static_data_t HTMLPluginsCollection_dispex = {
+dispex_static_data_t HTMLPluginsCollection_dispex = {
     L"PluginArray",
     NULL,
+    PROTO_ID_HTMLPluginsCollection,
     DispCPlugins_tid,
     HTMLPluginsCollection_iface_tids
 };
@@ -896,7 +1165,7 @@ static HRESULT create_plugins_collection(OmNavigator *navigator, HTMLPluginsColl
     col->navigator = navigator;
 
     init_dispatch(&col->dispex, (IUnknown*)&col->IHTMLPluginsCollection_iface,
-                  &HTMLPluginsCollection_dispex, dispex_compat_mode(&navigator->dispex));
+                  &HTMLPluginsCollection_dispex, navigator->doc, dispex_compat_mode(&navigator->dispex));
 
     *ret = col;
     return S_OK;
@@ -1021,9 +1290,10 @@ static const tid_t HTMLMimeTypesCollection_iface_tids[] = {
     IHTMLMimeTypesCollection_tid,
     0
 };
-static dispex_static_data_t HTMLMimeTypesCollection_dispex = {
+dispex_static_data_t HTMLMimeTypesCollection_dispex = {
     L"MimeTypeArray",
     NULL,
+    PROTO_ID_HTMLMimeTypesCollection,
     IHTMLMimeTypesCollection_tid,
     HTMLMimeTypesCollection_iface_tids
 };
@@ -1041,7 +1311,7 @@ static HRESULT create_mime_types_collection(OmNavigator *navigator, HTMLMimeType
     col->navigator = navigator;
 
     init_dispatch(&col->dispex, (IUnknown*)&col->IHTMLMimeTypesCollection_iface,
-                  &HTMLMimeTypesCollection_dispex, dispex_compat_mode(&navigator->dispex));
+                  &HTMLMimeTypesCollection_dispex, navigator->doc, dispex_compat_mode(&navigator->dispex));
 
     *ret = col;
     return S_OK;
@@ -1096,6 +1366,7 @@ static ULONG WINAPI OmNavigator_Release(IOmNavigator *iface)
             This->plugins->navigator = NULL;
         if(This->mime_types)
             This->mime_types->navigator = NULL;
+        htmldoc_release(&This->doc->basedoc);
         release_dispex(&This->dispex);
         heap_free(This);
     }
@@ -1244,7 +1515,7 @@ static HRESULT WINAPI OmNavigator_javaEnabled(IOmNavigator *iface, VARIANT_BOOL
 
     FIXME("(%p)->(%p) semi-stub\n", This, enabled);
 
-    *enabled = VARIANT_TRUE;
+    *enabled = VARIANT_FALSE;
     return S_OK;
 }
 
@@ -1471,14 +1742,15 @@ static const tid_t OmNavigator_iface_tids[] = {
     IOmNavigator_tid,
     0
 };
-static dispex_static_data_t OmNavigator_dispex = {
+dispex_static_data_t OmNavigator_dispex = {
     L"Navigator",
     NULL,
+    PROTO_ID_Navigator,
     DispHTMLNavigator_tid,
     OmNavigator_iface_tids
 };
 
-HRESULT create_navigator(compat_mode_t compat_mode, IOmNavigator **navigator)
+HRESULT create_navigator(HTMLDocumentNode *doc_node, compat_mode_t compat_mode, IOmNavigator **navigator)
 {
     OmNavigator *ret;
 
@@ -1488,8 +1760,11 @@ HRESULT create_navigator(compat_mode_t compat_mode, IOmNavigator **navigator)
 
     ret->IOmNavigator_iface.lpVtbl = &OmNavigatorVtbl;
     ret->ref = 1;
+    ret->doc = doc_node;
+    if(doc_node)
+        htmldoc_addref(&doc_node->basedoc);
 
-    init_dispatch(&ret->dispex, (IUnknown*)&ret->IOmNavigator_iface, &OmNavigator_dispex, compat_mode);
+    init_dispatch(&ret->dispex, (IUnknown*)&ret->IOmNavigator_iface, &OmNavigator_dispex, doc_node, compat_mode);
 
     *navigator = &ret->IOmNavigator_iface;
     return S_OK;
@@ -1854,9 +2129,10 @@ static const tid_t HTMLPerformanceTiming_iface_tids[] = {
     IHTMLPerformanceTiming_tid,
     0
 };
-static dispex_static_data_t HTMLPerformanceTiming_dispex = {
+dispex_static_data_t HTMLPerformanceTiming_dispex = {
     L"PerformanceTiming",
     NULL,
+    PROTO_ID_HTMLPerformanceTiming,
     IHTMLPerformanceTiming_tid,
     HTMLPerformanceTiming_iface_tids
 };
@@ -2006,9 +2282,10 @@ static const tid_t HTMLPerformanceNavigation_iface_tids[] = {
     IHTMLPerformanceNavigation_tid,
     0
 };
-static dispex_static_data_t HTMLPerformanceNavigation_dispex = {
+dispex_static_data_t HTMLPerformanceNavigation_dispex = {
     L"PerformanceNavigation",
     NULL,
+    PROTO_ID_HTMLPerformanceNavigation,
     IHTMLPerformanceNavigation_tid,
     HTMLPerformanceNavigation_iface_tids
 };
@@ -2131,7 +2408,7 @@ static HRESULT WINAPI HTMLPerformance_get_navigation(IHTMLPerformance *iface,
         navigation->IHTMLPerformanceNavigation_iface.lpVtbl = &HTMLPerformanceNavigationVtbl;
         navigation->ref = 1;
         init_dispatch(&navigation->dispex, (IUnknown*)&navigation->IHTMLPerformanceNavigation_iface,
-                      &HTMLPerformanceNavigation_dispex, dispex_compat_mode(&This->dispex));
+                      &HTMLPerformanceNavigation_dispex, NULL, dispex_compat_mode(&This->dispex));
 
         This->navigation = &navigation->IHTMLPerformanceNavigation_iface;
     }
@@ -2156,7 +2433,7 @@ static HRESULT WINAPI HTMLPerformance_get_timing(IHTMLPerformance *iface, IHTMLP
         timing->IHTMLPerformanceTiming_iface.lpVtbl = &HTMLPerformanceTimingVtbl;
         timing->ref = 1;
         init_dispatch(&timing->dispex, (IUnknown*)&timing->IHTMLPerformanceTiming_iface,
-                      &HTMLPerformanceTiming_dispex, dispex_compat_mode(&This->dispex));
+                      &HTMLPerformanceTiming_dispex, NULL, dispex_compat_mode(&This->dispex));
 
         This->timing = &timing->IHTMLPerformanceTiming_iface;
     }
@@ -2199,9 +2476,10 @@ static const tid_t HTMLPerformance_iface_tids[] = {
     IHTMLPerformance_tid,
     0
 };
-static dispex_static_data_t HTMLPerformance_dispex = {
+dispex_static_data_t HTMLPerformance_dispex = {
     L"Performance",
     NULL,
+    PROTO_ID_HTMLPerformance,
     IHTMLPerformance_tid,
     HTMLPerformance_iface_tids
 };
@@ -2218,7 +2496,7 @@ HRESULT create_performance(compat_mode_t compat_mode, IHTMLPerformance **ret)
     performance->ref = 1;
 
     init_dispatch(&performance->dispex, (IUnknown*)&performance->IHTMLPerformance_iface,
-                  &HTMLPerformance_dispex, compat_mode);
+                  &HTMLPerformance_dispex, NULL, compat_mode);
 
     *ret = &performance->IHTMLPerformance_iface;
     return S_OK;
@@ -2358,14 +2636,15 @@ static const tid_t HTMLNamespaceCollection_iface_tids[] = {
     IHTMLNamespaceCollection_tid,
     0
 };
-static dispex_static_data_t HTMLNamespaceCollection_dispex = {
+dispex_static_data_t HTMLNamespaceCollection_dispex = {
     L"MSNamespaceInfoCollection",
     NULL,
+    PROTO_ID_HTMLNamespaceCollection,
     DispHTMLNamespaceCollection_tid,
     HTMLNamespaceCollection_iface_tids
 };
 
-HRESULT create_namespace_collection(compat_mode_t compat_mode, IHTMLNamespaceCollection **ret)
+HRESULT create_namespace_collection(HTMLDocumentNode *doc_node, IHTMLNamespaceCollection **ret)
 {
     HTMLNamespaceCollection *namespaces;
 
@@ -2375,7 +2654,7 @@ HRESULT create_namespace_collection(compat_mode_t compat_mode, IHTMLNamespaceCol
     namespaces->IHTMLNamespaceCollection_iface.lpVtbl = &HTMLNamespaceCollectionVtbl;
     namespaces->ref = 1;
     init_dispatch(&namespaces->dispex, (IUnknown*)&namespaces->IHTMLNamespaceCollection_iface,
-                  &HTMLNamespaceCollection_dispex, compat_mode);
+                  &HTMLNamespaceCollection_dispex, doc_node, dispex_compat_mode(&doc_node->node.event_target.dispex));
     *ret = &namespaces->IHTMLNamespaceCollection_iface;
     return S_OK;
 }
@@ -2614,9 +2893,10 @@ static const tid_t console_iface_tids[] = {
     IWineMSHTMLConsole_tid,
     0
 };
-static dispex_static_data_t console_dispex = {
+dispex_static_data_t console_dispex = {
     L"Console",
     NULL,
+    PROTO_ID_Console,
     IWineMSHTMLConsole_tid,
     console_iface_tids
 };
@@ -2634,7 +2914,433 @@ void create_console(compat_mode_t compat_mode, IWineMSHTMLConsole **ret)
 
     obj->IWineMSHTMLConsole_iface.lpVtbl = &WineMSHTMLConsoleVtbl;
     obj->ref = 1;
-    init_dispatch(&obj->dispex, (IUnknown*)&obj->IWineMSHTMLConsole_iface, &console_dispex, compat_mode);
+    init_dispatch(&obj->dispex, (IUnknown*)&obj->IWineMSHTMLConsole_iface, &console_dispex, NULL, compat_mode);
 
     *ret = &obj->IWineMSHTMLConsole_iface;
 }
+
+struct crypto_subtle {
+    DispatchEx dispex;
+    IWineMSHTMLSubtleCrypto IWineMSHTMLSubtleCrypto_iface;
+    LONG ref;
+};
+
+static inline struct crypto_subtle *impl_from_IWineMSHTMLSubtleCrypto(IWineMSHTMLSubtleCrypto *iface)
+{
+    return CONTAINING_RECORD(iface, struct crypto_subtle, IWineMSHTMLSubtleCrypto_iface);
+}
+
+static HRESULT WINAPI crypto_subtle_QueryInterface(IWineMSHTMLSubtleCrypto *iface, REFIID riid, void **ppv)
+{
+    struct crypto_subtle *subtle = impl_from_IWineMSHTMLSubtleCrypto(iface);
+
+    TRACE("(%p)->(%s %p)\n", subtle, debugstr_mshtml_guid(riid), ppv);
+
+    if(IsEqualGUID(&IID_IUnknown, riid)) {
+        *ppv = &subtle->IWineMSHTMLSubtleCrypto_iface;
+    }else if(IsEqualGUID(&IID_IWineMSHTMLSubtleCrypto, riid)) {
+        *ppv = &subtle->IWineMSHTMLSubtleCrypto_iface;
+    }else if(dispex_query_interface(&subtle->dispex, riid, ppv)) {
+        return *ppv ? S_OK : E_NOINTERFACE;
+    }else {
+        WARN("(%p)->(%s %p)\n", subtle, debugstr_mshtml_guid(riid), ppv);
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown*)*ppv);
+    return S_OK;
+}
+
+static ULONG WINAPI crypto_subtle_AddRef(IWineMSHTMLSubtleCrypto *iface)
+{
+    struct crypto_subtle *subtle = impl_from_IWineMSHTMLSubtleCrypto(iface);
+    LONG ref = InterlockedIncrement(&subtle->ref);
+
+    TRACE("(%p) ref=%ld\n", subtle, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI crypto_subtle_Release(IWineMSHTMLSubtleCrypto *iface)
+{
+    struct crypto_subtle *subtle = impl_from_IWineMSHTMLSubtleCrypto(iface);
+    LONG ref = InterlockedDecrement(&subtle->ref);
+
+    TRACE("(%p) ref=%ld\n", subtle, ref);
+
+    if(!ref) {
+        release_dispex(&subtle->dispex);
+        heap_free(subtle);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI crypto_subtle_GetTypeInfoCount(IWineMSHTMLSubtleCrypto *iface, UINT *pctinfo)
+{
+    struct crypto_subtle *subtle = impl_from_IWineMSHTMLSubtleCrypto(iface);
+
+    TRACE("(%p)->(%p)\n", subtle, pctinfo);
+
+    return IDispatchEx_GetTypeInfoCount(&subtle->dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI crypto_subtle_GetTypeInfo(IWineMSHTMLSubtleCrypto *iface, UINT iTInfo,
+        LCID lcid, ITypeInfo **ppTInfo)
+{
+    struct crypto_subtle *subtle = impl_from_IWineMSHTMLSubtleCrypto(iface);
+
+    return IDispatchEx_GetTypeInfo(&subtle->dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
+}
+
+static HRESULT WINAPI crypto_subtle_GetIDsOfNames(IWineMSHTMLSubtleCrypto *iface, REFIID riid,
+        LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
+{
+    struct crypto_subtle *subtle = impl_from_IWineMSHTMLSubtleCrypto(iface);
+
+    return IDispatchEx_GetIDsOfNames(&subtle->dispex.IDispatchEx_iface, riid, rgszNames, cNames,
+            lcid, rgDispId);
+}
+
+static HRESULT WINAPI crypto_subtle_Invoke(IWineMSHTMLSubtleCrypto *iface, DISPID dispIdMember,
+        REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+        VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    struct crypto_subtle *subtle = impl_from_IWineMSHTMLSubtleCrypto(iface);
+
+    return IDispatchEx_Invoke(&subtle->dispex.IDispatchEx_iface, dispIdMember, riid, lcid, wFlags,
+            pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI crypto_subtle_encrypt(IWineMSHTMLSubtleCrypto *iface, VARIANT *algorithm, VARIANT *key,
+        VARIANT *data, IDispatch **result)
+{
+    struct crypto_subtle *subtle = impl_from_IWineMSHTMLSubtleCrypto(iface);
+
+    FIXME("(%p)->(%p %p %p %p)\n", subtle, algorithm, key, data, result);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI crypto_subtle_decrypt(IWineMSHTMLSubtleCrypto *iface, VARIANT *algorithm, VARIANT *key,
+        VARIANT *data, IDispatch **result)
+{
+    struct crypto_subtle *subtle = impl_from_IWineMSHTMLSubtleCrypto(iface);
+
+    FIXME("(%p)->(%p %p %p %p)\n", subtle, algorithm, key, data, result);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI crypto_subtle_sign(IWineMSHTMLSubtleCrypto *iface, VARIANT *algorithm, VARIANT *key,
+        VARIANT *data, IDispatch **signature)
+{
+    struct crypto_subtle *subtle = impl_from_IWineMSHTMLSubtleCrypto(iface);
+
+    FIXME("(%p)->(%p %p %p %p)\n", subtle, algorithm, key, data, signature);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI crypto_subtle_verify(IWineMSHTMLSubtleCrypto *iface, VARIANT *algorithm, VARIANT *key,
+        VARIANT *signature, VARIANT *data, IDispatch **result)
+{
+    struct crypto_subtle *subtle = impl_from_IWineMSHTMLSubtleCrypto(iface);
+
+    FIXME("(%p)->(%p %p %p %p %p)\n", subtle, algorithm, key, signature, data, result);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI crypto_subtle_digest(IWineMSHTMLSubtleCrypto *iface, VARIANT *algorithm, VARIANT *data,
+        IDispatch **digest)
+{
+    struct crypto_subtle *subtle = impl_from_IWineMSHTMLSubtleCrypto(iface);
+
+    FIXME("(%p)->(%p %p %p)\n", subtle, algorithm, data, digest);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI crypto_subtle_generateKey(IWineMSHTMLSubtleCrypto *iface, VARIANT *algorithm,
+        VARIANT_BOOL extractable, VARIANT *keyUsages, IDispatch **result)
+{
+    struct crypto_subtle *subtle = impl_from_IWineMSHTMLSubtleCrypto(iface);
+
+    FIXME("(%p)->(%p %x %p %p)\n", subtle, algorithm, extractable, keyUsages, result);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI crypto_subtle_deriveKey(IWineMSHTMLSubtleCrypto *iface, VARIANT *algorithm, VARIANT *baseKey,
+        VARIANT *derivedKeyAlgorithm, VARIANT_BOOL extractable, VARIANT *keyUsages, IDispatch **result)
+{
+    struct crypto_subtle *subtle = impl_from_IWineMSHTMLSubtleCrypto(iface);
+
+    FIXME("(%p)->(%p %p %p %x %p %p)\n", subtle, algorithm, baseKey, derivedKeyAlgorithm, extractable,
+          keyUsages, result);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI crypto_subtle_importKey(IWineMSHTMLSubtleCrypto *iface, BSTR format, VARIANT *keyData,
+        VARIANT *algorithm, VARIANT_BOOL extractable, VARIANT *keyUsages, IDispatch **result)
+{
+    struct crypto_subtle *subtle = impl_from_IWineMSHTMLSubtleCrypto(iface);
+
+    FIXME("(%p)->(%s %p %p %x %p %p)\n", subtle, debugstr_w(format), keyData, algorithm, extractable,
+          keyUsages, result);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI crypto_subtle_exportKey(IWineMSHTMLSubtleCrypto *iface, BSTR format, VARIANT *key,
+        IDispatch **result)
+{
+    struct crypto_subtle *subtle = impl_from_IWineMSHTMLSubtleCrypto(iface);
+
+    FIXME("(%p)->(%s %p %p)\n", subtle, debugstr_w(format), key, result);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI crypto_subtle_wrapKey(IWineMSHTMLSubtleCrypto *iface, BSTR format, VARIANT *key,
+        VARIANT *wrappingKey, VARIANT *wrapAlgo, IDispatch **result)
+{
+    struct crypto_subtle *subtle = impl_from_IWineMSHTMLSubtleCrypto(iface);
+
+    FIXME("(%p)->(%s %p %p %p %p)\n", subtle, debugstr_w(format), key, wrappingKey, wrapAlgo, result);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI crypto_subtle_unwrapKey(IWineMSHTMLSubtleCrypto *iface, BSTR format, VARIANT *wrappedKey,
+        VARIANT *unwrappingKey, VARIANT *unwrapAlgo, VARIANT *unwrappedKeyAlgo, VARIANT_BOOL extractable,
+        VARIANT *keyUsages, IDispatch **result)
+{
+    struct crypto_subtle *subtle = impl_from_IWineMSHTMLSubtleCrypto(iface);
+
+    FIXME("(%p)->(%s %p %p %p %p %x %p %p)\n", subtle, debugstr_w(format), wrappedKey, unwrappingKey, unwrapAlgo,
+          unwrappedKeyAlgo, extractable, keyUsages, result);
+
+    return E_NOTIMPL;
+}
+
+static const IWineMSHTMLSubtleCryptoVtbl WineMSHTMLSubtleCryptoVtbl = {
+    crypto_subtle_QueryInterface,
+    crypto_subtle_AddRef,
+    crypto_subtle_Release,
+    crypto_subtle_GetTypeInfoCount,
+    crypto_subtle_GetTypeInfo,
+    crypto_subtle_GetIDsOfNames,
+    crypto_subtle_Invoke,
+    crypto_subtle_encrypt,
+    crypto_subtle_decrypt,
+    crypto_subtle_sign,
+    crypto_subtle_verify,
+    crypto_subtle_digest,
+    crypto_subtle_generateKey,
+    crypto_subtle_deriveKey,
+    crypto_subtle_importKey,
+    crypto_subtle_exportKey,
+    crypto_subtle_wrapKey,
+    crypto_subtle_unwrapKey
+};
+
+static const tid_t crypto_subtle_iface_tids[] = {
+    IWineMSHTMLSubtleCrypto_tid,
+    0
+};
+dispex_static_data_t crypto_subtle_dispex = {
+    L"SubtleCrypto",
+    NULL,
+    PROTO_ID_SubtleCrypto,
+    IWineMSHTMLSubtleCrypto_tid,
+    crypto_subtle_iface_tids
+};
+
+struct crypto {
+    DispatchEx dispex;
+    IWineMSHTMLCrypto IWineMSHTMLCrypto_iface;
+    struct crypto_subtle *subtle;
+    LONG ref;
+};
+
+static inline struct crypto *impl_from_IWineMSHTMLCrypto(IWineMSHTMLCrypto *iface)
+{
+    return CONTAINING_RECORD(iface, struct crypto, IWineMSHTMLCrypto_iface);
+}
+
+static HRESULT WINAPI crypto_QueryInterface(IWineMSHTMLCrypto *iface, REFIID riid, void **ppv)
+{
+    struct crypto *crypto = impl_from_IWineMSHTMLCrypto(iface);
+
+    TRACE("(%p)->(%s %p)\n", crypto, debugstr_mshtml_guid(riid), ppv);
+
+    if(IsEqualGUID(&IID_IUnknown, riid)) {
+        *ppv = &crypto->IWineMSHTMLCrypto_iface;
+    }else if(IsEqualGUID(&IID_IWineMSHTMLCrypto, riid)) {
+        *ppv = &crypto->IWineMSHTMLCrypto_iface;
+    }else if(dispex_query_interface(&crypto->dispex, riid, ppv)) {
+        return *ppv ? S_OK : E_NOINTERFACE;
+    }else {
+        WARN("(%p)->(%s %p)\n", crypto, debugstr_mshtml_guid(riid), ppv);
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown*)*ppv);
+    return S_OK;
+}
+
+static ULONG WINAPI crypto_AddRef(IWineMSHTMLCrypto *iface)
+{
+    struct crypto *crypto = impl_from_IWineMSHTMLCrypto(iface);
+    LONG ref = InterlockedIncrement(&crypto->ref);
+
+    TRACE("(%p) ref=%ld\n", crypto, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI crypto_Release(IWineMSHTMLCrypto *iface)
+{
+    struct crypto *crypto = impl_from_IWineMSHTMLCrypto(iface);
+    LONG ref = InterlockedDecrement(&crypto->ref);
+
+    TRACE("(%p) ref=%ld\n", crypto, ref);
+
+    if(!ref) {
+        if(crypto->subtle)
+            IWineMSHTMLSubtleCrypto_Release(&crypto->subtle->IWineMSHTMLSubtleCrypto_iface);
+        release_dispex(&crypto->dispex);
+        heap_free(crypto);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI crypto_GetTypeInfoCount(IWineMSHTMLCrypto *iface, UINT *pctinfo)
+{
+    struct crypto *crypto = impl_from_IWineMSHTMLCrypto(iface);
+
+    TRACE("(%p)->(%p)\n", crypto, pctinfo);
+
+    return IDispatchEx_GetTypeInfoCount(&crypto->dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI crypto_GetTypeInfo(IWineMSHTMLCrypto *iface, UINT iTInfo,
+        LCID lcid, ITypeInfo **ppTInfo)
+{
+    struct crypto *crypto = impl_from_IWineMSHTMLCrypto(iface);
+
+    return IDispatchEx_GetTypeInfo(&crypto->dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
+}
+
+static HRESULT WINAPI crypto_GetIDsOfNames(IWineMSHTMLCrypto *iface, REFIID riid,
+        LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
+{
+    struct crypto *crypto = impl_from_IWineMSHTMLCrypto(iface);
+
+    return IDispatchEx_GetIDsOfNames(&crypto->dispex.IDispatchEx_iface, riid, rgszNames, cNames,
+            lcid, rgDispId);
+}
+
+static HRESULT WINAPI crypto_Invoke(IWineMSHTMLCrypto *iface, DISPID dispIdMember,
+        REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+        VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    struct crypto *crypto = impl_from_IWineMSHTMLCrypto(iface);
+
+    return IDispatchEx_Invoke(&crypto->dispex.IDispatchEx_iface, dispIdMember, riid, lcid, wFlags,
+            pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI crypto_get_subtle(IWineMSHTMLCrypto *iface, IDispatch **subtle)
+{
+    struct crypto *crypto = impl_from_IWineMSHTMLCrypto(iface);
+    struct crypto_subtle *obj;
+
+    TRACE("(%p)->(%p)\n", crypto, subtle);
+
+    if(!crypto->subtle) {
+        if(!(obj = heap_alloc_zero(sizeof(*obj))))
+            return E_OUTOFMEMORY;
+
+        obj->IWineMSHTMLSubtleCrypto_iface.lpVtbl = &WineMSHTMLSubtleCryptoVtbl;
+        obj->ref = 1;
+        init_dispatch(&obj->dispex, (IUnknown*)&obj->IWineMSHTMLSubtleCrypto_iface, &crypto_subtle_dispex,
+                      NULL, dispex_compat_mode(&crypto->dispex));
+        crypto->subtle = obj;
+    }
+
+    *subtle = (IDispatch*)crypto->subtle;
+    if(crypto->subtle)
+        IWineMSHTMLSubtleCrypto_AddRef(&crypto->subtle->IWineMSHTMLSubtleCrypto_iface);
+    return S_OK;
+}
+
+static HRESULT WINAPI crypto_getRandomValues(IWineMSHTMLCrypto *iface, VARIANT *typedArray, IDispatch **ret)
+{
+    struct crypto *crypto = impl_from_IWineMSHTMLCrypto(iface);
+    IWineDispatchProxyCbPrivate *proxy;
+    HRESULT hres;
+
+    TRACE("(%p)->(%p %p)\n", crypto, typedArray, ret);
+
+    if(V_VT(typedArray) != VT_DISPATCH || !V_DISPATCH(typedArray))
+        return E_INVALIDARG;
+
+    if(!(proxy = crypto->dispex.proxy)) {
+        FIXME("No proxy\n");
+        return E_NOTIMPL;
+    }
+
+    hres = proxy->lpVtbl->GetRandomValues(V_DISPATCH(typedArray));
+    if(SUCCEEDED(hres) && ret) {
+        *ret = V_DISPATCH(typedArray);
+        IDispatch_AddRef(*ret);
+    }
+    return hres;
+}
+
+static const IWineMSHTMLCryptoVtbl WineMSHTMLCryptoVtbl = {
+    crypto_QueryInterface,
+    crypto_AddRef,
+    crypto_Release,
+    crypto_GetTypeInfoCount,
+    crypto_GetTypeInfo,
+    crypto_GetIDsOfNames,
+    crypto_Invoke,
+    crypto_get_subtle,
+    crypto_getRandomValues
+};
+
+static const tid_t crypto_iface_tids[] = {
+    IWineMSHTMLCrypto_tid,
+    0
+};
+dispex_static_data_t crypto_dispex = {
+    L"Crypto",
+    NULL,
+    PROTO_ID_Crypto,
+    IWineMSHTMLCrypto_tid,
+    crypto_iface_tids
+};
+
+void create_crypto(compat_mode_t compat_mode, IWineMSHTMLCrypto **ret)
+{
+    struct crypto *obj;
+
+    if(!(obj = heap_alloc_zero(sizeof(*obj)))) {
+        ERR("No memory.\n");
+        return;
+    }
+
+    obj->IWineMSHTMLCrypto_iface.lpVtbl = &WineMSHTMLCryptoVtbl;
+    obj->ref = 1;
+    init_dispatch(&obj->dispex, (IUnknown*)&obj->IWineMSHTMLCrypto_iface, &crypto_dispex, NULL, compat_mode);
+
+    *ret = &obj->IWineMSHTMLCrypto_iface;
+}
diff --git a/dlls/mshtml/persist.c b/dlls/mshtml/persist.c
index 73f255e753d..f395a926293 100644
--- a/dlls/mshtml/persist.c
+++ b/dlls/mshtml/persist.c
@@ -510,7 +510,7 @@ static HRESULT get_doc_string(HTMLDocumentNode *This, char **str)
         return E_UNEXPECTED;
     }
 
-    nsres = nsIDOMHTMLDocument_QueryInterface(This->nsdoc, &IID_nsIDOMNode, (void**)&nsnode);
+    nsres = nsIDOMDocument_QueryInterface(This->nsdoc, &IID_nsIDOMNode, (void**)&nsnode);
     if(NS_FAILED(nsres)) {
         ERR("Could not get nsIDOMNode failed: %08lx\n", nsres);
         return E_FAIL;
diff --git a/dlls/mshtml/range.c b/dlls/mshtml/range.c
index 59d1a59b0b0..67912a01a08 100644
--- a/dlls/mshtml/range.c
+++ b/dlls/mshtml/range.c
@@ -949,7 +949,7 @@ static HRESULT WINAPI HTMLTxtRange_put_text(IHTMLTxtRange *iface, BSTR v)
         return MSHTML_E_NODOC;
 
     nsAString_InitDepend(&text_str, v);
-    nsres = nsIDOMHTMLDocument_CreateTextNode(This->doc->nsdoc, &text_str, &text_node);
+    nsres = nsIDOMDocument_CreateTextNode(This->doc->nsdoc, &text_str, &text_node);
     nsAString_Finish(&text_str);
     if(NS_FAILED(nsres)) {
         ERR("CreateTextNode failed: %08lx\n", nsres);
@@ -1159,7 +1159,12 @@ static HRESULT WINAPI HTMLTxtRange_expand(IHTMLTxtRange *iface, BSTR Unit, VARIA
         nsIDOMHTMLElement *nsbody = NULL;
         nsresult nsres;
 
-        nsres = nsIDOMHTMLDocument_GetBody(This->doc->nsdoc, &nsbody);
+        if(!This->doc->nshtmldoc) {
+            FIXME("Not implemented for XML document\n");
+            return E_NOTIMPL;
+        }
+
+        nsres = nsIDOMHTMLDocument_GetBody(This->doc->nshtmldoc, &nsbody);
         if(NS_FAILED(nsres) || !nsbody) {
             ERR("Could not get body: %08lx\n", nsres);
             break;
@@ -1714,9 +1719,10 @@ static const tid_t HTMLTxtRange_iface_tids[] = {
     IHTMLTxtRange_tid,
     0
 };
-static dispex_static_data_t HTMLTxtRange_dispex = {
+dispex_static_data_t HTMLTxtRange_dispex = {
     L"TextRange",
     NULL,
+    PROTO_ID_HTMLTextRange,
     IHTMLTxtRange_tid,
     HTMLTxtRange_iface_tids
 };
@@ -1730,7 +1736,7 @@ HRESULT HTMLTxtRange_Create(HTMLDocumentNode *doc, nsIDOMRange *nsrange, IHTMLTx
         return E_OUTOFMEMORY;
 
     init_dispatch(&ret->dispex, (IUnknown*)&ret->IHTMLTxtRange_iface, &HTMLTxtRange_dispex,
-                                 dispex_compat_mode(&doc->node.event_target.dispex));
+                                 doc, dispex_compat_mode(&doc->node.event_target.dispex));
 
     ret->IHTMLTxtRange_iface.lpVtbl = &HTMLTxtRangeVtbl;
     ret->IOleCommandTarget_iface.lpVtbl = &OleCommandTargetVtbl;
@@ -2060,9 +2066,10 @@ static const tid_t HTMLDOMRange_iface_tids[] = {
     0
 };
 
-static dispex_static_data_t HTMLDOMRange_dispex = {
+dispex_static_data_t HTMLDOMRange_dispex = {
     L"Range",
     NULL,
+    PROTO_ID_HTMLDOMRange,
     DispHTMLDOMRange_tid,
     HTMLDOMRange_iface_tids
 };
@@ -2075,7 +2082,7 @@ HRESULT create_dom_range(nsIDOMRange *nsrange, compat_mode_t compat_mode, IHTMLD
     if(!ret)
         return E_OUTOFMEMORY;
 
-    init_dispatch(&ret->dispex, (IUnknown*)&ret->IHTMLDOMRange_iface, &HTMLDOMRange_dispex, compat_mode);
+    init_dispatch(&ret->dispex, (IUnknown*)&ret->IHTMLDOMRange_iface, &HTMLDOMRange_dispex, NULL, compat_mode);
 
     ret->IHTMLDOMRange_iface.lpVtbl = &HTMLDOMRangeVtbl;
     ret->ref = 1;
diff --git a/dlls/mshtml/script.c b/dlls/mshtml/script.c
index e49449a61f8..39ee78d4f12 100644
--- a/dlls/mshtml/script.c
+++ b/dlls/mshtml/script.c
@@ -186,6 +186,18 @@ static BOOL init_script_engine(ScriptHost *script_host)
         return FALSE;
     }
 
+    if(script_mode & SCRIPTLANGUAGEVERSION_HTML) {
+        IWineDispatchProxyCbPrivate *proxy = script_host->window->event_target.dispex.proxy;
+        if(proxy) {
+            hres = proxy->lpVtbl->HostUpdated(proxy, script_host->script);
+            if(FAILED(hres)) {
+                WARN("Proxy->HostUpdated failed: %08lx\n", hres);
+                IActiveScript_Close(script_host->script);
+                return FALSE;
+            }
+        }
+    }
+
     hres = IActiveScript_GetScriptState(script_host->script, &state);
     if(FAILED(hres))
         WARN("GetScriptState failed: %08lx\n", hres);
@@ -1600,7 +1612,7 @@ void bind_event_scripts(HTMLDocumentNode *doc)
         return;
 
     nsAString_InitDepend(&selector_str, L"script[event]");
-    nsres = nsIDOMHTMLDocument_QuerySelectorAll(doc->nsdoc, &selector_str, &node_list);
+    nsres = nsIDOMDocument_QuerySelectorAll(doc->nsdoc, &selector_str, &node_list);
     nsAString_Finish(&selector_str);
     if(NS_FAILED(nsres)) {
         ERR("QuerySelectorAll failed: %08lx\n", nsres);
@@ -1668,7 +1680,12 @@ BOOL find_global_prop(HTMLInnerWindow *window, BSTR name, DWORD flags, ScriptHos
 
         hres = IDispatch_QueryInterface(disp, &IID_IDispatchEx, (void**)&dispex);
         if(SUCCEEDED(hres)) {
-            hres = IDispatchEx_GetDispID(dispex, name, flags & (~fdexNameEnsure), ret_id);
+            /* Avoid looking into ourselves if it's a proxy used as actual global object */
+            if(dispex == &window->base.IDispatchEx_iface ||
+               dispex == &window->base.outer_window->base.IDispatchEx_iface)
+                hres = DISP_E_UNKNOWNNAME;
+            else
+                hres = IDispatchEx_GetDispID(dispex, name, flags & (~fdexNameEnsure), ret_id);
             IDispatchEx_Release(dispex);
         }else {
             FIXME("No IDispatchEx\n");
diff --git a/dlls/mshtml/selection.c b/dlls/mshtml/selection.c
index 307b7c922a0..fc89a687188 100644
--- a/dlls/mshtml/selection.c
+++ b/dlls/mshtml/selection.c
@@ -165,7 +165,12 @@ static HRESULT WINAPI HTMLSelectionObject_createRange(IHTMLSelectionObject *ifac
                 return E_UNEXPECTED;
             }
 
-            nsres = nsIDOMHTMLDocument_GetBody(This->doc->nsdoc, &nsbody);
+            if(!This->doc->nshtmldoc) {
+                FIXME("Not implemented for XML document\n");
+                return E_NOTIMPL;
+            }
+
+            nsres = nsIDOMHTMLDocument_GetBody(This->doc->nshtmldoc, &nsbody);
             if(NS_FAILED(nsres) || !nsbody) {
                 ERR("Could not get body: %08lx\n", nsres);
                 return E_FAIL;
@@ -329,9 +334,10 @@ static const tid_t HTMLSelectionObject_iface_tids[] = {
     IHTMLSelectionObject2_tid,
     0
 };
-static dispex_static_data_t HTMLSelectionObject_dispex = {
+dispex_static_data_t HTMLSelectionObject_dispex = {
     L"MSSelection",
     NULL,
+    PROTO_ID_HTMLSelectionObject,
     IHTMLSelectionObject_tid, /* FIXME: We have a test for that, but it doesn't expose IHTMLSelectionObject2 iface. */
     HTMLSelectionObject_iface_tids
 };
@@ -345,7 +351,7 @@ HRESULT HTMLSelectionObject_Create(HTMLDocumentNode *doc, nsISelection *nsselect
         return E_OUTOFMEMORY;
 
     init_dispatch(&selection->dispex, (IUnknown*)&selection->IHTMLSelectionObject_iface,
-                  &HTMLSelectionObject_dispex, dispex_compat_mode(&doc->node.event_target.dispex));
+                  &HTMLSelectionObject_dispex, doc, dispex_compat_mode(&doc->node.event_target.dispex));
 
     selection->IHTMLSelectionObject_iface.lpVtbl = &HTMLSelectionObjectVtbl;
     selection->IHTMLSelectionObject2_iface.lpVtbl = &HTMLSelectionObject2Vtbl;
diff --git a/dlls/mshtml/task.c b/dlls/mshtml/task.c
index 088742e902a..817af9382a8 100644
--- a/dlls/mshtml/task.c
+++ b/dlls/mshtml/task.c
@@ -33,6 +33,7 @@
 WINE_DEFAULT_DEBUG_CHANNEL(mshtml);
 
 #define WM_PROCESSTASK 0x8008
+#define WM_CREATEDOC   0x8018
 #define TIMER_ID 0x3000
 
 typedef struct {
@@ -208,7 +209,8 @@ HRESULT clear_task_timer(HTMLInnerWindow *window, DWORD id)
 
     LIST_FOR_EACH_ENTRY(iter, &thread_data->timer_list, task_timer_t, entry) {
         if(iter->id == id && iter->window == window) {
-            release_task_timer(thread_data->thread_hwnd, iter);
+            if(iter->type != TIMER_ANIMATION_FRAME)
+                release_task_timer(thread_data->thread_hwnd, iter);
             return S_OK;
         }
     }
@@ -217,6 +219,26 @@ HRESULT clear_task_timer(HTMLInnerWindow *window, DWORD id)
     return S_OK;
 }
 
+HRESULT clear_animation_timer(HTMLInnerWindow *window, DWORD id)
+{
+    thread_data_t *thread_data = get_thread_data(FALSE);
+    task_timer_t *iter;
+
+    if(!thread_data)
+        return S_OK;
+
+    LIST_FOR_EACH_ENTRY(iter, &thread_data->timer_list, task_timer_t, entry) {
+        if(iter->id == id && iter->window == window) {
+            if(iter->type == TIMER_ANIMATION_FRAME)
+                release_task_timer(thread_data->thread_hwnd, iter);
+            return S_OK;
+        }
+    }
+
+    WARN("timer not found\n");
+    return S_OK;
+}
+
 static const char *debugstr_timer_type(enum timer_type type)
 {
     switch(type) {
@@ -309,6 +331,13 @@ static LRESULT process_timer(void)
     return 0;
 }
 
+typedef struct {
+    IUnknown *unk;
+    IID iid;
+    IStream *stream;
+    HRESULT hres;
+} create_doc_params_t;
+
 static LRESULT WINAPI hidden_proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 {
     switch(msg) {
@@ -325,6 +354,20 @@ static LRESULT WINAPI hidden_proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lPa
         return 0;
     case WM_TIMER:
         return process_timer();
+    case WM_CREATEDOC: {
+        create_doc_params_t *params = (create_doc_params_t*)lParam;
+        IUnknown *unk;
+
+        TRACE("WM_CREATEDOC %p\n", params);
+
+        params->hres = HTMLDocument_Create(NULL, &params->iid, (void**)&unk);
+        if(FAILED(params->hres))
+            return 0;
+
+        params->hres = CoMarshalInterface(params->stream, &params->iid, unk, MSHCTX_INPROC, NULL, MSHLFLAGS_NORMAL);
+        IUnknown_Release(unk);
+        return 0;
+    }
     }
 
     if(msg > WM_USER)
@@ -367,6 +410,35 @@ HWND get_thread_hwnd(void)
     return thread_data->thread_hwnd;
 }
 
+HRESULT create_marshaled_doc(HWND main_thread_hwnd, REFIID riid, void **ppv)
+{
+    create_doc_params_t params = {NULL, *riid, NULL, E_FAIL};
+    LARGE_INTEGER zero;
+    BOOL res;
+    HRESULT hres;
+
+    hres = CreateStreamOnHGlobal(NULL, TRUE, &params.stream);
+    if(FAILED(hres))
+        return hres;
+
+    res = SendMessageW(main_thread_hwnd, WM_CREATEDOC, 0, (LPARAM)&params);
+    TRACE("SendMessage ret %x\n", res);
+    if(FAILED(params.hres)) {
+        WARN("EM_CREATEDOC failed: %08x\n", params.hres);
+        IStream_Release(params.stream);
+        return hres;
+    }
+
+    zero.QuadPart = 0;
+    hres = IStream_Seek(params.stream, zero, STREAM_SEEK_SET, NULL);
+    if(SUCCEEDED(hres))
+        hres = CoUnmarshalInterface(params.stream, riid, ppv);
+    IStream_Release(params.stream);
+    if(FAILED(hres))
+        WARN("CoUnmarshalInterface failed: %08x\n", hres);
+    return hres;
+}
+
 thread_data_t *get_thread_data(BOOL create)
 {
     thread_data_t *thread_data;
diff --git a/dlls/mshtml/tests/documentmode.js b/dlls/mshtml/tests/documentmode.js
index 74e871e47f1..532731d1e84 100644
--- a/dlls/mshtml/tests/documentmode.js
+++ b/dlls/mshtml/tests/documentmode.js
@@ -146,7 +146,7 @@ sync_test("builtin_toString", function() {
     ];
     var v = document.documentMode, e;
 
-    function test(msg, obj, name, tostr) {
+    function test(msg, obj, name, tostr, ctor_name) {
         var s;
         if(obj.toString) {
             s = obj.toString();
@@ -154,8 +154,34 @@ sync_test("builtin_toString", function() {
             ok(s === (tostr ? tostr : (v < 9 ? "[object]" : "[object " + name + "]")), msg + " toString returned " + s);
         }
         s = Object.prototype.toString.call(obj);
-        todo_wine_if(v >= 9 && name != "Object").
+        todo_wine_if(name !== "HTMLElement" && s === "[object HTMLElement]").
         ok(s === (v < 9 ? "[object Object]" : "[object " + name + "]"), msg + " Object.toString returned " + s);
+
+        if(v >= 9) {
+            eval("var c = window." + name + ";");
+            todo_wine_if(name !== "HTMLElement" && s === "[object HTMLElement]").
+            ok(c !== undefined, name + " is undefined");
+            if(!ctor_name) ctor_name = name;
+            if(c === undefined) return;  /* todo_wine */
+
+            s = Object.getPrototypeOf(obj);
+            if(name === "Object") {
+                ok(s === null, msg + "'s proto is not null: " + s);
+
+                s = Object.prototype.toString.call(c);
+                ok(s === "[object Function]", msg + " Object.toString on constructor returned " + s);
+            }else {
+                ok(s === c.prototype, msg + "'s proto is not its constructor's prototype");
+
+                s = Object.prototype.toString.call(c);
+                todo_wine_if(name !== "HTMLElement" && s === "[object HTMLElement]").
+                ok(s === "[object " + ctor_name + "]", msg + " Object.toString on constructor returned " + s);
+
+                s = Object.prototype.toString.call(c.prototype);
+                todo_wine_if(name !== "HTMLElement" && s === "[object HTMLElementPrototype]").
+                ok(s === "[object " + name + "Prototype]", msg + " Object.toString on constructor.prototype returned " + s);
+            }
+        }
     }
 
     for(var i = 0; i < tags.length; i++)
@@ -205,12 +231,12 @@ sync_test("builtin_toString", function() {
     if(!localStorage) win_skip("localStorage is buggy and not available, skipping");
 
     test("attribute", document.createAttribute("class"), "Attr");
-    if(false /* todo_wine */) test("attributes", e.attributes, "NamedNodeMap");
+    test("attributes", e.attributes, "NamedNodeMap");
     test("childNodes", document.body.childNodes, "NodeList");
     if(clientRects) test("clientRect", clientRects[0], "ClientRect");
     if(clientRects) test("clientRects", clientRects, "ClientRectList");
     if(currentStyle) test("currentStyle", currentStyle, "MSCurrentStyleCSSProperties");
-    if(v >= 11 /* todo_wine */) test("document", document, v < 11 ? "Document" : "HTMLDocument");
+    test("document", document, v < 11 ? "Document" : "HTMLDocument");
     test("elements", document.getElementsByTagName("body"), "HTMLCollection");
     test("history", window.history, "History");
     test("implementation", document.implementation, "DOMImplementation");
@@ -232,7 +258,7 @@ sync_test("builtin_toString", function() {
     test("textNode", document.createTextNode("testNode"), "Text", v < 9 ? "testNode" : null);
     test("textRange", txtRange, "TextRange");
     test("window", window, "Window", "[object Window]");
-    test("xmlHttpRequest", new XMLHttpRequest(), "XMLHttpRequest");
+    test("xmlHttpRequest", new XMLHttpRequest(), "XMLHttpRequest", null, "Function");
     if(v < 10) {
         test("namespaces", document.namespaces, "MSNamespaceInfoCollection");
     }
@@ -241,7 +267,13 @@ sync_test("builtin_toString", function() {
         test("selection", document.selection, "MSSelection");
     }
     if(v >= 9) {
+        var xml = new DOMParser().parseFromString("<tag>foobar</tag>", "text/xml");
         test("computedStyle", window.getComputedStyle(e), "CSSStyleDeclaration");
+        test("domParser", new DOMParser(), "DOMParser", null, "Function");
+        test("svgDocument", new DOMParser().parseFromString("<tag>foobar</tag>", "image/svg+xml"), v < 11 ? "Document" : "XMLDocument");
+        test("xhtmlDocument", new DOMParser().parseFromString("<tag>foobar</tag>", "application/xhtml+xml"), v < 11 ? "Document" : "XMLDocument");
+        test("xmlDocument", xml, v < 11 ? "Document" : "XMLDocument");
+        test("xmlElement", xml.getElementsByTagName("tag")[0], "Element");
 
         test("Event", document.createEvent("Event"), "Event");
         test("CustomEvent", document.createEvent("CustomEvent"), "CustomEvent");
@@ -253,12 +285,1070 @@ sync_test("builtin_toString", function() {
         test("classList", e.classList, "DOMTokenList", "testclass    another ");
         test("console", window.console, "Console");
     }
+    if(v >= 11) {
+        test("crypto", window.msCrypto, "Crypto");
+        test("crypto.subtle", window.msCrypto.subtle, "SubtleCrypto");
+    }
     if(v >= 9) {
         document.body.innerHTML = "<!--...-->";
         test("comment", document.body.firstChild, "Comment");
     }
 });
 
+sync_test("builtin_obj", function() {
+    var v = document.documentMode;
+    var f = document.createElement;
+    var e;
+
+    if(v < 9) {
+        ok(!(window instanceof Object), "window instance of Object");
+        ok(!(document instanceof Object), "document instance of Object");
+        ok(!(f.apply instanceof Function), "f.apply instance of Function");
+        ok(!(f.call instanceof Function), "f.call instance of Function");
+        ok(!("arguments" in f), "arguments in f");
+        ok(!("length" in f), "length in f");
+        e = 0;
+        try {
+            f.toString();
+        }catch(ex) {
+            e = ex.number;
+        }
+        ok(e === 0xa01b6 - 0x80000000, "[f.toString] e = " + e);
+        try {
+            window.toString.call(null);
+            ok(false, "expected exception calling window.toString with null context");
+        }catch(ex) {}
+    }else {
+        ok(window instanceof Object, "window not instance of Object");
+        ok(document instanceof Object, "document not instance of Object");
+        ok(Object.isExtensible(window), "window is not extensible");
+        ok(Object.isExtensible(document), "document is not extensible");
+
+        ok(f.toString() === "\nfunction createElement() {\n    [native code]\n}\n", "f.toString() = " + f.toString());
+        ok(Object.getPrototypeOf(f) === Function.prototype, "unexpected document.createElement prototype");
+        ok(Object.getPrototypeOf(f.apply) === Function.prototype, "unexpected f.apply prototype");
+        ok(Object.getPrototypeOf(f.call) === Function.prototype, "unexpected f.call prototype");
+
+        e = window.toString.call(null);
+        ok(e === "[object Window]", "window.toString with null context = " + e);
+        e = window.toString.call(external.nullDisp);
+        ok(e === "[object Window]", "window.toString with nullDisp context = " + e);
+    }
+
+    e = 0;
+    try {
+        f.call(Object, "div");
+    }catch(ex) {
+        e = ex.number;
+    }
+    ok(e === (v < 9 ? 0xa0005 : 0x0ffff) - 0x80000000, "[f.call(Object, 'div')] e = " + e);
+
+    e = 0;
+    try {
+        f.call(null, "div");
+    }catch(ex) {
+        e = ex.number;
+    }
+    ok(e === (v < 9 ? 0xa0005 : 0x0ffff) - 0x80000000, "[f.call(null, 'div')] e = " + e);
+
+    var elem = f.call(document, "div");
+    elem.setAttribute("class", "cls");
+    elem.setAttribute("className", "cls");
+    ok(elem.className === "cls", "elem.className = " + elem.className);
+
+    document.body.click.call(elem);
+
+    e = 0;
+    try {
+        new f();
+    }catch(ex) {
+        e = ex.number;
+    }
+    ok(e === (v < 9 ? 0xa01b6 : 0x0ffff) - 0x80000000, "[new f()] e = " + e);
+
+    if(v < 9) {
+        e = 0;
+        try {
+            elem = f.call.call(f, document, "div");
+        }catch(ex) {
+            e = ex.number;
+        }
+        ok(e === 0xa01b6 - 0x80000000, "[elem = f.call.call(f, document, 'div')] e = " + e);
+        e = 0;
+        try {
+            f = f.bind(document);
+        }catch(ex) {
+            e = ex.number;
+        }
+        ok(e === 0xa01b6 - 0x80000000, "[f.bind(document)] e = " + e);
+        elem = f.apply(document, ["style"]);
+        document.body.appendChild(elem);
+
+        var enumerator = new Enumerator(document.getElementsByTagName("style"));
+        enumerator.moveNext();
+        var enum_elem = enumerator.item();
+        enumerator.moveNext();
+        ok(enum_elem === elem, "enum_elem = " + enum_elem);
+        ok(enumerator.atEnd(), "enumerator not at end");
+
+        e = 0;
+        try {
+            f.apply = 0;
+        }catch(ex) {
+            e = ex.number;
+        }
+        ok(e === 0xa01b6 - 0x80000000, "[f.apply = 0] e = " + e);
+        e = 0;
+        try {
+            f.call = function() { };
+        }catch(ex) {
+            e = ex.number;
+        }
+        ok(e === 0xa01b6 - 0x80000000, "[f.call = function() { }] e = " + e);
+
+        f = f.apply;
+        ok(!("arguments" in f), "arguments in f.apply");
+        ok(!("length" in f), "length in f.apply");
+        e = 0;
+        try {
+            f.toString();
+        }catch(ex) {
+            e = ex.number;
+        }
+        ok(e === 0xa01b6 - 0x80000000, "[f.apply.toString] e = " + e);
+        e = 0;
+        try {
+            f(document, ["style"]);
+        }catch(ex) {
+            e = ex.number;
+        }
+        ok(e === 0xa01b6 - 0x80000000, "[f.apply() indirect] e = " + e);
+    }else {
+        elem = f.call.call(f, document, "div");
+        f = f.bind(document);
+        elem = f.apply(null, ["style"]);
+        document.body.appendChild(elem);
+
+        try {
+            var enumerator = new Enumerator(document.getElementsByTagName("style"));
+        }catch(ex) {
+            e = ex.number;
+        }
+        ok(e === 0xa01c3 - 0x80000000, "[style Enumerator] e = " + e);
+
+        f.apply = 0;
+        f.call = function() { };
+        ok(f.apply === 0, "changed f.apply = ", f.apply);
+        ok(f.call instanceof Function, "changed f.call not instance of Function");
+
+        e = Array.isArray(document.body.childNodes);
+        ok(e === false, "isArray(childNodes) returned " + e);
+        e = Array.prototype.toString.call(Number);
+        ok(e === "[object Function]", "Array.toString(Number) = " + e);
+    }
+
+    function test_toString(msg, constr, err) {
+        var e = 0;
+        if(typeof err == "string") {
+            e = constr.prototype.toString.call(document.body);
+            ok(e === err, msg + ".toString(body) = " + e);
+            return;
+        }
+        try {
+            constr.prototype.toString.call(document.body);
+        }catch(ex) {
+            e = ex.number;
+        }
+        ok(e === err - 0x80000000, "[" + msg + ".toString(body)] e = " + e);
+    }
+
+    test_toString("Array", Array, v < 9 ? 0xa13a7 : "[object HTMLBodyElement]");
+    test_toString("Boolean", Boolean, 0xa1392);
+    test_toString("Date", Date, 0xa138e);
+    test_toString("RegExp", RegExp, 0xa1398);
+    test_toString("Number", Number, 0xa1389);
+    test_toString("String", String, 0xa138d);
+
+    if(v >= 9) {
+        var obj = { length: 2 };
+        obj[0] = "foo";
+        obj[1] = "bar";
+        e = Array.prototype.toString.call(obj);
+        ok(e === "[object Object]", "Array.toString(array-like object) = " + e);
+
+        obj = Object.create(null);
+        obj.length = 2;
+        obj[0] = "foo";
+        obj[1] = "bar";
+        e = Array.prototype.toString.call(obj);
+        ok(e === "[object Object]", "Array.toString(array-like object with no prototype) = " + e);
+
+        e = 0;
+        try {
+            Array.prototype.toString.call(null);
+        }catch(ex) {
+            e = ex.number;
+        }
+        ok(e === 0xa138f - 0x80000000, "Array.toString(null) e = " + e);
+    }
+
+    (function(a, b, c) {
+        ok(a === document.body.childNodes[0], "a = " + a);
+        ok(b === document.body.childNodes[1], "b = " + b);
+        ok(c === document.body.childNodes[2], "c = " + c);
+    }).apply(null, document.body.childNodes);
+
+    elem[0] = "a";
+    elem[1] = "b";
+    if(v < 9) {
+        try {
+            (function(a, b) {}).apply(null, elem);
+        }catch(ex) {
+            e = ex.number;
+        }
+        ok(e === 0xa13a4 - 0x80000000, "[function.apply with elem without length] e = " + e);
+    }else {
+        (function(a, b) {
+            ok(a === undefined, "a = " + a);
+            ok(b === undefined, "b = " + b);
+        }).apply(null, elem);
+    }
+
+    elem.length = 2;
+    (function(a, b) {
+        ok(a === "a", "a = " + a);
+        ok(b === "b", "b = " + b);
+    }).apply(null, elem);
+
+    elem = new Object;
+    elem[0] = "c";
+    elem[1] = "d";
+    if(v < 9) {
+        try {
+            (function(c, d) {}).apply(null, elem);
+        }catch(ex) {
+            e = ex.number;
+        }
+        ok(e === 0xa13a4 - 0x80000000, "[function.apply with Object without length] e = " + e);
+    }else {
+        (function(c, d) {
+            ok(c === undefined, "c = " + c);
+            ok(d === undefined, "d = " + d);
+        }).apply(null, elem);
+    }
+
+    elem.length = 2;
+    if(v < 9) {
+        try {
+            (function(c, d) {}).apply(null, elem);
+        }catch(ex) {
+            e = ex.number;
+        }
+        ok(e === 0xa13a4 - 0x80000000, "[function.apply with Object with length] e = " + e);
+    }else {
+        (function(c, d) {
+            ok(c === "c", "c = " + c);
+            ok(d === "d", "d = " + d);
+        }).apply(null, elem);
+    }
+});
+
+sync_test("builtin_prototypes", function() {
+    var v = document.documentMode, r, obj, name, proto;
+
+    var special_ctors = [
+        [ "DOMParser",          [ "prototype", "arguments" ], [ "create", "length" ], 9 ],
+        [ "Image",              [ "prototype", "arguments" ], [ "create", "length" ] ],
+        [ "Option",             [ "prototype", "arguments" ], [ "create", "length" ] ],
+        [ "XMLHttpRequest",     [ "prototype", "arguments", "create" ], [ "length" ] ]
+    ];
+    for(var i = 0; i < special_ctors.length; i++) {
+        if(special_ctors[i].length > 3 && v < special_ctors[i][3])
+            continue;
+        name = special_ctors[i][0];
+        ok(Object.prototype.hasOwnProperty.call(window, name), name + " not a property of window.");
+        eval("obj = window." + name + ";");
+        if(v < 9) {
+            ok(!Object.prototype.hasOwnProperty.call(obj, "arguments"), "arguments is a property of " + name + " constructor.");
+            ok(Object.prototype.hasOwnProperty.call(obj, "create"), "create not a property of " + name + " constructor.");
+            ok(!Object.prototype.hasOwnProperty.call(obj, "length"), "length is a property of " + name + " constructor.");
+            ok(Object.prototype.hasOwnProperty.call(obj, "prototype"), "prototype not a property of " + name + " constructor.");
+            ok(!("length" in obj), "length in " + name + " constructor.");
+            if(window.Window)
+                ok(!Object.prototype.hasOwnProperty.call(window.Window.prototype, name), name + " is a property of window's prototype.");
+        }else {
+            if(special_ctors[i][1]) for(var j = 0; j < special_ctors[i][1].length; j++)
+                ok(Object.prototype.hasOwnProperty.call(obj, special_ctors[i][1][j]), special_ctors[i][1][j] + " not a property of " + name + " constructor.");
+
+            if(special_ctors[i][2]) for(var j = 0; j < special_ctors[i][2].length; j++)
+                ok(!Object.prototype.hasOwnProperty.call(obj, special_ctors[i][2][j]), special_ctors[i][2][j] + " is a property of " + name + " constructor.");
+
+            ok(Object.getPrototypeOf(obj) === Function.prototype, "getPrototypeOf(" + name + " constructor) = " + Object.getPrototypeOf(obj));
+            ok(!Object.prototype.hasOwnProperty.call(Object.getPrototypeOf(window), name), name + " is a property of window's prototype.");
+
+            if(obj.create) {
+                proto = obj.prototype;
+                var func = obj.create;
+                var s = Object.prototype.toString.call(func);
+                ok(s === "[object Function]", "obj.create toString = " + s);
+                ok(Object.getPrototypeOf(func) === Function.prototype, "getPrototypeOf(" + name + ".create) = " + Object.getPrototypeOf(func));
+                ok(Object.prototype.hasOwnProperty.call(func, "arguments"), "arguments not a property of " + name + ".create");
+                ok(!Object.prototype.hasOwnProperty.call(func, "length"), "length is a property of " + name + ".create");
+                ok(Object.prototype.hasOwnProperty.call(func, "prototype"), "prototype not a property of " + name + ".create");
+
+                obj = func();
+                ok(Object.getPrototypeOf(obj) === proto, "getPrototypeOf(obj.create()) = " + Object.getPrototypeOf(obj));
+                obj = func.call(Object);
+                ok(Object.getPrototypeOf(obj) === proto, "getPrototypeOf(obj.create() on Object) = " + Object.getPrototypeOf(obj));
+            }
+        }
+    }
+
+    function set_obj(n, o) {
+        name = n;
+        proto = null;
+        if(o) {
+            eval("proto = window." + n + ".prototype;");
+            if(typeof o !== "boolean") {
+                obj = o;
+                return;
+            }
+        }
+        try {
+            eval("obj = new window." + n + "();");
+            ok(o, "expected exception when creating " + name + ".");
+        }catch(ex) {
+            obj = null;
+            ok(!o, "did not expect exception when creating " + name + ".");
+            ok(ex.number == 0xa01bd - 0x80000000, "unexpected exception number when creating " + name + ": " + ex.number);
+        }
+    }
+    function test_prop(prop, own) {
+        if(own === undefined ? v < 9 : own)
+            ok(Object.prototype.hasOwnProperty.call(obj, prop), prop + " not a property of " + name + ".");
+        else
+            ok(!Object.prototype.hasOwnProperty.call(obj, prop), prop + " is a property of " + name + ".");
+        ok(Object.prototype.hasOwnProperty.call(proto, prop), prop + " not a property of " + name + ".prototype.");
+    }
+    function test_compat_ctor(methods, props, non_props, set_prop, set_prop_val) {
+        if(v >= 9)
+            return;
+        ok(""+proto === "[Interface prototype object]", name + ".prototype = " + proto);
+        if(v < 8)
+            ok(proto.constructor === undefined, name + ".prototype.constructor = " + proto.constructor);
+        for(var i = 0; i < methods.length; i++) {
+            ok(methods[i] in proto, methods[i] + " not in " + name + ".prototype");
+            var r = 0;
+            try {
+                eval("proto." + methods[i] + "();");
+            }catch(ex) {
+                r = ex.number;
+            }
+            ok(r === 0xa01b6 - 0x80000000, name + ".prototype." + methods[i] + "() exception code = " + r);
+            eval("r = \"\"+proto." + methods[i] + ";");
+            ok(r === "\nfunction " + methods[i] + "() {\n    [native code]\n}\n", name + ".prototype." + methods[i] + " = " + r);
+            try {
+                eval("r = (delete proto." + methods[i] + ");");
+                ok(v >= 8, "expected exception deleting " + name + ".prototype." + methods[i]);
+                ok(r === true, "delete " + name + ".prototype." + methods[i] + " returned " + r);
+            }catch(ex) {
+                ok(v < 8, "did not expect exception deleting " + name + ".prototype." + methods[i]);
+            }
+            eval("r = \"\"+proto." + methods[i] + ";");
+            ok(r === "\nfunction " + methods[i] + "() {\n    [native code]\n}\n", name + ".prototype." + methods[i] + " after delete = " + r);
+            ok(methods[i] in proto, methods[i] + " not in " + name + ".prototype after delete");
+
+            var func = function() { return "foobar"; }
+            eval("proto." + methods[i] + " = func;");
+            eval("r = proto." + methods[i] + ";");
+            ok(r === func, name + ".prototype." + methods[i] + " after set = " + r);
+            try {
+                eval("r = (delete proto." + methods[i] + ");");
+                ok(v >= 8, "expected exception deleting " + name + ".prototype." + methods[i] + " after set");
+                ok(r === true, "delete " + name + ".prototype." + methods[i] + " after set returned " + r);
+                eval("r = \"\"+proto." + methods[i] + ";");
+                ok(r === "\nfunction " + methods[i] + "() {\n    [native code]\n}\n", name + ".prototype." + methods[i] + " after second delete = " + r);
+            }catch(ex) {
+                ok(v < 8, "did not expect exception deleting " + name + ".prototype." + methods[i] + " after set");
+                eval("r = proto." + methods[i] + ";");
+                ok(r === func, name + ".prototype." + methods[i] + " after second delete = " + r);
+            }
+            eval("proto." + methods[i] + " = func;");
+            eval("r = proto." + methods[i] + ";");
+            ok(r === func, name + ".prototype." + methods[i] + " after second set = " + r);
+        }
+        for(var i = 0; i < props.length; i++) {
+            ok(props[i] in proto, props[i] + " not in " + name + ".prototype");
+            eval("var r = proto." + props[i] + ";");
+            ok(r === undefined, name + ".prototype." + props[i] + " = " + r);
+            try {
+                eval("r = (delete proto." + props[i] + ");");
+                ok(v >= 8, "expected exception deleting " + name + ".prototype." + props[i]);
+                ok(r === true, "delete " + name + ".prototype." + props[i] + " returned " + r);
+            }catch(ex) {
+                ok(v < 8, "did not expect exception deleting " + name + ".prototype." + props[i]);
+            }
+            eval("r = proto." + props[i] + ";");
+            ok(r === undefined, name + ".prototype." + props[i] + " after delete = " + r);
+            ok(props[i] in proto, props[i] + " not in " + name + ".prototype after delete");
+        }
+        for(var i = 0; i < non_props.length; i++)
+            ok(!(non_props[i] in proto), non_props[i] + " in " + name + ".prototype");
+
+        eval("r = proto." + set_prop + ";");
+        ok(r === undefined, name + ".prototype." + set_prop + " = " + r);
+        eval("proto." + set_prop + " = set_prop_val; r = proto." + set_prop + ";");
+        ok(r === undefined, name + ".prototype." + set_prop + " after set = " + r);
+
+        r = proto.winetestprop;
+        ok(r === undefined, name + ".prototype.winetestprop = " + r);
+        proto.winetestprop = "test";
+        r = proto.winetestprop;
+        ok(r === "test", name + ".prototype.winetestprop after set = " + r);
+    }
+
+    set_obj("XMLHttpRequest", true);
+    test_prop("open");
+    test_prop("status");
+    test_prop("onreadystatechange");
+    test_compat_ctor(["abort", "send"], ["readyState", "status"], ["selected", "src", "getAttribute"], "onreadystatechange", function(){});
+    if(v < 9) {
+        r = obj.abort();
+        ok(r === "foobar", "(new XMLHttpRequest).abort() returned " + r);
+        r = obj.winetestprop;
+        ok(r === "test", "(new XMLHttpRequest).winetestprop = " + r);
+        obj.winetestprop = "prop";
+        r = obj.winetestprop;
+        ok(r === "prop", "(new XMLHttpRequest).winetestprop after set = " + r);
+        r = XMLHttpRequest.prototype.winetestprop;
+        ok(r === "test", "XMLHttpRequest.prototype.winetestprop after obj = " + r);
+    }else
+        ok(proto.constructor === window.XMLHttpRequest, "XMLHttpRequest.prototype.constructor = " + proto.constructor);
+
+    set_obj("Image", true);
+    test_prop("src");
+    test_prop("border");
+    test_compat_ctor(["getAttribute", "toString"], ["isMap", "alt"], ["selected", "send"], "src", "about:blank");
+    if(v < 9) {
+        r = obj.toString();
+        ok(r === "foobar", "(new Image).toString() returned " + r);
+        r = obj.winetestprop;
+        ok(r === "test", "(new Image).winetestprop = " + r);
+        obj.winetestprop = "prop";
+        r = obj.winetestprop;
+        ok(r === "prop", "(new Image).winetestprop after set = " + r);
+        r = window.Image.prototype.winetestprop;
+        ok(r === "test", "Image.prototype.winetestprop after obj = " + r);
+        try {
+            r = (delete obj.winetestprop);
+            ok(v >= 8, "expected exception deleting (new Image).winetestprop");
+            ok(r === true, "delete (new Image).winetestprop returned " + r);
+        }catch(ex) {
+            ok(v < 8, "did not expect exception deleting (new Image).winetestprop");
+        }
+        r = obj.winetestprop;
+        ok(r === (v < 8 ? "prop" : "test"), "(new Image).winetestprop after delete = " + r);
+        obj = new window.Image();
+        r = obj.winetestprop;
+        ok(r === "test", "(new Image).winetestprop second time = " + r);
+        window.Image.prototype.winetestprop = "string";
+        r = obj.winetestprop;
+        ok(r === "string", "(new Image).winetestprop after change in prototype = " + r);
+    }else
+        ok(proto.constructor === window.HTMLImageElement, "Image.prototype.constructor = " + proto.constructor);
+
+    set_obj("Option", true);
+    test_prop("text");
+    test_prop("selected");
+    test_compat_ctor(["setAttribute", "contains"], ["index", "value"], ["src", "send"], "text", "foo");
+    if(v < 9) {
+        r = obj.setAttribute("a", "b");
+        ok(r === "foobar", "(new Option).setAttribute() returned " + r);
+        r = obj.winetestprop;
+        ok(r === "test", "(new Option).winetestprop = " + r);
+        obj.winetestprop = "prop";
+        r = obj.winetestprop;
+        ok(r === "prop", "(new Option).winetestprop after set = " + r);
+        r = window.Option.prototype.winetestprop;
+        ok(r === "test", "Option.prototype.winetestprop after obj = " + r);
+        try {
+            r = (delete obj.winetestprop);
+            ok(v >= 8, "expected exception deleting (new Option).winetestprop");
+            ok(r === true, "delete (new Option).winetestprop returned " + r);
+        }catch(ex) {
+            ok(v < 8, "did not expect exception deleting (new Option).winetestprop");
+        }
+        r = obj.winetestprop;
+        ok(r === (v < 8 ? "prop" : "test"), "(new Option).winetestprop after delete = " + r);
+        obj = new window.Option();
+        r = obj.winetestprop;
+        ok(r === "test", "(new Option).winetestprop second time = " + r);
+        window.Option.prototype.winetestprop = "string";
+        r = obj.winetestprop;
+        ok(r === "string", "(new Option).winetestprop after change in prototype = " + r);
+    }else
+        ok(proto.constructor === window.HTMLOptionElement, "Option.prototype.constructor = " + proto.constructor);
+
+    if(v >= 9) {
+        set_obj("DOMParser", true);
+        test_prop("parseFromString");
+        ok(proto.constructor === window.DOMParser, "DOMParser.prototype.constructor = " + proto.constructor);
+    }
+
+    // other constructors don't support construction
+    set_obj("ClientRect");
+    set_obj("ClientRectList");
+    set_obj("Console");
+    set_obj("CustomEvent");
+    set_obj("DOMTokenList");
+    set_obj("KeyboardEvent");
+    set_obj("MessageEvent");
+    set_obj("MouseEvent");
+    set_obj("MSCSSRuleList");
+    set_obj("MSCurrentStyleCSSProperties");
+    set_obj("MSEventObj");
+    set_obj("MSNamespaceInfoCollection");
+    set_obj("MSSelection");
+    set_obj("MSStyleCSSProperties");
+    set_obj("Performance");
+    set_obj("PerformanceNavigation");
+    set_obj("PerformanceTiming");
+    set_obj("UIEvent");
+    if(v >= 9) {
+        set_obj("Attr");
+        set_obj("CSSStyleDeclaration");
+        set_obj("CSSStyleRule");
+        set_obj("CSSStyleSheet");
+        set_obj("DOMImplementation");
+        set_obj("Event");
+        set_obj("History");
+        set_obj("HTMLCollection");
+        set_obj("NamedNodeMap");
+        set_obj("Navigator");
+        set_obj("NodeList");
+        set_obj("Screen");
+        set_obj("Storage");
+        set_obj("StyleSheetList");
+        set_obj("Text");
+        set_obj("TextRange");
+        set_obj("Window");
+    }
+    if(v >= 11) {
+        set_obj("Crypto");
+        set_obj("SubtleCrypto");
+    }
+
+    if(v >= 8 && v < 11) {
+        set_obj(v < 9 ? "Event" : "MSEventObj", document.createEventObject());
+        test_prop("x");
+        test_prop("y");
+        test_prop("srcElement");
+        test_prop("returnValue");
+
+        if(Object.create) {
+            obj = Object.create(proto);
+            test_prop("reason");
+            test_prop("srcFilter");
+            r = Object.prototype.toString.call(obj);
+            ok(r === "[object Object]", "Object.toString on obj created from MSEventObj.prototype returned " + r);
+        }
+
+        var ctor = function() {};
+        ctor.prototype = proto;
+        ctor.prototype.testWineProp = function() { return 42; };
+        obj = new ctor();
+        test_prop("shiftKey", false);
+        test_prop("testWineProp", false);
+        r = Object.prototype.toString.call(obj);
+        ok(r === "[object Object]", "Object.toString on custom obj returned " + r);
+
+        r = (delete proto.shiftKey);
+        ok(r === true, "delete shiftKey returned " + r);
+        if(v < 9)
+            ok(Object.prototype.hasOwnProperty.call(proto, "shiftKey"), "shiftKey not a property anymore of Event.prototype.");
+        else {
+            ok(!Object.prototype.hasOwnProperty.call(proto, "shiftKey"), "shiftKey still a property of MSEventObj.prototype.");
+            proto.shiftKey = ctor;
+            ok(proto.shiftKey === ctor, "shiftKey = " + proto.shiftKey);
+        }
+
+        r = (delete proto.testWineProp);
+        ok(r === true, "delete testWineProp returned " + r);
+        ok(!Object.prototype.hasOwnProperty.call(proto, "testWineProp"), "testWineProp still a property of " + name + ".prototype.");
+    }
+
+    if(v >= 9) {
+        set_obj("Event", document.createEvent("Event"));
+        test_prop("initEvent");
+        test_prop("currentTarget");
+
+        obj = Object.create(proto);
+        test_prop("eventPhase");
+        test_prop("preventDefault");
+        r = Object.prototype.toString.call(obj);
+        ok(r === "[object Object]", "Object.toString on obj created from Event.prototype returned " + r);
+
+        var ctor = function() {};
+        ctor.prototype = proto;
+        ctor.prototype.testWineProp = function() { return 42; };
+        obj = new ctor();
+        test_prop("timeStamp");
+        test_prop("testWineProp");
+        r = Object.prototype.toString.call(obj);
+        ok(r === "[object Object]", "Object.toString on custom obj returned " + r);
+
+        r = (delete proto.timeStamp);
+        ok(r === true, "delete timeStamp returned " + r);
+        ok(!Object.prototype.hasOwnProperty.call(proto, "timeStamp"), "timeStamp still a property of Event.prototype.");
+
+        r = (delete proto.testWineProp);
+        ok(r === true, "delete testWineProp returned " + r);
+        ok(!Object.prototype.hasOwnProperty.call(proto, "testWineProp"), "testWineProp still a property of Event.prototype.");
+
+        proto.timeStamp = ctor;
+        ok(proto.timeStamp === ctor, "timeStamp = " + proto.timeStamp);
+
+        set_obj("HTMLImageElement", document.createElement("img"));
+        document.body.setAttribute.call(obj, "width", "100");
+        obj = Object.create(proto);
+        r = 0;
+        try {
+            document.body.setAttribute.call(obj, "width", "100");
+        }catch(ex) {
+            r = ex.number;
+        }
+        ok(r === 0xffff - 0x80000000, "document.body.setAttribute.call(obj ...) exception code = " + r);
+    }
+
+    if(v >= 8) {
+        obj = window.HTMLMetaElement;
+        ok(!("charset" in obj), "charset in HTMLMetaElement constructor.");
+        ok(!("setAttribute" in obj), "setAttribute in HTMLMetaElement constructor.");
+        ok(!Object.prototype.hasOwnProperty.call(obj, "charset"), "charset is a property of HTMLMetaElement constructor.");
+        if(Object.getPrototypeOf)
+            ok(Object.getPrototypeOf(obj) === Object.prototype, "getPrototypeOf(HTMLMetaElement constructor) = " + Object.getPrototypeOf(obj));
+        r = 0;
+        try {
+            document.body.setAttribute.call(obj, "charset", "UTF-8");
+        }catch(ex) {
+            r = ex.number;
+        }
+        ok(r === (v < 9 ? 0xa0005 : 0xffff) - 0x80000000, "setAttribute on HTMLMetaElement constructor error code = " + r);
+
+        proto = window.HTMLMetaElement.prototype;
+        try {
+            window.HTMLMetaElement.prototype = Object.prototype;
+            ok(v >= 9, "expected exception setting HTMLMetaElement.prototype");
+        }catch(ex) {
+            ok(v < 9, "did not expect exception setting HTMLMetaElement.prototype");
+            ok(ex.number === 0xa01b6 - 0x80000000, "exception code setting HTMLMetaElement.prototype = " + ex.number);
+        }
+        ok(window.HTMLMetaElement.prototype === proto, "HTMLMetaElement.prototype = " + window.HTMLMetaElement.prototype);
+        ok(proto !== Object.prototype, "old prototype is Object.prototype");
+
+        obj = document.createElement("meta");
+        ok("tagName" in obj, "tagName not in HTMLMetaElement");
+        if(Object.getPrototypeOf)
+            ok(Object.getPrototypeOf(obj) === proto, "getPrototypeOf(meta element) = " + Object.getPrototypeOf(obj));
+
+        try {
+            r = (delete window.HTMLMetaElement.prototype);
+            ok(r === false, "delete HTMLMetaElement.prototype returned " + r);
+            ok(v >= 9, "expected exception deleting HTMLMetaElement.prototype");
+        }catch(ex) {
+            ok(v < 9, "did not expect exception deleting HTMLMetaElement.prototype");
+            ok(ex.number === 0xa01b6 - 0x80000000, "exception code deleting HTMLMetaElement.prototype = " + ex.number);
+        }
+        ok(Object.prototype.hasOwnProperty.call(window.HTMLMetaElement, "prototype"), "prototype not a property anymore of HTMLMetaElement.");
+
+        try {
+            r = (delete window.HTMLMetaElement);
+            ok(r === true, "delete HTMLMetaElement returned " + r);
+            ok(v >= 9, "expected exception deleting HTMLMetaElement");
+            ok(!Object.prototype.hasOwnProperty.call(window, "HTMLMetaElement"), "HTMLMetaElement still a property of window.");
+        }catch(ex) {
+            ok(v < 9, "did not expect exception deleting HTMLMetaElement");
+            ok(ex.number === 0xa01bd - 0x80000000, "exception code deleting HTMLMetaElement = " + ex.number);
+            ok(Object.prototype.hasOwnProperty.call(window, "HTMLMetaElement"), "HTMLMetaElement not a property anymore of window.");
+        }
+
+        obj = document.createElement("meta");
+        ok("tagName" in obj, "tagName not in HTMLMetaElement");
+        if(Object.getPrototypeOf) {
+            ok(Object.getPrototypeOf(obj) === proto, "getPrototypeOf(meta element) = " + Object.getPrototypeOf(obj));
+            ok(window.HTMLMetaElement === undefined, "HTMLMetaElement = " + window.HTMLMetaElement);
+        }
+
+        ok("setAttribute" in proto, "setAttribute not in proto.");
+        r = 0;
+        try {
+            obj.setAttribute.call(proto, "charset", "UTF-8");
+        }catch(ex) {
+            r = ex.number;
+        }
+        ok(r === (v < 9 ? 0xa01b6 : 0xffff) - 0x80000000, "setAttribute on proto error code = " + r);
+        r = 0;
+        try {
+            proto.setAttribute("charset", "UTF-8");
+        }catch(ex) {
+            r = ex.number;
+        }
+        ok(r === (v < 9 ? 0xa01b6 : 0xffff) - 0x80000000, "proto.setAttribute error code = " + r);
+
+        ok(Object.prototype.hasOwnProperty.call(proto, "charset"), "charset not a property of proto.");
+        if(v < 9) {
+            proto.charset = "UTF-8";
+            ok(proto.charset === undefined, "proto.charset = " + proto.charset);
+        }else {
+            r = Object.getOwnPropertyDescriptor(proto, "charset");
+            ok(r.get.toString() === "\nfunction charset() {\n    [native code]\n}\n", "charset.get = " + r.get.toString());
+            ok(r.set.toString() === "\nfunction charset() {\n    [native code]\n}\n", "charset.set = " + r.set.toString());
+            ok(Object.getPrototypeOf(r.get) === Function.prototype, "unexpected charset.get prototype");
+            ok(Object.getPrototypeOf(r.set) === Function.prototype, "unexpected charset.set prototype");
+
+            r = 0;
+            try {
+                proto.charset;
+            }catch(ex) {
+                r = ex.number;
+            }
+            ok(r === 0xffff - 0x80000000, "proto.charset error code = " + r);
+            r = 0;
+            try {
+                proto.charset = "UTF-8";
+            }catch(ex) {
+                r = ex.number;
+            }
+            ok(r === 0xffff - 0x80000000, "set proto.charset error code = " + r);
+        }
+    }
+
+
+    if(v < 9) {
+        // IHTMLDOMConstructorCollection props
+        var ctors = [
+            [ "Attr" ],
+            [ "BehaviorUrnsCollection" ],
+            [ "BookmarkCollection" ],
+            [ "CSSCurrentStyleDeclaration" ],
+            [ "CSSRuleList" ],
+            [ "CSSRuleStyleDeclaration" ],
+            [ "CSSStyleDeclaration" ],
+            [ "CSSStyleRule" ],
+            [ "CSSStyleSheet" ],
+            [ "CompatibleInfo" ],
+            [ "CompatibleInfoCollection" ],
+            [ "ControlRangeCollection" ],
+            [ "DOMImplementation" ],
+            [ "DataTransfer" ],
+            [ "Element" ],
+            [ "Event" ],
+            [ "HTCElementBehaviorDefaults" ],
+            [ "HTMLAnchorElement" ],
+            [ "HTMLAreaElement" ],
+            [ "HTMLAreasCollection" ],
+            [ "HTMLBGSoundElement" ],
+            [ "HTMLBRElement" ],
+            [ "HTMLBaseElement" ],
+            [ "HTMLBaseFontElement" ],
+            [ "HTMLBlockElement" ],
+            [ "HTMLBodyElement" ],
+            [ "HTMLButtonElement" ],
+            [ "HTMLCollection" ],
+            [ "HTMLCommentElement" ],
+            [ "HTMLDDElement" ],
+            [ "HTMLDListElement" ],
+            [ "HTMLDTElement" ],
+            [ "HTMLDivElement" ],
+            [ "HTMLDocument" ],
+            [ "HTMLEmbedElement" ],
+            [ "HTMLFieldSetElement" ],
+            [ "HTMLFontElement" ],
+            [ "HTMLFormElement" ],
+            [ "HTMLFrameElement" ],
+            [ "HTMLFrameSetElement" ],
+            [ "HTMLGenericElement" ],
+            [ "HTMLHRElement" ],
+            [ "HTMLHeadElement" ],
+            [ "HTMLHeadingElement" ],
+            [ "HTMLHtmlElement" ],
+            [ "HTMLIFrameElement" ],
+            [ "HTMLImageElement" ],
+            [ "HTMLInputElement" ],
+            [ "HTMLIsIndexElement" ],
+            [ "HTMLLIElement" ],
+            [ "HTMLLabelElement" ],
+            [ "HTMLLegendElement" ],
+            [ "HTMLLinkElement" ],
+            [ "HTMLMapElement" ],
+            [ "HTMLMarqueeElement" ],
+            [ "HTMLMetaElement" ],
+            [ "HTMLModelessDialog" ],
+            [ "HTMLNamespaceInfo" ],
+            [ "HTMLNamespaceInfoCollection" ],
+            [ "HTMLNextIdElement" ],
+            [ "HTMLNoShowElement" ],
+            [ "HTMLOListElement" ],
+            [ "HTMLObjectElement" ],
+            [ "HTMLOptionElement" ],
+            [ "HTMLParagraphElement" ],
+            [ "HTMLParamElement" ],
+            [ "HTMLPhraseElement" ],
+            [ "HTMLPluginsCollection" ],
+            [ "HTMLPopup" ],
+            [ "HTMLScriptElement" ],
+            [ "HTMLSelectElement" ],
+            [ "HTMLSpanElement" ],
+            [ "HTMLStyleElement" ],
+            [ "HTMLTableCaptionElement" ],
+            [ "HTMLTableCellElement" ],
+            [ "HTMLTableColElement" ],
+            [ "HTMLTableElement" ],
+            [ "HTMLTableRowElement" ],
+            [ "HTMLTableSectionElement" ],
+            [ "HTMLTextAreaElement" ],
+            [ "HTMLTextElement" ],
+            [ "HTMLTitleElement" ],
+            [ "HTMLUListElement" ],
+            [ "HTMLUnknownElement" ],
+            [ "History" ],
+            [ "Image", 0, "HTMLImageElement" ],
+            [ "Location" ],
+            [ "NamedNodeMap" ],
+            [ "Navigator" ],
+            [ "NodeList" ],
+            [ "Option", 0, "HTMLOptionElement" ],
+            [ "Screen" ],
+            [ "Selection" ],
+            [ "StaticNodeList" ],
+            [ "Storage" ],
+            [ "StyleSheetList" ],
+            [ "StyleSheetPage" ],
+            [ "StyleSheetPageList" ],
+            [ "Text" ],
+            [ "TextRange" ],
+            [ "TextRangeCollection" ],
+            [ "TextRectangle" ],
+            [ "TextRectangleList" ],
+            [ "Window" ],
+            [ "XDomainRequest", 0 ],
+            [ "XMLHttpRequest", 0 ]
+        ];
+        for(var i = 0; i < ctors.length; i++) {
+            if(!(ctors[i][0] in window) && (v >= 8 || ctors[i][0] === "XDomainRequest")) {
+                todo_wine.ok(false, ctors[i][0] + " not implemented");
+                continue;
+            }
+            var a, b;
+            r = 0;
+            try {
+                eval("a = " + ctors[i][0] + "; b = window." + ctors[i][0] + ";");
+            }catch(ex) {
+                r = ex.number;
+            }
+            if(r === 0x4001 - 0x80000000)  /* todo_wine XDomainRequest */
+                continue;
+            if(v < 8 && (ctors[i].length < 2 || v < ctors[i][1]))
+                ok(r === 0xa1391 - 0x80000000, ctors[i][0] + " not undefined: " + r);
+            else {
+                ok(r === 0, ctors[i][0] + " exception code: " + r);
+                ok(a === b, ctors[i][0] + ": " + a + " != " + b);
+                ok(ctors[i][0] in window, ctors[i][0] + " in window");
+                if(v >= 8)
+                    ok(!(ctors[i][0] in window.Window.prototype), ctors[i][0] + " in Window.prototype");
+                r = "" + a;
+                ok(r === "[object " + ctors[i][ctors[i].length < 3 ? 0 : 2] + "]", ctors[i][0] + " returned " + r);
+                r = "" + a.prototype;
+                ok(r === "[Interface prototype object]", ctors[i][0] + ".prototype returned " + r);
+
+                var props = [ "LookupGetter", "LookupSetter", "DefineGetter", "DefineSetter" ];
+                for(var j = 0; j < props.length; j++) {
+                    ok(!(props[j] in a.prototype), props[j] + " in " + ctors[i][0] + ".prototype");
+                    ok(!(props[j] in a), props[j] + " in " + ctors[i][0]);
+                }
+                ok(!("constructor" in a), "constructor in " + ctors[i][0]);
+
+                if(v < 8 || ctors[i][0] === "HTMLModelessDialog") {
+                    ok(!("constructor" in a.prototype), "constructor in " + ctors[i][0] + ".prototype");
+                }else {
+                    ok("constructor" in a.prototype, "constructor not in " + ctors[i][0] + ".prototype");
+                    b = a.prototype.constructor;
+                    r = ctors[i][(ctors[i].length > 2) ? 2 : 0];
+                    var ctor = (r.length > 7 && r.slice(-7) === "Element") ? window.Element : null;
+                    ok(b === ctor, ctors[i][0] + ".prototype.constructor = " + b);
+                    a.prototype.constructor = "foobar";
+                    b = a.prototype.constructor;
+                    ok(b === ctor, ctors[i][0] + ".prototype.constructor after set = " + b);
+                    r = (delete a.prototype.constructor);
+                    ok(r === true, "delete " + ctors[i][0] + ".prototype.constructor returned " + r);
+                    b = a.prototype.constructor;
+                    ok(b === ctor, ctors[i][0] + ".prototype.constructor after delete = " + b);
+                }
+            }
+        }
+    }else {
+        var protos = [
+            [ "Attr",                           "Node" ],
+            [ "CharacterData",                  "Node" ],
+            [ "ClientRect",                     "Object" ],
+            [ "ClientRectList",                 "Object" ],
+            [ "Comment",                        "CharacterData" ],
+            [ "Console",                        "Object" ],
+            [ "Crypto",                         "Object" ],
+            [ "CSSRule",                        "Object" ],
+            [ "CSSStyleDeclaration",            "Object" ],
+            [ "CSSStyleRule",                   "CSSRule" ],
+            [ "CSSStyleSheet",                  "StyleSheet" ],
+            [ "CustomEvent",                    "Event" ],
+            [ "Document",                       "Node" ],
+            [ "DOMImplementation",              "Object" ],
+            [ "DOMParser",                      "Object" ],
+            [ "DOMTokenList",                   "Object" ],
+            [ "Element",                        "Node" ],
+            [ "Event",                          "Object" ],
+            [ "History",                        "Object" ],
+            [ "HTMLAnchorElement",              "HTMLElement" ],
+            [ "HTMLAreaElement",                "HTMLElement" ],
+            [ "HTMLBodyElement",                "HTMLElement" ],
+            [ "HTMLButtonElement",              "HTMLElement" ],
+            [ "HTMLCollection",                 "Object" ],
+            [ "HTMLDocument",                   "Document" ],
+            [ "HTMLElement",                    "Element" ],
+            [ "HTMLEmbedElement",               "HTMLElement" ],
+            [ "HTMLFormElement",                "HTMLElement" ],
+            [ "HTMLFrameElement",               "HTMLElement" ],
+            [ "HTMLHeadElement",                "HTMLElement" ],
+            [ "HTMLHtmlElement",                "HTMLElement" ],
+            [ "HTMLIFrameElement",              "HTMLElement" ],
+            [ "HTMLImgElement",                 "HTMLElement" ],
+            [ "HTMLInputElement",               "HTMLElement" ],
+            [ "HTMLLabelElement",               "HTMLElement" ],
+            [ "HTMLLinkElement",                "HTMLElement" ],
+            [ "HTMLMetaElement",                "HTMLElement" ],
+            [ "HTMLObjectElement",              "HTMLElement" ],
+            [ "HTMLOptionElement",              "HTMLElement" ],
+            [ "HTMLScriptElement",              "HTMLElement" ],
+            [ "HTMLSelectElement",              "HTMLElement" ],
+            [ "HTMLStyleElement",               "HTMLElement" ],
+            [ "HTMLTableCellElement",           "HTMLElement" ],
+            [ "HTMLTableDataCellElement",       "HTMLTableCellElement" ],
+            [ "HTMLTableElement",               "HTMLElement" ],
+            [ "HTMLTableRowElement",            "HTMLElement" ],
+            [ "HTMLTextAreaElement",            "HTMLElement" ],
+            [ "HTMLTitleElement",               "HTMLElement" ],
+            [ "HTMLUnknownElement",             "HTMLElement" ],
+            [ "Image",                          "HTMLElement" ],
+            [ "KeyboardEvent",                  "UIEvent" ],
+            [ "MessageEvent",                   "Event" ],
+            [ "MimeTypeArray",                  "Object" ],
+            [ "MouseEvent",                     "UIEvent" ],
+            [ "MSCSSProperties",                "CSSStyleDeclaration" ],
+            [ "MSCSSRuleList",                  "Object" ],
+            [ "MSCurrentStyleCSSProperties",    "MSCSSProperties" ],
+            [ "MSEventObj",                     "Object" ],
+            [ "MSMimeTypesCollection",          "Object" ],
+            [ "MSNamespaceInfoCollection",      "Object" ],
+            [ "MSPluginsCollection",            "Object" ],
+            [ "MSSelection",                    "Object" ],
+            [ "MSStyleCSSProperties",           "MSCSSProperties" ],
+            [ "NamedNodeMap",                   "Object" ],
+            [ "Navigator",                      "Object" ],
+            [ "Node",                           "Object" ],
+            [ "NodeList",                       "Object" ],
+            [ "Option",                         "HTMLElement" ],
+            [ "Performance",                    "Object" ],
+            [ "PerformanceNavigation",          "Object" ],
+            [ "PerformanceTiming",              "Object" ],
+            [ "PluginArray",                    "Object" ],
+            [ "Screen",                         "Object" ],
+            [ "Storage",                        "Object" ],
+            [ "StyleSheet",                     "Object" ],
+            [ "StyleSheetList",                 "Object" ],
+            [ "SubtleCrypto",                   "Object" ],
+            [ "Text",                           "CharacterData" ],
+            [ "TextRange",                      "Object" ],
+            [ "UIEvent",                        "Event" ],
+            [ "Window",                         "Object" ],
+            [ "XMLDocument",                    "Document" ],
+            [ "XMLHttpRequest",                 "Object" ]
+        ];
+
+        for(var i = 0; i < protos.length; i++) {
+            if(!(protos[i][0] in window))
+                continue;
+            var a, b;
+            eval("a = Object.getPrototypeOf(" + protos[i][0] + ".prototype); b = " + protos[i][1] + ".prototype;");
+            ok(a === b, "getPrototypeOf(" + protos[i][0] + ".prototype) = " + a);
+        }
+
+        var CSS_props = [ "accelerator","backgroundPositionX","backgroundPositionY","getAttribute","imeMode","layoutFlow","layoutGrid","layoutGridChar",
+                          "layoutGridLine","layoutGridMode","layoutGridType","lineBreak","msBlockProgression","msInterpolationMode","removeAttribute",
+                          "scrollbar3dLightColor","scrollbarArrowColor","scrollbarBaseColor","scrollbarDarkShadowColor","scrollbarFaceColor",
+                          "scrollbarHighlightColor","scrollbarShadowColor","scrollbarTrackColor","setAttribute","styleFloat","textAutospace",
+                          "textJustifyTrim","textKashida","textKashidaSpace","writingMode","zoom" ];
+        var Elem_props = [ "clientHeight","clientLeft","clientTop","clientWidth","firstElementChild","getAttribute","getAttributeNode","getAttributeNodeNS",
+                           "getAttributeNS","getBoundingClientRect","getClientRects","getElementsByTagName","getElementsByTagNameNS","hasAttribute",
+                           "hasAttributeNS","lastElementChild","msMatchesSelector","nextElementSibling","previousElementSibling","querySelector",
+                           "removeAttribute","removeAttributeNode","removeAttributeNS","scrollHeight","scrollLeft","scrollTop","scrollWidth","setAttribute",
+                           "setAttributeNode","setAttributeNodeNS","setAttributeNS","tagName" ];
+        var Event_props = [ "bubbles","cancelable","cancelBubble","currentTarget","defaultPrevented","eventPhase","initEvent","isTrusted",
+                            "preventDefault","srcElement","stopImmediatePropagation","stopPropagation","target","timeStamp","type" ];
+        var HtmlElem_props = [ "accessKey","applyElement","blur","canHaveHTML","children","className","clearAttributes","click","componentFromPoint",
+                               "contains","contentEditable","createControlRange","currentStyle","dir","disabled","dragDrop","focus","getAdjacentText",
+                               "getElementsByClassName","hideFocus","id","innerHTML","innerText","insertAdjacentElement","insertAdjacentHTML",
+                               "insertAdjacentText","isContentEditable","isDisabled","isMultiLine","isTextEdit","lang","language","mergeAttributes",
+                               "offsetHeight","offsetLeft","offsetParent","offsetTop","offsetWidth","onabort","onactivate","onbeforeactivate","onbeforecopy",
+                               "onbeforecut","onbeforedeactivate","onbeforepaste","onblur","oncanplay","oncanplaythrough","onchange","onclick",
+                               "oncontextmenu","oncopy","oncut","ondblclick","ondeactivate","ondrag","ondragend","ondragenter","ondragleave","ondragover",
+                               "ondragstart","ondrop","ondurationchange","onemptied","onended","onerror","onfocus","onfocusin","onfocusout","onhelp",
+                               "oninput","onkeydown","onkeypress","onkeyup","onload","onloadeddata","onloadedmetadata","onloadstart","onmousedown",
+                               "onmouseleave","onmousemove","onmouseout","onmouseover","onmouseup","onmousewheel","onpaste","onpause","onplay","onplaying",
+                               "onprogress","onratechange","onreset","onscroll","onseeked","onseeking","onselect","onselectstart","onstalled","onsubmit",
+                               "onsuspend","ontimeupdate","onvolumechange","onwaiting","outerHTML","outerText","parentElement","parentTextEdit",
+                               "recordNumber","releaseCapture","replaceAdjacentText","runtimeStyle","scrollIntoView","setActive","setCapture","sourceIndex",
+                               "style","tabIndex","title","uniqueID","uniqueNumber" ];
+        var Node_props = [ "addEventListener","appendChild","attributes","childNodes","cloneNode","compareDocumentPosition","dispatchEvent","firstChild",
+                           "hasChildNodes","insertBefore","isDefaultNamespace","isEqualNode","isSameNode","isSupported","lastChild","localName",
+                           "lookupNamespaceURI","lookupPrefix","namespaceURI","nextSibling","nodeName","nodeType","nodeValue","ownerDocument",
+                           "parentNode","prefix","previousSibling","removeChild","removeEventListener","replaceChild","textContent" ];
+        var TableCell_props = [ "align","background","bgColor","borderColor","borderColorDark","borderColorLight","cellIndex","colSpan","height","noWrap",
+                                "rowSpan","vAlign","width" ];
+
+        protos = [
+            [ "Attr", ["expando","name","specified","value"], Node_props ],
+            [ "CharacterData", ["data","length","appendData"], Node_props ],
+            [ "Comment", ["text"], ["insertData","replaceData","substringData"] ],
+            [ "CSSStyleRule", ["readOnly","selectorText","style"], ["cssText","parentRule","parentStyleSheet","type" ] ],
+            [ "CSSStyleSheet", ["addRule","cssRules","ownerRule","rules"], ["disabled","media","ownerNode","parentStyleSheet","title","type"] ],
+            [ "CustomEvent", ["detail","initCustomEvent"], Event_props ],
+            [ "Document", ["body","doctype","documentMode","onactivate","parentWindow","styleSheets","title"], Node_props ],
+            [ "Element", Elem_props, Node_props ],
+            [ "HTMLElement", HtmlElem_props, Elem_props ],
+            [ "HTMLTableCellElement", TableCell_props, HtmlElem_props ],
+            [ "HTMLTableDataCellElement", [], TableCell_props ],
+            [ "HTMLUnknownElement", ["recordset","namedRecordset"], HtmlElem_props ],
+            [ "KeyboardEvent", ["altKey","ctrlKey","getModifierState","initKeyboardEvent","key","metaKey"], ["detail","initUIEvent","view"] ],
+            [ "MessageEvent", ["data","initMessageEvent","origin","source"], Event_props ],
+            [ "MouseEvent", ["button","clientX","initMouseEvent","offsetY","pageX","shiftKey","x","y"], ["detail","initUIEvent","view"] ],
+            [ "MSCSSProperties", CSS_props, ["background","border","clip","fontWeight","listStyle","quotes","setProperty","zIndex"] ],
+            [ "MSCurrentStyleCSSProperties", ["blockDirection","clipBottom","clipLeft","clipRight","clipTop","hasLayout"], CSS_props ],
+            [ "MSStyleCSSProperties", ["pixelTop","pixelWidth","posHeight","posLeft","textDecorationBlink","textDecorationNone"], CSS_props ],
+            [ "Text", ["splitText"], ["data","length","appendData","deleteData","insertData","replaceData","substringData"] ],
+            [ "UIEvent", ["detail","initUIEvent","view"], Event_props ]
+        ];
+
+        for(var i = 0; i < protos.length; i++) {
+            eval("r = " + protos[i][0] + ".prototype");
+            for(var j = 0; j < protos[i][1].length; j++)
+                ok(Object.prototype.hasOwnProperty.call(r, protos[i][1][j]), protos[i][1][j] + " not a property of " + protos[i][0] + ".prototype");
+            for(var j = 0; j < protos[i][2].length; j++) {
+                ok(!Object.prototype.hasOwnProperty.call(r, protos[i][2][j]), protos[i][2][j] + " is a property of " + protos[i][0] + ".prototype");
+                ok(protos[i][2][j] in r, protos[i][2][j] + " not in " + protos[i][0] + ".prototype");
+            }
+        }
+    }
+});
+
 sync_test("elem_props", function() {
     var elem = document.documentElement;
 
@@ -300,6 +1390,83 @@ sync_test("elem_props", function() {
     test_exposed("classList", v >= 10);
 });
 
+sync_test("attr_props", function() {
+    var elem = document.createElement("style"), attr;
+    var v = document.documentMode;
+    elem.setAttribute("id", "test");
+    elem.setAttribute("test", "wine");
+    elem.setAttribute("z-index", "foobar");
+    elem.setAttribute("removeAttribute", "funcattr");
+
+    function test_exposed(prop, expect) {
+        if(expect)
+            ok(prop in attr, prop + " not found in attribute.");
+        else
+            ok(!(prop in attr), prop + " found in attribute.");
+    }
+
+    function test_attr(expando, specified) {
+        var r = attr.expando;
+        ok(r === expando, attr.name + " attr.expando = " + r);
+        r = attr.specified;
+        ok(r === specified, attr.name + " attr.specified = " + r);
+    }
+
+    attr = elem.getAttributeNode("id");
+    test_exposed("appendChild", true);
+    test_exposed("attributes", true);
+    test_exposed("childNodes", true);
+    test_exposed("cloneNode", true);
+    test_exposed("compareDocumentPosition", v >= 9);
+    test_exposed("expando", true);
+    test_exposed("firstChild", true);
+    test_exposed("hasChildNodes", true);
+    test_exposed("insertBefore", true);
+    test_exposed("isDefaultNamespace", v >= 9);
+    test_exposed("isEqualNode", v >= 9);
+    test_exposed("isSameNode", v >= 9);
+    test_exposed("isSupported", v >= 9);
+    test_exposed("lastChild", true);
+    test_exposed("localName", v >= 9);
+    test_exposed("lookupNamespaceURI", v >= 9);
+    test_exposed("lookupPrefix", v >= 9);
+    test_exposed("name", true);
+    test_exposed("namespaceURI", v >= 9);
+    test_exposed("nextSibling", true);
+    test_exposed("nodeName", true);
+    test_exposed("nodeType", true);
+    test_exposed("nodeValue", true);
+    test_exposed("ownerDocument", true);
+    test_exposed("parentNode", true);
+    test_exposed("prefix", v >= 9);
+    test_exposed("previousSibling", true);
+    test_exposed("removeChild", true);
+    test_exposed("replaceChild", true);
+    test_exposed("specified", true);
+    test_exposed("textContent", v >= 9);
+    test_exposed("value", true);
+    test_attr(false, true);
+
+    attr = elem.getAttributeNode("test");
+    test_attr(true, true);
+
+    attr = elem.getAttributeNode("z-index");
+    test_attr(true, true);
+
+    attr = elem.getAttributeNode("removeAttribute");
+    test_attr(true, true);
+
+    attr = elem.getAttributeNode("tabIndex");
+    if(v < 8)
+        test_attr(false, false);
+    else
+        todo_wine_if(v === 8).
+        ok(attr === null, "tabIndex attr not null.");
+
+    attr = document.createAttribute("winetest");
+    test_attr(false, v >= 9);
+});
+
 sync_test("doc_props", function() {
     function test_exposed(prop, expect) {
         if(expect)
@@ -309,6 +1476,7 @@ sync_test("doc_props", function() {
     }
 
     var v = document.documentMode;
+    ok(document.mimeType === "HTML Document", "mimeType = " + document.mimeType);
 
     test_exposed("textContent", v >= 9);
     test_exposed("prefix", v >= 9);
@@ -357,11 +1525,31 @@ sync_test("window_props", function() {
     test_exposed("getSelection", v >= 9);
     test_exposed("onfocusout", v >= 9);
     test_exposed("getComputedStyle", v >= 9);
+    test_exposed("cancelAnimationFrame", v >= 10);
     test_exposed("requestAnimationFrame", v >= 10);
     test_exposed("Map", v >= 11);
     test_exposed("Set", v >= 11);
     test_exposed("performance", true);
     test_exposed("console", v >= 10);
+    test_exposed("msCrypto", v >= 11);
+    test_exposed("DOMParser", v >= 9);
+});
+
+sync_test("domimpl_props", function() {
+    var domimpl = document.implementation;
+    function test_exposed(prop, expect) {
+        if(expect)
+            ok(prop in domimpl, prop + " not found in DOMImplementation.");
+        else
+            ok(!(prop in domimpl), prop + " found in DOMImplementation.");
+    }
+
+    var v = document.documentMode;
+
+    test_exposed("hasFeature", true);
+    test_exposed("createDocument", v >= 9);
+    test_exposed("createDocumentType", v >= 9);
+    test_exposed("createHTMLDocument", v >= 9);
 });
 
 sync_test("xhr_props", function() {
@@ -466,10 +1654,21 @@ sync_test("style_props", function() {
     test_exposed("float", true);
     test_exposed("css-float", false);
     test_exposed("style-float", false);
+    test_exposed("styleFloat", true);
     test_exposed("setProperty", v >= 9);
     test_exposed("removeProperty", v >= 9);
     test_exposed("background-clip", v >= 9);
     test_exposed("transform", v >= 10);
+    test_exposed("zoom", true);
+
+    try {
+        style.styleFloat = "left";
+        ok(false, "expected exception setting styleFloat");
+    }catch(ex) {}
+    try {
+        style.zoom = "1.0";
+        ok(false, "expected exception setting zoom");
+    }catch(ex) {}
 
     if(window.getComputedStyle) {
         style = window.getComputedStyle(document.body);
@@ -488,6 +1687,86 @@ sync_test("style_props", function() {
     }
 });
 
+sync_test("input_validation_props", function() {
+    var obj, v = document.documentMode;
+    if(v < 9) return;
+
+    function test_exposed(prop, expect) {
+        if(expect)
+            ok(Object.prototype.hasOwnProperty.call(obj, prop), prop + " not a property of " + obj);
+        else
+            ok(!Object.prototype.hasOwnProperty.call(obj, prop), prop + " is a property of " + obj);
+    }
+
+    obj = window.HTMLFormElement.prototype;
+    test_exposed("action", true);
+    test_exposed("autofocus", false);
+    test_exposed("checkValidity", v >= 10);
+    test_exposed("enctype", true);
+    test_exposed("formAction", false);
+    test_exposed("formEnctype", false);
+    test_exposed("formMethod", false);
+    test_exposed("formNoValidate", false);
+    test_exposed("formTarget", false);
+    test_exposed("method", true);
+    test_exposed("noValidate", v >= 10);
+    test_exposed("setCustomValidity", false);
+    test_exposed("target", true);
+    test_exposed("validationMessage", false);
+    test_exposed("validity", false);
+    test_exposed("willValidate", false);
+
+    obj = window.HTMLInputElement.prototype;
+    test_exposed("autofocus", v >= 10);
+    test_exposed("checkValidity", v >= 10);
+    test_exposed("formAction", v >= 10);
+    test_exposed("formEnctype", v >= 10);
+    test_exposed("formMethod", v >= 10);
+    test_exposed("formNoValidate", v >= 10);
+    test_exposed("formTarget", v >= 10);
+    test_exposed("setCustomValidity", v >= 10);
+    test_exposed("validationMessage", v >= 10);
+    test_exposed("validity", v >= 10);
+    test_exposed("willValidate", v >= 10);
+
+    obj = window.HTMLButtonElement.prototype;
+    test_exposed("autofocus", v >= 10);
+    test_exposed("checkValidity", v >= 10);
+    test_exposed("formAction", v >= 10);
+    test_exposed("formEnctype", v >= 10);
+    test_exposed("formMethod", v >= 10);
+    test_exposed("formNoValidate", v >= 10);
+    test_exposed("formTarget", v >= 10);
+    test_exposed("setCustomValidity", v >= 10);
+    test_exposed("validationMessage", v >= 10);
+    test_exposed("validity", v >= 10);
+    test_exposed("willValidate", v >= 10);
+
+    obj = window.HTMLObjectElement.prototype;
+    test_exposed("autofocus", false);
+    test_exposed("checkValidity", v >= 10);
+    test_exposed("setCustomValidity", v >= 10);
+    test_exposed("validationMessage", v >= 10);
+    test_exposed("validity", v >= 10);
+    test_exposed("willValidate", v >= 10);
+
+    obj = window.HTMLSelectElement.prototype;
+    test_exposed("autofocus", v >= 10);
+    test_exposed("checkValidity", v >= 10);
+    test_exposed("setCustomValidity", v >= 10);
+    test_exposed("validationMessage", v >= 10);
+    test_exposed("validity", v >= 10);
+    test_exposed("willValidate", v >= 10);
+
+    obj = window.HTMLTextAreaElement.prototype;
+    test_exposed("autofocus", v >= 10);
+    test_exposed("checkValidity", v >= 10);
+    test_exposed("setCustomValidity", v >= 10);
+    test_exposed("validationMessage", v >= 10);
+    test_exposed("validity", v >= 10);
+    test_exposed("willValidate", v >= 10);
+});
+
 sync_test("createElement_inline_attr", function() {
     var v = document.documentMode, e, s;
 
@@ -736,7 +2015,7 @@ sync_test("navigator", function() {
 
 sync_test("delete_prop", function() {
     var v = document.documentMode;
-    var obj = document.createElement("div"), r, obj2;
+    var obj = document.createElement("div"), r, obj2, func, prop;
 
     obj.prop1 = true;
     r = false;
@@ -752,6 +2031,40 @@ sync_test("delete_prop", function() {
     ok(!r, "got an unexpected exception");
     ok(!("prop1" in obj), "prop1 is still in obj");
 
+    /* builtin properties don't throw any exception, but are not really deleted */
+    r = (delete obj.tagName);
+    ok(r, "delete returned " + r);
+    ok("tagName" in obj, "tagName deleted from obj");
+    ok(obj.tagName === "DIV", "tagName = " + obj.tagName);
+
+    prop = obj.id;
+    r = (delete obj.id);
+    ok(r, "delete returned " + r);
+    ok("id" in obj, "id deleted from obj");
+    ok(obj.id === prop, "id = " + obj.id);
+
+    obj.id = "1234";
+    ok(obj.id === "1234", "id after set to 1234 = " + obj.id);
+    r = (delete obj.id);
+    ok(r, "delete returned " + r);
+    ok("id" in obj, "id deleted from obj");
+    ok(obj.id === "1234", "id = " + obj.id);
+
+    /* builtin functions get reset to their original values */
+    func = function() { }
+    prop = obj.setAttribute;
+    r = (delete obj.setAttribute);
+    ok(r, "delete returned " + r);
+    ok("setAttribute" in obj, "setAttribute deleted from obj");
+    ok(obj.setAttribute === prop, "setAttribute = " + obj.setAttribute);
+
+    obj.setAttribute = func;
+    ok(obj.setAttribute === func, "setAttribute after set to func = " + obj.setAttribute);
+    r = (delete obj.setAttribute);
+    ok(r, "delete returned " + r);
+    ok("setAttribute" in obj, "setAttribute deleted from obj");
+    ok(obj.setAttribute === prop, "setAttribute = " + obj.setAttribute);
+
     /* again, this time prop1 does not exist */
     r = false;
     try {
@@ -772,12 +2085,6 @@ sync_test("delete_prop", function() {
     ok("className" in obj, "className deleted from obj");
     ok(obj.className === "", "className = " + obj.className);
 
-    /* builtin propertiles don't throw any exception, but are not really deleted */
-    r = (delete obj.tagName);
-    ok(r, "delete returned " + r);
-    ok("tagName" in obj, "tagName deleted from obj");
-    ok(obj.tagName === "DIV", "tagName = " + obj.tagName);
-
     obj = document.querySelectorAll("*");
     ok("0" in obj, "0 is not in obj");
     obj2 = obj[0];
@@ -815,7 +2122,6 @@ sync_test("delete_prop", function() {
         ok(r, "did not get an expected globalprop2 exception");
     }else {
         ok(!r, "got an unexpected exception");
-        todo_wine.
         ok(!("globalprop2" in obj), "globalprop2 is still in obj");
     }
 
@@ -839,7 +2145,6 @@ sync_test("delete_prop", function() {
     ok(obj.globalprop4, "globalprop4 = " + globalprop4);
     r = (delete globalprop4);
     ok(r, "delete returned " + r);
-    todo_wine.
     ok(!("globalprop4" in obj), "globalprop4 is still in obj");
 });
 
@@ -1246,11 +2551,10 @@ sync_test("elem_attr", function() {
     var func = elem.setAttribute;
     try {
         func("testattr", arr);
-        todo_wine_if(v >= 9).
         ok(v < 9, "expected exception setting testattr via func");
     }catch(ex) {
         ok(v >= 9, "did not expect exception setting testattr via func");
-        elem.setAttribute("testattr", arr);
+        func.call(elem, "testattr", arr);
     }
     r = elem.getAttribute("testattr");
     ok(r === (v < 8 ? arr : (v < 10 ? "arrval" : "42")), "testattr after setAttribute (as func) = " + r);
@@ -1453,6 +2757,339 @@ sync_test("nullDisp", function() {
     }
 });
 
+sync_test("elem_attrNS", function() {
+    var v = document.documentMode;
+    if(v < 9) return;  /* not available */
+
+    var specialspace_ns = "http://www.mozilla.org/ns/specialspace";
+    var svg_ns = "http://www.w3.org/2000/svg";
+
+    var elem = document.createElement("div"), r;
+
+    elem.setAttributeNS(specialspace_ns, "spec:align", "left");
+    r = elem.hasAttribute("spec:align");
+    ok(r === true, "spec:align does not exist");
+    r = elem.getAttribute("spec:align");
+    ok(r === "left", "spec:align = " + r);
+    r = elem.hasAttribute("align");
+    ok(r === false, "align exists");
+    r = elem.getAttribute("align");
+    ok(r === null, "align = " + r);
+    r = elem.hasAttributeNS(null, "spec:align");
+    ok(r === false, "null spec:align exists");
+    r = elem.getAttributeNS(null, "spec:align");
+    ok(r === "", "null spec:align = " + r);
+    r = elem.hasAttributeNS(null, "spec:align");
+    ok(r === false, "null align exists");
+    r = elem.getAttributeNS(null, "align");
+    ok(r === "", "null align = " + r);
+    r = elem.hasAttributeNS(svg_ns, "spec:align");
+    ok(r === false, "svg spec:align exists");
+    r = elem.getAttributeNS(svg_ns, "spec:align");
+    ok(r === "", "svg spec:align = " + r);
+    r = elem.hasAttributeNS(svg_ns, "align");
+    ok(r === false, "svg align exists");
+    r = elem.getAttributeNS(svg_ns, "align");
+    ok(r === "", "svg align = " + r);
+    r = elem.hasAttributeNS(specialspace_ns, "spec:align");
+    ok(r === false, "specialspace spec:align exists");
+    r = elem.getAttributeNS(specialspace_ns, "spec:align");
+    ok(r === "", "specialspace spec:align = " + r);
+    r = elem.hasAttributeNS(specialspace_ns, "align");
+    ok(r === true, "specialspace align does not exist");
+    r = elem.getAttributeNS(specialspace_ns, "align");
+    ok(r === "left", "specialspace align = " + r);
+
+    try {
+        elem.setAttributeNS(null, "spec:align", "right");
+        ok(false, "expected exception setting qualified attr with null ns");
+    }catch(ex) {
+        todo_wine.
+        ok(ex.message === "NamespaceError", "setAttributeNS(null, 'spec:align', 'right') threw " + ex.message);
+    }
+    try {
+        elem.setAttributeNS("", "spec:align", "right");
+        ok(false, "expected exception setting qualified attr with empty ns");
+    }catch(ex) {
+        todo_wine.
+        ok(ex.message === "NamespaceError", "setAttributeNS('', 'spec:align', 'right') threw " + ex.message);
+    }
+    elem.setAttributeNS(null, "align", "right");
+    r = elem.getAttribute("spec:align");
+    ok(r === "left", "spec:align (null) = " + r);
+    r = elem.hasAttribute("align");
+    ok(r === true, "align (null) does not exist");
+    r = elem.getAttribute("align");
+    ok(r === "right", "align (null) = " + r);
+    r = elem.hasAttributeNS(null, "spec:align");
+    ok(r === false, "null spec:align exists");
+    r = elem.getAttributeNS(null, "spec:align");
+    ok(r === "", "null spec:align (null) = " + r);
+    r = elem.hasAttributeNS(null, "align");
+    ok(r === true, "null align does not exist");
+    r = elem.getAttributeNS(null, "align");
+    ok(r === "right", "null align (null) = " + r);
+    r = elem.hasAttributeNS(svg_ns, "spec:align");
+    ok(r === false, "svg spec:align (null) exists");
+    r = elem.getAttributeNS(svg_ns, "spec:align");
+    ok(r === "", "svg spec:align (null) = " + r);
+    r = elem.hasAttributeNS(svg_ns, "align");
+    ok(r === false, "svg align (null) exists");
+    r = elem.getAttributeNS(svg_ns, "align");
+    ok(r === "", "svg align (null) = " + r);
+    r = elem.hasAttributeNS(specialspace_ns, "spec:align");
+    ok(r === false, "specialspace_ns spec:align (null) exists");
+    r = elem.getAttributeNS(specialspace_ns, "spec:align");
+    ok(r === "", "specialspace spec:align (null) = " + r);
+    r = elem.hasAttributeNS(specialspace_ns, "align");
+    ok(r === true, "specialspace align (null) does not exist");
+    r = elem.getAttributeNS(specialspace_ns, "align");
+    ok(r === "left", "specialspace align (null) = " + r);
+
+    elem.setAttribute("align", "center");
+    r = elem.hasAttributeNS(null, "spec:align");
+    ok(r === false, "null spec:align (non-NS) exists");
+    r = elem.getAttributeNS(null, "spec:align");
+    ok(r === "", "null spec:align (non-NS) = " + r);
+    r = elem.hasAttributeNS(null, "align");
+    ok(r === true, "null align (non-NS) does not exist");
+    r = elem.getAttributeNS(null, "align");
+    ok(r === "center", "null align (non-NS) = " + r);
+    r = elem.hasAttributeNS(svg_ns, "spec:align");
+    ok(r === false, "svg spec:align (non-NS) exists");
+    r = elem.getAttributeNS(svg_ns, "spec:align");
+    ok(r === "", "svg spec:align (non-NS) = " + r);
+    r = elem.hasAttributeNS(svg_ns, "align");
+    ok(r === false, "svg align (non-NS) exists");
+    r = elem.getAttributeNS(svg_ns, "align");
+    ok(r === "", "svg align (non-NS) = " + r);
+    r = elem.hasAttributeNS(specialspace_ns, "spec:align");
+    ok(r === false, "specialspace spec:align (non-NS) exists");
+    r = elem.getAttributeNS(specialspace_ns, "spec:align");
+    ok(r === "", "specialspace spec:align (non-NS) = " + r);
+    r = elem.hasAttributeNS(specialspace_ns, "align");
+    ok(r === true, "specialspace align (non-NS) does not exist");
+    r = elem.getAttributeNS(specialspace_ns, "align");
+    ok(r === "left", "specialspace align (non-NS) = " + r);
+    elem.removeAttributeNS(null, "spec:align");
+
+    elem.setAttribute("emptynsattr", "none");
+    elem.setAttributeNS("", "emptynsattr", "test");
+    r = elem.hasAttribute("emptynsattr");
+    ok(r === true, "emptynsattr without NS does not exist");
+    r = elem.getAttribute("emptynsattr");
+    ok(r === "test", "emptynsattr without NS = " + r);
+    elem.setAttributeNS(null, "emptynsattr", "wine");
+    r = elem.hasAttribute("emptynsattr");
+    ok(r === true, "emptynsattr without NS does not exist");
+    r = elem.getAttribute("emptynsattr");
+    ok(r === "wine", "emptynsattr without NS = " + r);
+    elem.setAttributeNS(specialspace_ns, "emptynsattr", "ns");
+    r = elem.hasAttribute("emptynsattr");
+    ok(r === true, "emptynsattr without NS does not exist");
+    r = elem.getAttribute("emptynsattr");
+    ok(r === "wine", "emptynsattr without NS = " + r);
+    r = elem.hasAttributeNS("", "emptynsattr");
+    ok(r === true, "emptynsattr empty ns does not exist");
+    r = elem.getAttributeNS("", "emptynsattr");
+    ok(r === "wine", "emptynsattr empty ns = " + r);
+    r = elem.hasAttributeNS(null, "emptynsattr");
+    ok(r === true, "emptynsattr null ns does not exist");
+    r = elem.getAttributeNS(null, "emptynsattr");
+    ok(r === "wine", "emptynsattr null ns = " + r);
+    r = elem.hasAttributeNS(specialspace_ns, "emptynsattr");
+    ok(r === true, "emptynsattr specialspace ns does not exist");
+    r = elem.getAttributeNS(specialspace_ns, "emptynsattr");
+    ok(r === "ns", "emptynsattr specialspace ns = " + r);
+
+    elem.removeAttributeNS("", "emptynsattr");
+    r = elem.hasAttribute("emptynsattr");
+    ok(r === true, "emptynsattr without NS after remove does not exist");
+    r = elem.getAttribute("emptynsattr");
+    ok(r === "ns", "emptynsattr without NS after remove = " + r);
+    r = elem.hasAttributeNS(specialspace_ns, "emptynsattr");
+    ok(r === true, "emptynsattr specialspace ns after empty remove does not exist");
+    r = elem.getAttributeNS(specialspace_ns, "emptynsattr");
+    ok(r === "ns", "emptynsattr specialspace ns after empty remove = " + r);
+    elem.setAttribute("emptynsattr", "test");
+    r = elem.getAttribute("emptynsattr");
+    ok(r === "test", "emptynsattr without NS after re-set = " + r);
+    r = elem.getAttributeNS(specialspace_ns, "emptynsattr");
+    ok(r === "test", "emptynsattr specialspace ns after empty re-set = " + r);
+
+    elem.removeAttribute("emptynsattr");
+    r = elem.hasAttribute("emptynsattr");
+    ok(r === false, "emptynsattr without NS after non-NS remove exists");
+    r = elem.getAttribute("emptynsattr");
+    ok(r === null, "emptynsattr without NS after non-NS remove = " + r);
+    r = elem.hasAttributeNS(specialspace_ns, "emptynsattr");
+    ok(r === false, "emptynsattr specialspace ns after non-NS remove exists");
+    r = elem.getAttributeNS(specialspace_ns, "emptynsattr");
+    ok(r === "", "emptynsattr specialspace ns after non-NS remove = " + r);
+
+    elem.setAttributeNS(specialspace_ns, "emptynsattr", "ns");
+    elem.removeAttributeNS(svg_ns, "emptynsattr");
+    r = elem.hasAttributeNS(specialspace_ns, "emptynsattr");
+    ok(r === true, "emptynsattr specialspace ns after wrong NS remove does not exist");
+    r = elem.getAttributeNS(specialspace_ns, "emptynsattr");
+    ok(r === "ns", "emptynsattr specialspace ns after wrong NS remove = " + r);
+    r = elem.hasAttributeNS(specialspace_ns, "emptynsattr");
+    ok(r === true, "emptynsattr specialspace ns after remove does not exist");
+    r = elem.getAttributeNS(specialspace_ns, "emptynsattr");
+    ok(r === "ns", "emptynsattr specialspace ns after remove = " + r);
+
+    var ns = {};
+    ns.toString = function() { return "toString namespace"; }
+    ns.valueOf = function() { return "valueOf namespace"; }
+    elem.setAttributeNS(ns, "foobar", "test");
+    r = elem.hasAttribute("foobar");
+    ok(r === true, "foobar without NS does not exist");
+    r = elem.getAttribute("foobar");
+    ok(r === "test", "foobar without NS = " + r);
+    r = elem.hasAttributeNS(ns, "foobar");
+    ok(r === true, "foobar does not exist");
+    r = elem.getAttributeNS(ns, "foobar");
+    ok(r === "test", "foobar = " + r);
+    r = elem.hasAttributeNS("toString namespace", "foobar");
+    ok(r === (v < 10 ? false : true), "foobar (toString namespace) " + (v < 10 ? "exists" : "does not exist"));
+    r = elem.getAttributeNS("toString namespace", "foobar");
+    ok(r === (v < 10 ? "" : "test"), "foobar (toString namespace) = " + r);
+    r = elem.hasAttributeNS("valueOf namespace", "foobar");
+    ok(r === (v < 10 ? true : false), "foobar (valueOf namespace) = " + (v < 10 ? "does not exist" : "exists"));
+    r = elem.getAttributeNS("valueOf namespace", "foobar");
+    ok(r === (v < 10 ? "test" : ""), "foobar (valueOf namespace) = " + r);
+
+    var arr = [3];
+    elem.setAttributeNS(svg_ns, "testattr", arr);
+    r = elem.getAttributeNS(svg_ns, "testattr");
+    ok(r === "3", "testattr = " + r);
+    ok(elem.testattr === undefined, "elem.testattr = " + elem.testattr);
+    elem.removeAttributeNS(svg_ns, "testattr");
+    r = elem.getAttributeNS(svg_ns, "testattr");
+    ok(r === "", "testattr after remove = " + r);
+
+    arr.toString = function() { return 42; }
+    elem.setAttributeNS(svg_ns, "testattr", arr);
+    r = elem.getAttributeNS(svg_ns, "testattr");
+    ok(r === "42", "testattr with custom toString = " + r);
+    elem.removeAttributeNS(svg_ns, "testattr");
+    r = elem.getAttributeNS(svg_ns, "testattr");
+    ok(r === "", "testattr with custom toString after remove = " + r);
+
+    arr.valueOf = function() { return "arrval"; }
+    elem.setAttributeNS(svg_ns, "testattr", arr);
+    r = elem.getAttributeNS(svg_ns, "testattr");
+    ok(r === "42", "testattr with custom valueOf = " + r);
+    elem.removeAttributeNS(svg_ns, "testattr");
+
+    elem.setAttributeNS(svg_ns, "boolattr", true);
+    r = elem.getAttributeNS(svg_ns, "boolattr");
+    ok(r === "true", "boolattr = " + r);
+
+    elem.setAttributeNS(svg_ns, "numattr", 13);
+    r = elem.getAttributeNS(svg_ns, "numattr");
+    ok(r === "13", "numattr = " + r);
+});
+
+sync_test("builtins_diffs", function() {
+    var v = document.documentMode;
+
+    /* despite what spec says for ES6, IE still throws */
+    var props = [
+        "freeze",
+        "getPrototypeOf",
+        "isExtensible",
+        "isFrozen",
+        "isSealed",
+        "keys",
+        "preventExtensions",
+        "seal"
+    ];
+    for(var i = 0; i < props.length; i++) {
+        try {
+            Object[props[i]]("test");
+            ok(false, "Object." + props[i] + " with non-object: expected exception");
+        }catch(e) {
+            ok(e.number === (v < 9 ? 0xa01b6 : 0xa138f) - 0x80000000, "Object." + props[i] + " with non-object: exception = " + e.number);
+        }
+    }
+
+    try {
+        RegExp.prototype.toString.call({source: "foo", flags: "g"});
+        ok(false, "RegExp.toString with non-regexp: expected exception");
+    }catch(e) {
+        ok(e.number === 0xa1398 - 0x80000000, "RegExp.toString with non-regexp: exception = " + e.number);
+    }
+
+    try {
+        /a/.lastIndex();
+        ok(false, "/a/.lastIndex(): expected exception");
+    }catch(e) {
+        ok(e.number === 0xa138a - 0x80000000, "/a/.lastIndex(): exception = " + e.number);
+    }
+    try {
+        "a".length();
+        ok(false, "\"a\".length(): expected exception");
+    }catch(e) {
+        ok(e.number === 0xa138a - 0x80000000, "\"a\".length(): exception = " + e.number);
+    }
+});
+
+sync_test("nullDisp", function() {
+    var v = document.documentMode, nullDisp = external.nullDisp, r;
+
+    ok(external.getVT(nullDisp) === "VT_NULL", "getVT(nullDisp) is not VT_NULL");
+    ok(typeof(nullDisp) === "object", "typeof(nullDisp) = " + typeof(nullDisp));
+    ok(nullDisp === nullDisp, "nullDisp !== nullDisp");
+    ok(nullDisp === null, "nullDisp === null");
+    ok(nullDisp == null, "nullDisp == null");
+    ok(!nullDisp === true, "!nullDisp = " + !nullDisp);
+    ok(String(nullDisp) === "null", "String(nullDisp) = " + String(nullDisp));
+    ok(+nullDisp === 0, "+nullDisp !== 0");
+    ok(''+nullDisp === "null", "''+nullDisp !== null");
+    ok(nullDisp != new Object(), "nullDisp == new Object()");
+    ok(new Object() != nullDisp, "new Object() == nullDisp");
+    ok((typeof Object(nullDisp)) === "object", "typeof Object(nullDisp) !== 'object'");
+    r = Object(nullDisp).toString();
+    ok(r === "[object Object]", "Object(nullDisp).toString() = " + r);
+    ok(Object(nullDisp) != nullDisp, "Object(nullDisp) == nullDisp");
+    ok(new Object(nullDisp) != nullDisp, "new Object(nullDisp) == nullDisp");
+    r = (nullDisp instanceof Object);
+    ok(r === false, "nullDisp instance of Object");
+
+    if(v >= 8) {
+        r = JSON.stringify.call(null, nullDisp);
+        ok(r === "null", "JSON.stringify(nullDisp) returned " + r);
+    }
+
+    try {
+        (new Object()) instanceof nullDisp;
+        ok(false, "expected exception on (new Object()) instanceof nullDisp");
+    }catch(e) {
+        ok(e.number === 0xa138a - 0x80000000, "(new Object()) instanceof nullDisp threw " + e.number);
+    }
+
+    try {
+        Function.prototype.apply.call(nullDisp, Object, []);
+        ok(false, "expected exception calling Function.apply on nullDisp");
+    }catch(e) {
+        ok(e.number === 0xa138a - 0x80000000, "Function.apply on nullDisp threw " + e.number);
+    }
+    try {
+        Function.prototype.call.call(nullDisp, Object);
+        ok(false, "expected exception calling Function.call on nullDisp");
+    }catch(e) {
+        ok(e.number === 0xa138a - 0x80000000, "Function.call on nullDisp threw " + e.number);
+    }
+
+    try {
+        new nullDisp;
+        ok(false, "expected exception for new nullDisp");
+    }catch(e) {
+        ok(e.number === 0xa138f - 0x80000000, "new nullDisp threw " + e.number);
+    }
+});
+
 sync_test("__proto__", function() {
     var v = document.documentMode;
     var r, x = 42;
@@ -1588,6 +3225,13 @@ sync_test("__proto__", function() {
         ok(e.number === 0xa13b6 - 0x80000000 && e.name === "TypeError",
             "changing __proto__ on non-extensible object threw exception " + e.number + " (" + e.name + ")");
     }
+
+    obj = document.createElement("img");
+    obj.__proto__ = ctor.prototype;
+    document.body.setAttribute.call(obj, "height", "101");
+    r = document.body.getAttribute.call(obj, "height");
+    ok(r === "101", "getAttribute(height) = " + r);
+    ok(!("getAttribute" in obj), "getAttribute exposed in obj");
 });
 
 sync_test("__defineGetter__", function() {
@@ -1776,10 +3420,61 @@ sync_test("__defineSetter__", function() {
 async_test("postMessage", function() {
     var v = document.documentMode;
     var onmessage_called = false;
-    window.onmessage = function() {
+    window.onmessage = function(e) {
         onmessage_called = true;
-        next_test();
+        if(v < 9)
+            ok(e === undefined, "e = " + e);
+        else {
+            ok(e.data === (v < 10 ? "10" : 10), "e.data = " + e.data);
+            next_test();
+        }
+    }
+
+    var invalid = [
+        v < 10 ? { toString: function() { return "http://winetest.example.org"; } } : null,
+        (function() { return "http://winetest.example.org"; }),
+        "winetest.example.org",
+        "example.org",
+        undefined
+    ];
+    for(var i = 0; i < invalid.length; i++) {
+        try {
+            window.postMessage("invalid " + i, invalid[i]);
+            ok(false, "expected exception with targetOrigin " + invalid[i]);
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            todo_wine_if(v >= 10).
+            ok(n === (v < 10 ? 0x80070057 : 0), "postMessage with targetOrigin " + invalid[i] + " threw " + n);
+            if(v >= 10)
+                todo_wine.
+                ok(ex.name === "SyntaxError", "postMessage with targetOrigin " + invalid[i] + " threw " + ex.name);
+        }
+    }
+    try {
+        window.postMessage("invalid empty", "");
+        ok(false, "expected exception with empty targetOrigin");
+    }catch(ex) {
+        var n = ex.number >>> 0;
+        ok(n === 0x80070057, "postMessage with empty targetOrigin threw " + n);
+    }
+
+    window.postMessage("wrong port", "http://winetest.example.org:1234");
+    ok(onmessage_called == (v < 9 ? true : false), "onmessage not called with wrong port");
+    onmessage_called = false;
+
+    var not_sent = [
+        "http://winetest.example.com",
+        "ftp://winetest.example.org",
+        "http://wine.example.org",
+        "http://example.org"
+    ];
+    for(var i = 0; i < not_sent.length; i++) {
+        window.postMessage("not_sent " + i, not_sent[i]);
+        ok(onmessage_called == false, "onmessage called with targetOrigin " + not_sent[i]);
+        onmessage_called = false;
     }
-    window.postMessage("test", "*");
+
+    window.postMessage(10, (v < 10 ? "*" : { toString: function() { return "*"; } }));
     ok(onmessage_called == (v < 9 ? true : false), "onmessage not called");
+    if(v < 9) next_test();
 });
diff --git a/dlls/mshtml/tests/dom.c b/dlls/mshtml/tests/dom.c
index 1b1e6771ec9..b40c9c8b55f 100644
--- a/dlls/mshtml/tests/dom.c
+++ b/dlls/mshtml/tests/dom.c
@@ -2186,6 +2186,42 @@ static void _set_object_name(unsigned line, IHTMLElement *elem, const WCHAR *nam
     _test_object_name(line, elem, name);
 }
 
+static void test_factory(void *window, void *factory, const WCHAR *name, const WCHAR *value)
+{
+    IDispatch *disp, *window_disp = window;
+    DISPPARAMS dp = { NULL, NULL, 0, 0 };
+    BSTR bstr = SysAllocString(name);
+    VARIANT var, val;
+    DISPID dispid;
+    HRESULT hres;
+
+    hres = IDispatch_GetIDsOfNames(window_disp, &IID_NULL, &bstr, 1, 0, &dispid);
+    SysFreeString(bstr);
+    ok(hres == S_OK, "GetIDsOfNames(%s) failed: %08lx\n", wine_dbgstr_w(name), hres);
+
+    hres = IDispatch_Invoke(window_disp, dispid, &IID_NULL, 0, DISPATCH_PROPERTYGET, &dp, &var, NULL, NULL);
+    ok(hres == S_OK, "Invoke(%s) failed: %08lx\n", wine_dbgstr_w(name), hres);
+    ok(V_VT(&var) == VT_DISPATCH, "VT(%s) = %d\n", wine_dbgstr_w(name), V_VT(&var));
+
+    hres = IUnknown_QueryInterface((IUnknown*)factory, &IID_IDispatch, (void**)&disp);
+    ok(hres == S_OK, "Could not get IDispatch from %s factory: %08lx\n", wine_dbgstr_w(name), hres);
+    ok(disp != V_DISPATCH(&var), "window.%s and the builtin getter returned same dispatch\n", wine_dbgstr_w(name));
+
+    hres = IDispatch_Invoke(disp, DISPID_VALUE, &IID_NULL, 0, DISPATCH_PROPERTYGET, &dp, &val, NULL, NULL);
+    IDispatch_Release(disp);
+    ok(hres == S_OK, "Invoke(DISPID_VALUE) for %s builtin getter returned: %08lx\n", wine_dbgstr_w(name), hres);
+    ok(V_VT(&val) == VT_BSTR, "V_VT(value) for %s builtin getter = %d\n", wine_dbgstr_w(name), V_VT(&val));
+    ok(!lstrcmpW(V_BSTR(&val), L"[object]"), "value for %s builtin getter = %s\n", wine_dbgstr_w(name), wine_dbgstr_w(V_BSTR(&val)));
+    VariantClear(&val);
+
+    hres = IDispatch_Invoke(V_DISPATCH(&var), DISPID_VALUE, &IID_NULL, 0, DISPATCH_PROPERTYGET, &dp, &val, NULL, NULL);
+    VariantClear(&var);
+    ok(hres == S_OK, "Invoke(DISPID_VALUE) for %s: %08lx\n", wine_dbgstr_w(name), hres);
+    ok(V_VT(&val) == VT_BSTR, "V_VT(value) for %s = %d\n", wine_dbgstr_w(name), V_VT(&val));
+    ok(!lstrcmpW(V_BSTR(&val), value), "value for %s = %s\n", wine_dbgstr_w(name), wine_dbgstr_w(V_BSTR(&val)));
+    VariantClear(&val);
+}
+
 #define create_option_elem(d,t,v) _create_option_elem(__LINE__,d,t,v)
 static IHTMLOptionElement *_create_option_elem(unsigned line, IHTMLDocument2 *doc,
         const WCHAR *txt, const WCHAR *val)
@@ -2205,6 +2241,7 @@ static IHTMLOptionElement *_create_option_elem(unsigned line, IHTMLDocument2 *do
     IHTMLWindow2_Release(window);
     ok_(__FILE__,line) (hres == S_OK, "get_Option failed: %08lx\n", hres);
 
+    test_factory(window, factory, L"Option", L"[object HTMLOptionElement]");
     test_disp((IUnknown*)factory, &IID_IHTMLOptionElementFactory, NULL, L"[object]");
 
     V_VT(&text) = VT_BSTR;
@@ -2308,6 +2345,7 @@ static IHTMLImgElement *_create_img_elem(unsigned line, IHTMLDocument2 *doc,
     ok_(__FILE__,line) (hres == S_OK, "get_Image failed: %08lx\n", hres);
 
     test_ifaces((IUnknown*)factory, img_factory_iids);
+    test_factory(window, factory, L"Image", L"[object HTMLImageElement]");
     test_disp((IUnknown*)factory, &IID_IHTMLImageElementFactory, NULL, L"[object]");
 
     if(wdth >= 0){
@@ -3614,6 +3652,7 @@ static void test_dynamic_properties(IHTMLElement *elem)
 #define test_attr_node_name(a,b) _test_attr_node_name(__LINE__,a,b)
 static void _test_attr_node_name(unsigned line, IHTMLDOMAttribute *attr, const WCHAR *exname)
 {
+    IHTMLDOMAttribute2 *attr2 = _get_attr2_iface(line, (IUnknown*)attr);
     BSTR str;
     HRESULT hres;
 
@@ -3621,6 +3660,13 @@ static void _test_attr_node_name(unsigned line, IHTMLDOMAttribute *attr, const W
     ok_(__FILE__,line)(hres == S_OK, "get_nodeName failed: %08lx\n", hres);
     ok_(__FILE__,line)(!lstrcmpW(str, exname), "node name is %s, expected %s\n", wine_dbgstr_w(str), wine_dbgstr_w(exname));
     SysFreeString(str);
+
+    hres = IHTMLDOMAttribute2_get_name(attr2, &str);
+    ok_(__FILE__,line)(hres == S_OK, "get_name failed: %08lx\n", hres);
+    ok_(__FILE__,line)(!lstrcmpW(str, exname), "name is %s, expected %s\n", wine_dbgstr_w(str), wine_dbgstr_w(exname));
+    SysFreeString(str);
+
+    IHTMLDOMAttribute2_Release(attr2);
 }
 
 #define test_attr_parent(a) _test_attr_parent(__LINE__,a)
@@ -3937,6 +3983,7 @@ static void test_contenteditable(IUnknown *unk)
     IHTMLElement3 *elem3 = get_elem3_iface(unk);
     HRESULT hres;
     BSTR str, strDefault;
+    VARIANT_BOOL vbool;
 
     hres = IHTMLElement3_get_contentEditable(elem3, &strDefault);
     ok(hres == S_OK, "get_contentEditable failed: 0x%08lx\n", hres);
@@ -3949,6 +3996,21 @@ static void test_contenteditable(IUnknown *unk)
     ok(hres == S_OK, "get_contentEditable failed: 0x%08lx\n", hres);
     ok(!lstrcmpW(str, L"true"), "Got %s, expected %s\n", wine_dbgstr_w(str), "true");
     SysFreeString(str);
+    hres = IHTMLElement3_get_isContentEditable(elem3, &vbool);
+    ok(hres == S_OK, "get_isContentEditable failed: 0x%08lx\n", hres);
+    ok(vbool == VARIANT_TRUE, "Got %d, expected VARIANT_TRUE\n", vbool);
+
+    str = SysAllocString(L"inherit");
+    hres = IHTMLElement3_put_contentEditable(elem3, str);
+    ok(hres == S_OK, "put_contentEditable(%s) failed: 0x%08lx\n", wine_dbgstr_w(str), hres);
+    SysFreeString(str);
+    hres = IHTMLElement3_get_contentEditable(elem3, &str);
+    ok(hres == S_OK, "get_contentEditable failed: 0x%08lx\n", hres);
+    ok(!lstrcmpW(str, L"inherit"), "Got %s, expected %s\n", wine_dbgstr_w(str), "inherit");
+    SysFreeString(str);
+    hres = IHTMLElement3_get_isContentEditable(elem3, &vbool);
+    ok(hres == S_OK, "get_isContentEditable failed: 0x%08lx\n", hres);
+    ok(vbool == VARIANT_FALSE, "Got %d, expected VARIANT_FALSE\n", vbool);
 
     /* Restore origin contentEditable */
     hres = IHTMLElement3_put_contentEditable(elem3, strDefault);
@@ -7079,6 +7141,8 @@ static void test_xmlhttprequest(IHTMLWindow5 *window)
     ok(hres == S_OK, "QueryInterface(&IID_IHTMLXMLHttpRequestFactory) failed: %08lx\n", hres);
     ok(factory != NULL, "factory == NULL\n");
 
+    test_factory(window, factory, L"XMLHttpRequest", L"[object XMLHttpRequest]");
+
     xml = NULL;
     hres = IHTMLXMLHttpRequestFactory_create(factory, &xml);
     ok(hres == S_OK, "create failed: %08lx\n", hres);
@@ -7117,6 +7181,7 @@ static void test_window(IHTMLDocument2 *doc)
     IHTMLWindow2 *window, *window2, *self, *parent;
     IHTMLWindow5 *window5;
     IHTMLWindow7 *window7;
+    IHTMLDOMConstructorCollection *ctor_col;
     IHTMLDocument2 *doc2 = NULL;
     IDispatch *disp;
     IUnknown *unk;
@@ -7218,6 +7283,9 @@ static void test_window(IHTMLDocument2 *doc)
         win_skip("IHTMLWindow5 not supported!\n");
     }
 
+    hres = IHTMLWindow2_QueryInterface(window, &IID_IHTMLDOMConstructorCollection, (void**)&ctor_col);
+    ok(hres == E_NOINTERFACE, "QueryInterface for IHTMLDOMConstructorCollection returned %08lx\n", hres);
+
     hres = IHTMLWindow2_QueryInterface(window, &IID_IHTMLWindow7, (void**)&window7);
     if(SUCCEEDED(hres)) {
         IHTMLCSSStyleDeclaration *computed_style;
@@ -7314,10 +7382,14 @@ static void test_dom_implementation(IHTMLDocument2 *doc)
     hres = IHTMLDOMImplementation_QueryInterface(dom_implementation, &IID_IHTMLDOMImplementation2,
                                                  (void**)&dom_implementation2);
     if(SUCCEEDED(hres)) {
+        IHTMLSelectionObject *selection;
+        IHTMLFramesCollection2 *frames;
         IHTMLDocument2 *new_document2;
+        IHTMLDocument3 *new_document3;
         IHTMLDocument7 *new_document;
         IHTMLLocation *location;
         IHTMLWindow2 *window;
+        IHTMLElement *elem;
         VARIANT v;
         IDispatch *disp;
 
@@ -7326,6 +7398,7 @@ static void test_dom_implementation(IHTMLDocument2 *doc)
         str = SysAllocString(L"test");
         hres = IHTMLDOMImplementation2_createHTMLDocument(dom_implementation2, str, &new_document);
         ok(hres == S_OK, "createHTMLDocument failed: %08lx\n", hres);
+        SysFreeString(str);
 
         test_disp((IUnknown*)new_document, &DIID_DispHTMLDocument, &CLSID_HTMLDocument, L"[object]");
         test_ifaces((IUnknown*)new_document, doc_node_iids);
@@ -7341,15 +7414,63 @@ static void test_dom_implementation(IHTMLDocument2 *doc)
         hres = IHTMLDocument7_QueryInterface(new_document, &IID_IHTMLDocument2, (void**)&new_document2);
         ok(hres == S_OK, "Could not get IHTMLDocument2 iface: %08lx\n", hres);
 
+        hres = IHTMLDocument7_QueryInterface(new_document, &IID_IHTMLDocument3, (void**)&new_document3);
+        ok(hres == S_OK, "Could not get IHTMLDocument3 iface: %08lx\n", hres);
+
         hres = IHTMLDocument2_get_parentWindow(new_document2, &window);
         ok(hres == E_FAIL, "get_parentWindow returned: %08lx\n", hres);
 
+        hres = IHTMLDocument2_get_readyState(new_document2, &str);
+        ok(hres == S_OK, "get_readyState returned: %08lx\n", hres);
+        ok(!lstrcmpW(str, L"uninitialized"), "readyState = %s\n", wine_dbgstr_w(str));
+        SysFreeString(str);
+
         hres = IHTMLDocument2_get_Script(new_document2, &disp);
         ok(hres == E_PENDING, "get_Script returned: %08lx\n", hres);
 
+        str = SysAllocString(L"test=testval");
+        hres = IHTMLDocument2_put_cookie(new_document2, str);
+        ok(hres == S_OK, "put_cookie returned: %08lx\n", hres);
+        SysFreeString(str);
+
+        hres = IHTMLDocument2_get_cookie(doc, &str);
+        ok(hres == S_OK, "get_cookie returned: %08lx\n", hres);
+        ok(str == NULL, "cookie = %s\n", wine_dbgstr_w(str));
+        SysFreeString(str);
+
+        hres = IHTMLDocument3_get_documentElement(new_document3, &elem);
+        ok(hres == S_OK, "get_documentElement returned: %08lx\n", hres);
+        ok(elem != NULL, "documentElement = NULL\n");
+        IHTMLElement_Release(elem);
+
+        hres = IHTMLDocument2_get_frames(new_document2, &frames);
+        ok(hres == E_NOTIMPL, "get_frames returned: %08lx\n", hres);
+
         hres = IHTMLDocument2_get_location(new_document2, &location);
         ok(hres == E_UNEXPECTED, "get_location returned: %08lx\n", hres);
 
+        hres = IHTMLDocument2_get_selection(new_document2, &selection);
+        ok(hres == S_OK, "get_selection returned: %08lx\n", hres);
+        ok(selection != NULL, "selection = NULL\n");
+        hres = IHTMLSelectionObject_get_type(selection, &str);
+        ok(hres == S_OK, "selection get_type returned: %08lx\n", hres);
+        ok(!lstrcmpW(str, L"None"), "selection type = %s\n", wine_dbgstr_w(str));
+        IHTMLSelectionObject_Release(selection);
+        SysFreeString(str);
+
+        hres = IHTMLDocument2_get_URL(new_document2, &str);
+        ok(hres == S_OK, "get_URL returned: %08lx\n", hres);
+        ok(!lstrcmpW(str, L"about:blank"), "URL = %s\n", wine_dbgstr_w(str));
+        SysFreeString(str);
+
+        str = SysAllocString(L"text/html");
+        V_VT(&v) = VT_ERROR;
+        disp = (IDispatch*)0xdeadbeef;
+        hres = IHTMLDocument2_open(new_document2, str, v, v, v, &disp);
+        ok(hres == E_FAIL, "open returned: %08lx\n", hres);
+        ok(disp == NULL, "disp = %p\n", disp);
+        SysFreeString(str);
+
         memset(&v, 0xcc, sizeof(v));
         hres = IHTMLDocument7_get_onmsthumbnailclick(new_document, &v);
         ok(hres == S_OK, "get_onmsthumbnailclick returned: %08lx\n", hres);
@@ -7357,6 +7478,7 @@ static void test_dom_implementation(IHTMLDocument2 *doc)
         ok((DWORD)(DWORD_PTR)V_DISPATCH(&v) == 0xcccccccc, "got %p\n", V_DISPATCH(&v));
 
         IHTMLDocument2_Release(new_document2);
+        IHTMLDocument3_Release(new_document3);
         IHTMLDocument7_Release(new_document);
         IHTMLDOMImplementation2_Release(dom_implementation2);
     }else {
diff --git a/dlls/mshtml/tests/dom.js b/dlls/mshtml/tests/dom.js
index ed5f72c4376..cd95690c12a 100644
--- a/dlls/mshtml/tests/dom.js
+++ b/dlls/mshtml/tests/dom.js
@@ -89,14 +89,29 @@ sync_test("textContent", function() {
 
 sync_test("ElementTraversal", function() {
     var div = document.createElement("div");
-    div.innerHTML = "abc<b>bold</b><script>/* */<script><div>text</div>def";
+    div.innerHTML = "abc<b>bold</b><script>/* */</script><div>text</div>def";
+    ok(div.childElementCount === 3, "div.childElementCount = " + div.childElementCount);
     ok(div.firstElementChild.outerHTML === "<b>bold</b>",
             "div.firstElementChild.outerHTML = " + div.firstElementChild.outerHTML);
+    ok(div.lastElementChild.outerHTML === "<div>text</div>",
+            "div.lastElementChild.outerHTML = " + div.lastElementChild.outerHTML);
+    ok(div.firstElementChild.nextElementSibling.outerHTML === "<script>/* */</script>",
+            "div.firstElementChild.nextElementSibling.outerHTML = " + div.firstElementChild.nextElementSibling.outerHTML);
+    ok(div.lastElementChild.nextElementSibling === null,
+            "div.lastElementChild.nextElementSibling = " + div.lastElementChild.nextElementSibling);
+    ok(div.lastElementChild.previousElementSibling.outerHTML === "<script>/* */</script>",
+            "div.lastElementChild.previousElementSibling.outerHTML = " + div.lastElementChild.previousElementSibling.outerHTML);
+    ok(div.firstElementChild.previousElementSibling === null,
+            "div.firstElementChild.previousElementSibling = " + div.firstElementChild.previousElementSibling);
 
     div.innerHTML = "abc";
+    ok(div.childElementCount === 0, "div.childElementCount = " + div.childElementCount);
     ok(div.firstElementChild === null, "div.firstElementChild = " + div.firstElementChild);
+    ok(div.lastElementChild === null, "div.lastElementChild = " + div.lastElementChild);
 
+    ok(!("childElementCount" in document), "childElementCount found in document");
     ok(!("firstElementChild" in document), "firstElementChild found in document");
+    ok(!("nextElementSibling" in document), "nextElementSibling found in document");
 });
 
 sync_test("head", function() {
@@ -127,9 +142,18 @@ async_test("iframe_location", function() {
     iframe.onload = function() {
         ok(iframe.contentWindow.location.pathname === "/emptyfile",
            "path = " + iframe.contentWindow.location.pathname);
+        ok(iframe.contentWindow.Image !== undefined, "Image is undefined");
+        ok(iframe.contentWindow.VBArray !== undefined, "VBArray is undefined");
+        iframe.contentWindow.Image = undefined;
+        iframe.contentWindow.VBArray = undefined;
+        iframe.contentWindow.foobar = 1234;
         iframe.onload = function () {
             ok(iframe.contentWindow.location.pathname === "/empty/file",
                "path = " + iframe.contentWindow.location.pathname);
+            ok(iframe.contentWindow.Image !== undefined, "Image is undefined (2)");
+            ok(iframe.contentWindow.VBArray !== undefined, "VBArray is undefined (2)");
+            ok(!Object.prototype.hasOwnProperty.call(iframe.contentWindow, "foobar"),
+               "contentWindow has foobar");
             next_test();
         }
         iframe.src = "empty/file";
@@ -494,13 +518,21 @@ sync_test("elem_props", function() {
 });
 
 async_test("animation_frame", function() {
-    var id = requestAnimationFrame(function(x) {
+    var id = requestAnimationFrame(function(x) { ok(false, "request was supposed to be cancelled"); });
+    id = cancelAnimationFrame(id);
+    ok(id === undefined, "cancelAnimationFrame returned " + id);
+
+    id = requestAnimationFrame(function(x) {
         ok(this === window, "this != window");
         ok(typeof(x) === "number", "x = " + x);
         ok(arguments.length === 1, "arguments.length = " + arguments.length);
         next_test();
     });
+    cancelAnimationFrame(0);
+    clearInterval(id);
+    clearTimeout(id);
     ok(typeof(id) === "number", "id = " + id);
+    ok(id !== 0, "id = 0");
 });
 
 sync_test("title", function() {
@@ -510,6 +542,24 @@ sync_test("title", function() {
     elem.title = "test";
     ok(elem.title === "test", "div.title = " + elem.title);
     ok(elem.getAttribute("title") === "test", "title attribute = " + elem.getAttribute("title"));
+
+    var orig = document.title;
+    document.title = "w i n e test";
+    var title = document.getElementsByTagName("title")[0];
+    ok(title.text === "w i n e test", "<title> element text = " + title.text);
+    title.text = "winetest";
+    ok(title.text === "winetest", "<title> element text after change = " + title.text);
+    ok(document.title === "winetest", "document.title after <title> change = " + document.title);
+
+    elem = document.createElement("title");
+    ok(elem.text === "", "detached <title> element text = " + elem.text);
+    elem.text = "foobar";
+    ok(elem.text === "foobar", "detached <title> element text after change = " + elem.text);
+    ok(document.title === "winetest", "document.title after detached <title> change = " + document.title);
+
+    title.parentNode.replaceChild(elem, title);
+    ok(document.title === "foobar", "document.title after <title> replaced = " + document.title);
+    document.title = orig;
 });
 
 sync_test("disabled", function() {
diff --git a/dlls/mshtml/tests/es5.js b/dlls/mshtml/tests/es5.js
index 5aa186b91da..60656bf3172 100644
--- a/dlls/mshtml/tests/es5.js
+++ b/dlls/mshtml/tests/es5.js
@@ -16,19 +16,32 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+var E_INVALIDARG = 0x80070057;
 var JS_E_PROP_DESC_MISMATCH = 0x800a01bd;
 var JS_E_NUMBER_EXPECTED = 0x800a1389;
 var JS_E_FUNCTION_EXPECTED = 0x800a138a;
 var JS_E_DATE_EXPECTED = 0x800a138e;
 var JS_E_OBJECT_EXPECTED = 0x800a138f;
+var JS_E_UNDEFINED_VARIABLE = 0x800a1391;
 var JS_E_BOOLEAN_EXPECTED = 0x800a1392;
 var JS_E_VBARRAY_EXPECTED = 0x800a1395;
 var JS_E_ENUMERATOR_EXPECTED = 0x800a1397;
 var JS_E_REGEXP_EXPECTED = 0x800a1398;
+var JS_E_INVALID_LENGTH = 0x800a13a5;
 var JS_E_INVALID_WRITABLE_PROP_DESC = 0x800a13ac;
 var JS_E_NONCONFIGURABLE_REDEFINED = 0x800a13d6;
 var JS_E_NONWRITABLE_MODIFIED = 0x800a13d7;
+var JS_E_TYPEDARRAY_BAD_CTOR_ARG = 0x800a13da;
+var JS_E_NOT_TYPEDARRAY = 0x800a13db;
+var JS_E_TYPEDARRAY_INVALID_OFFSLEN = 0x800a13dc;
+var JS_E_TYPEDARRAY_INVALID_SUBARRAY = 0x800a13dd;
+var JS_E_TYPEDARRAY_INVALID_SOURCE = 0x800a13de;
+var JS_E_NOT_DATAVIEW = 0x800a13df;
+var JS_E_DATAVIEW_NO_ARGUMENT = 0x800a13e0;
+var JS_E_DATAVIEW_INVALID_ACCESS = 0x800a13e1;
+var JS_E_DATAVIEW_INVALID_OFFSET = 0x800a13e2;
 var JS_E_WRONG_THIS = 0x800a13fc;
+var JS_E_ARRAYBUFFER_EXPECTED = 0x800a15e4;
 
 var tests = [];
 
@@ -419,7 +432,14 @@ sync_test("array_sort", function() {
 });
 
 sync_test("identifier_keywords", function() {
+    function get(let, set) { { get instanceof (Object); } return let + set; }
+    set: var let = get(1, 2);
+    { get: 10 }
+    var set = 0;
     var o = {
+        get: get,
+        set: set,
+        let: let,
         if: 1,
         default: 2,
         function: 3,
@@ -432,8 +452,8 @@ sync_test("identifier_keywords", function() {
         else: true,
         finally: true,
         for: true,
-        in: true,
-        instanceof: true,
+        set in(x) { },
+        get instanceof() { return 3; },
         new: true,
         return: true,
         switch: true,
@@ -454,6 +474,19 @@ sync_test("identifier_keywords", function() {
     ok(o.if === 1, "o.if = " + o.if);
     ok(ro().default === 2, "ro().default = " + ro().default);
     ok(o.false === true, "o.false = " + o.false);
+    ok(o.get === get, "o.let = " + o.get);
+    ok(o.set === set, "o.let = " + o.set);
+    ok(o.let === let, "o.let = " + o.let);
+    ok(o.instanceof === 3, "o.instanceof = " + o.instanceof);
+
+    var tmp = false;
+    try {
+        eval('function var() { }');
+    }
+    catch(set) {
+        tmp = true;
+    }
+    ok(tmp === true, "Expected exception for 'function var() { }'");
 });
 
 function test_own_data_prop_desc(obj, prop, expected_writable, expected_enumerable,
@@ -1082,13 +1115,14 @@ sync_test("toString", function() {
     todo_wine.
     ok(tmp === "[object Arguments]", "toString.call(arguments) = " + tmp);
     tmp = Object.prototype.toString.call(this);
-    todo_wine.
     ok(tmp === "[object Window]", "toString.call(null) = " + tmp);
     tmp = Object.prototype.toString.call(null);
     ok(tmp === "[object Null]", "toString.call(null) = " + tmp);
     tmp = Object.prototype.toString.call(undefined);
+    todo_wine.
     ok(tmp === "[object Undefined]", "toString.call(undefined) = " + tmp);
     tmp = Object.prototype.toString.call();
+    todo_wine.
     ok(tmp === "[object Undefined]", "toString.call() = " + tmp);
 
     obj = Object.create(null);
@@ -1570,6 +1604,809 @@ sync_test("isFrozen", function() {
     }
 });
 
+sync_test("ArrayBuffers & Views", function() {
+    var i, r, buf, buf2, view, view2, arr, arr2;
+
+    var types = [
+        [ "Int8",    1 ],
+        [ "Uint8",   1 ],
+        [ "Int16",   2 ],
+        [ "Uint16",  2 ],
+        [ "Int32",   4 ],
+        [ "Uint32",  4 ],
+        [ "Float32", 4 ],
+        [ "Float64", 8 ]
+    ];
+
+    function test_own_props(obj_name, props) {
+        var obj = eval(obj_name);
+        for(var i = 0; i < props.length; i++)
+            ok(Object.prototype.hasOwnProperty.call(obj, props[i]), props[i] + " not a property of " + obj_name);
+    }
+
+    function test_not_own_props(obj_name, props) {
+        var obj = eval(obj_name);
+        for(var i = 0; i < props.length; i++)
+            ok(!Object.prototype.hasOwnProperty.call(obj, props[i]), props[i] + " is a property of " + obj_name);
+    }
+
+    function test_readonly(obj, prop, val) {
+        var name = Object.getPrototypeOf(obj).constructor.toString();
+        name = name.substring(9, name.indexOf("(", 9)) + ".prototype." + prop;
+        obj[prop] = val + 42;
+        ok(obj[prop] === val, name + " not read-only");
+    }
+
+    test_own_props("ArrayBuffer", [ "isView" ]);
+    test_own_props("ArrayBuffer.prototype", [ "byteLength", "slice" ]);
+    test_own_data_prop_desc(ArrayBuffer.prototype, "byteLength", false, false, false);
+
+    r = Object.prototype.toString.call(new ArrayBuffer());
+    ok(r === "[object ArrayBuffer]", "Object toString(new ArrayBuffer()) = " + r);
+    r = ArrayBuffer.length;
+    ok(r === 1, "ArrayBuffer.length = " + r);
+    r = ArrayBuffer.isView.length;
+    ok(r === 1, "ArrayBuffer.isView.length = " + r);
+    r = ArrayBuffer.prototype.slice.length;
+    ok(r === 2, "ArrayBuffer.prototype.slice.length = " + r);
+
+    try {
+        ArrayBuffer.prototype.slice.call(null);
+        ok(false, "ArrayBuffer: calling slice with null context did not throw exception");
+    }catch(ex) {
+        var n = ex.number >>> 0;
+        ok(n === JS_E_ARRAYBUFFER_EXPECTED, "ArrayBuffer: calling slice with null context threw " + n);
+    }
+    try {
+        ArrayBuffer.prototype.slice.call({});
+        ok(false, "ArrayBuffer: calling slice with an object context did not throw exception");
+    }catch(ex) {
+        var n = ex.number >>> 0;
+        ok(n === JS_E_ARRAYBUFFER_EXPECTED, "ArrayBuffer: calling slice with an object context threw " + n);
+    }
+    try {
+        new ArrayBuffer(-1);
+        ok(false, "new ArrayBuffer(-1) did not throw exception");
+    }catch(ex) {
+        var n = ex.number >>> 0;
+        ok(n === JS_E_INVALID_LENGTH, "new ArrayBuffer(-1) threw " + n);
+    }
+
+    buf = new ArrayBuffer();
+    ok(buf.byteLength === 0, "ArrayBuffer().byteLength = " + buf.byteLength);
+    buf = new ArrayBuffer(13.1);
+    ok(buf.byteLength === 13, "ArrayBuffer(13).byteLength = " + buf.byteLength);
+    buf = ArrayBuffer("10");
+    ok(buf.byteLength === 10, "ArrayBuffer(10).byteLength = " + buf.byteLength);
+    test_readonly(buf, "byteLength", 10);
+    test_own_data_prop_desc(buf, "byteLength", false, false, false);
+
+    ok(ArrayBuffer.isView() === false, "ArrayBuffer.isView() returned true");
+    ok(ArrayBuffer.isView([]) === false, "ArrayBuffer.isView([]) returned true");
+    ok(ArrayBuffer.isView({}) === false, "ArrayBuffer.isView({}) returned true");
+    ok(ArrayBuffer.isView(undefined) === false, "ArrayBuffer.isView(undefined) returned true");
+    ok(ArrayBuffer.isView(null) === false, "ArrayBuffer.isView(null) returned true");
+    ok(ArrayBuffer.isView(buf) === false, "ArrayBuffer.isView(ArrayBuffer) returned true");
+
+    test_own_props("DataView.prototype", [
+        "buffer", "byteLength", "byteOffset",
+        "getInt8",  "setInt8",  "getUint8",  "setUint8",
+        "getInt16", "setInt16", "getUint16", "setUint16",
+        "getInt32", "setInt32", "getUint32", "setUint32",
+        "getFloat32", "setFloat32", "getFloat64", "setFloat64"
+    ]);
+
+    r = Object.prototype.toString.call(new DataView(buf));
+    ok(r === "[object Object]", "Object toString(new DataView(buf)) = " + r);
+    r = DataView.length;
+    ok(r === 1, "DataView.length = " + r);
+
+    /* DataView.prototype has actual accessors, but others don't */
+    arr = [ "buffer", "byteLength", "byteOffset" ];
+    for(i = 0; i < arr.length; i++) {
+        var prop = arr[i], desc = Object.getOwnPropertyDescriptor(DataView.prototype, prop);
+        ok(!("value" in desc), "DataView: value is in desc");
+        ok(!("writable" in desc), "DataView: writable is in desc");
+        ok(desc.enumerable === false, "DataView: desc.enumerable = " + desc.enumerable);
+        ok(desc.configurable === true, "DataView: desc.configurable = " + desc.configurable);
+        ok(Object.getPrototypeOf(desc.get) === Function.prototype, "DataView: desc.get not a function: " + desc.get);
+        ok("set" in desc, "DataView: set is not in desc");
+        ok(desc.set === undefined, "DataView: desc.set not undefined: " + desc.set);
+        try {
+            desc.get.call(null);
+            ok(false, "DataView: calling " + prop + " getter with null did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_NOT_DATAVIEW, "DataView: calling " + prop + " getter with null threw " + n);
+        }
+        try {
+            desc.get.call({});
+            ok(false, "DataView: calling " + prop + " getter with an object did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_NOT_DATAVIEW, "DataView: calling " + prop + " getter with an object threw " + n);
+        }
+        try {
+            desc.get.call(DataView);
+            ok(false, "DataView: calling " + prop + " getter with DataView constructor did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_NOT_DATAVIEW, "DataView: calling " + prop + " getter with DataView constructor threw " + n);
+        }
+        try {
+            desc.get.call(new ArrayBuffer());
+            ok(false, "DataView: calling " + prop + " getter with ArrayBuffer did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_NOT_DATAVIEW, "DataView: calling " + prop + " getter with ArrayBuffer threw " + n);
+        }
+        r = desc.get.call(DataView.prototype);
+        if(prop === "buffer")
+            ok(Object.getPrototypeOf(r) === ArrayBuffer.prototype, "DataView: calling " + prop + " getter with DataView.prototype returned " + r);
+        else
+            ok(r === 0, "DataView: calling " + prop + " getter with DataView.prototype returned " + r);
+    }
+
+    try {
+        new DataView();
+        ok(false, "new DataView() did not throw exception");
+    }catch(ex) {
+        var n = ex.number >>> 0;
+        ok(n === JS_E_DATAVIEW_NO_ARGUMENT, "new DataView() threw " + n);
+    }
+    try {
+        new DataView(ArrayBuffer);
+        ok(false, "new DataView(ArrayBuffer) did not throw exception");
+    }catch(ex) {
+        var n = ex.number >>> 0;
+        ok(n === JS_E_DATAVIEW_NO_ARGUMENT, "new DataView(ArrayBuffer) threw " + n);
+    }
+    try {
+        new DataView(buf, -1);
+        ok(false, "new DataView(buf, -1) did not throw exception");
+    }catch(ex) {
+        var n = ex.number >>> 0;
+        ok(n === JS_E_DATAVIEW_INVALID_OFFSET, "new DataView(buf, -1) threw " + n);
+    }
+    try {
+        new DataView(buf, 11);
+        ok(false, "new DataView(buf, 11) did not throw exception");
+    }catch(ex) {
+        var n = ex.number >>> 0;
+        ok(n === JS_E_DATAVIEW_INVALID_OFFSET, "new DataView(buf, 11) threw " + n);
+    }
+    try {
+        new DataView(buf, 9, 2);
+        ok(false, "new DataView(buf, 9, 2) did not throw exception");
+    }catch(ex) {
+        var n = ex.number >>> 0;
+        ok(n === JS_E_DATAVIEW_INVALID_OFFSET, "new DataView(buf, 9, 2) threw " + n);
+    }
+
+    view = new DataView(buf, 9, 1);
+    ok(view.buffer === buf,  "DataView(buf, 9, 1).buffer = " + view.buffer);
+    ok(view.byteLength === 1, "DataView(buf, 9, 1).byteLength = " + view.byteLength);
+    ok(view.byteOffset === 9, "DataView(buf, 9, 1).byteOffset = " + view.byteOffset);
+    test_readonly(view, "byteLength", 1);
+    test_readonly(view, "byteOffset", 9);
+    test_not_own_props("view", [ "buffer", "byteLength", "byteOffset" ]);
+
+    view = new DataView(buf, 10);
+    ok(view.buffer === buf,  "DataView(buf, 10).buffer = " + view.buffer);
+    ok(view.byteLength === 0, "DataView(buf, 10).byteLength = " + view.byteLength);
+    ok(view.byteOffset === 10, "DataView(buf, 10).byteOffset = " + view.byteOffset);
+    view = new DataView(buf, 1, 7);
+    ok(view.buffer === buf,  "DataView(buf, 1, 7).buffer = " + view.buffer);
+    ok(view.byteLength === 7, "DataView(buf, 1, 7).byteLength = " + view.byteLength);
+    ok(view.byteOffset === 1, "DataView(buf, 1, 7).byteOffset = " + view.byteOffset);
+    view2 = new DataView(buf, 6);
+    ok(view2.buffer === buf,  "DataView(buf, 6).buffer = " + view2.buffer);
+    ok(view2.byteLength === 4, "DataView(buf, 6).byteLength = " + view2.byteLength);
+    ok(view2.byteOffset === 6, "DataView(buf, 6).byteOffset = " + view2.byteOffset);
+    view = DataView(buf);
+    ok(view.buffer === buf,  "DataView(buf).buffer = " + view.buffer);
+    ok(view.byteLength === 10, "DataView(buf).byteLength = " + view.byteLength);
+    ok(view.byteOffset === 0,  "DataView(buf).byteOffset = " + view.byteOffset);
+
+    ok(ArrayBuffer.isView(DataView) === false, "ArrayBuffer.isView(DataView) returned true");
+    ok(ArrayBuffer.isView(view) === true, "ArrayBuffer.isView(DataView(buf)) returned false");
+
+    for(i = 0; i < 10; i++) {
+        r = view.getInt8(i);
+        ok(r === 0, "view byte " + i + " = " + r);
+    }
+
+    for(i = 0; i < types.length; i++) {
+        var method = "get" + types[i][0], offs = 11 - types[i][1];
+        r = DataView.prototype[method].length;
+        ok(r === 1, "DataView.prototype." + method + ".length = " + r);
+        try {
+            view[method]();
+            ok(false, "view." + method + "() did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_DATAVIEW_NO_ARGUMENT, "view." + method + "() threw " + n);
+        }
+        try {
+            view[method](-1);
+            ok(false, "view." + method + "(-1) did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_DATAVIEW_INVALID_ACCESS, "view." + method + "(-1) threw " + n);
+        }
+        try {
+            view[method](offs);
+            ok(false, "view." + method + "(" + offs + ") did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_DATAVIEW_INVALID_ACCESS, "view." + method + "(" + offs + ") threw " + n);
+        }
+        try {
+            view[method].call(null, 0);
+            ok(false, "view." + method + "(0) with null context did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_NOT_DATAVIEW, "view." + method + "(0) with null context threw " + n);
+        }
+        try {
+            view[method].call({}, 0);
+            ok(false, "view." + method + "(0) with an object context did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_NOT_DATAVIEW, "view." + method + "(0) with an object context threw " + n);
+        }
+        method = "set" + types[i][0];
+        r = DataView.prototype[method].length;
+        ok(r === 1, "DataView.prototype." + method + ".length = " + r);
+        try {
+            view[method]();
+            ok(false, "view." + method + "() did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_DATAVIEW_NO_ARGUMENT, "view." + method + "() threw " + n);
+        }
+        try {
+            view[method](0);
+            ok(false, "view." + method + "(0) did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_DATAVIEW_NO_ARGUMENT, "view." + method + "(0) threw " + n);
+        }
+        try {
+            view[method](-1, 0);
+            ok(false, "view." + method + "(-1, 0) did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_DATAVIEW_INVALID_ACCESS, "view." + method + "(-1, 0) threw " + n);
+        }
+        try {
+            view[method](offs, 0);
+            ok(false, "view." + method + "(" + offs + ", 0) did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_DATAVIEW_INVALID_ACCESS, "view." + method + "(" + offs + ", 0) threw " + n);
+        }
+        try {
+            view[method].call(null, 0, 0);
+            ok(false, "view." + method + "(0, 0) with null context did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_NOT_DATAVIEW, "view." + method + "(0, 0) with null context threw " + n);
+        }
+        try {
+            view[method].call({}, 0, 0);
+            ok(false, "view." + method + "(0, 0) with an object context did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_NOT_DATAVIEW, "view." + method + "(0, 0) with an object context threw " + n);
+        }
+    }
+
+    r = view.setInt8(1, -257);
+    ok(r === undefined, "view.setInt8(1, -1) returned " + r);
+    r = view.getUint16(0);
+    ok(r === 255, "view.getUint16(0) returned " + r);
+    r = view.getUint16(0, true);
+    ok(r === 65280, "view.getUint16(0, true) returned " + r);
+    r = view.setUint32(2, "12345678", true);
+    ok(r === undefined, "view.setUint32(2, '12345678', true) returned " + r);
+    r = view.getInt32(1);
+    ok(r === -11640388, "view.getInt32(1) returned " + r);
+    r = view.setInt16(3, 65535, true);
+    ok(r === undefined, "view.setInt16(3, 65535) returned " + r);
+    r = view.getUint16(3);
+    ok(r === 65535, "view.getUint16(3) returned " + r);
+    r = view.setUint32(0, -2, true);
+    ok(r === undefined, "view.setUint32(0, -2) returned " + r);
+    r = view.getInt32(0, true);
+    ok(r === -2, "view.getInt32(0) returned " + r);
+    r = view.setFloat32(6, 1234.5, true);
+    ok(r === undefined, "view.setFloat32(6, 1234.5) returned " + r);
+    r = view2.getFloat32(0, true);
+    ok(r === 1234.5, "view2.getFloat32(0) returned " + r);
+
+    r = buf.slice(-9, 1);
+    ok(r instanceof ArrayBuffer, "buf.slice did not return an ArrayBuffer");
+    ok(r.byteLength === 0, "buf.slice(-9, 1).byteLength = " + r.byteLength);
+    r = buf.slice();
+    ok(r.byteLength === 10, "buf.slice().byteLength = " + r.byteLength);
+    r = buf.slice(9, 16);
+    ok(r.byteLength === 1, "buf.slice(9, 16).byteLength = " + r.byteLength);
+    r = buf.slice(-9, -1);
+    ok(r.byteLength === 8, "buf.slice(-9, -1).byteLength = " + r.byteLength);
+
+    /* setters differing only in signedness have identical behavior, but they're not the same methods */
+    ok(view.setInt8 !== view.setUint8, "setInt8 and setUint8 are the same method");
+    ok(view.setInt16 !== view.setUint16, "setInt16 and setUint16 are the same method");
+    ok(view.setInt32 !== view.setUint32, "setInt32 and setUint32 are the same method");
+
+    /* slice makes a copy */
+    buf2 = buf.slice(-9);
+    ok(buf2.byteLength === 9, "buf.slice(-9).byteLength = " + buf2.byteLength);
+    view2 = DataView(buf2, 1);
+    ok(view2.byteLength === 8, "buf.slice(-9) view(1).byteLength = " + view2.byteLength);
+    ok(ArrayBuffer.isView(buf2) === false, "ArrayBuffer.isView(buf.slice(-9)) returned true");
+    ok(ArrayBuffer.isView(view2) === true, "ArrayBuffer.isView(DataView(buf.slice(-9))) returned false");
+
+    r = view2.getUint32(0);
+    ok(r === 4294967040, "buf.slice(-9) view(1).getUint32(0) returned " + r);
+    view2.setInt16(0, -5);
+    r = view2.getUint16(1);
+    ok(r === 64511, "buf.slice(-9) view(1).getUint16(1) returned " + r);
+    r = view.getInt32(1);
+    ok(r === -1, "view.getInt32(1) after slice changed returned " + r);
+
+    r = view2.setFloat64(0, 11.875);
+    ok(r === undefined, "buf.slice(-9) view(1).setFloat64(0, 11.875) returned " + r);
+    r = view2.getFloat64(0);
+    ok(r === 11.875, "buf.slice(-9) view(1).getFloat64(0) returned " + r);
+
+    for(i = 0; i < types.length; i++) {
+        var arrType = types[i][0] + "Array", typeSz = types[i][1];
+        test_own_props(arrType, [ "BYTES_PER_ELEMENT" ]);
+        test_not_own_props(arrType, [ "from", "of" ]);
+        test_own_props(arrType + ".prototype", [ "buffer", "byteLength", "byteOffset", "length", "set", "subarray" ]);
+        test_not_own_props(arrType + ".prototype", [
+            "at", "copyWithin", "entries", "every", "fill", "filter", "find", "findIndex", "forEach",
+            "includes", "indexOf", "join", "keys", "lastIndexOf", "map", "reduce", "reduceRight",
+            "reverse", "slice", "some", "sort", "toLocaleString", "toString", "values"
+        ]);
+
+        arr = eval(arrType);
+        test_own_data_prop_desc(arr, "BYTES_PER_ELEMENT", false, false, false);
+        ok(arr.BYTES_PER_ELEMENT === typeSz, arrType + ".BYTES_PER_ELEMENT = " + arr.BYTES_PER_ELEMENT);
+        r = arr.length;
+        ok(r === 1, arrType + ".length = " + r);
+        r = arr.prototype.set.length;
+        ok(r === 2, arrType + ".prototype.set.length = " + r);
+        r = arr.prototype.subarray.length;
+        ok(r === 2, arrType + ".prototype.subarray.length = " + r);
+
+        r = eval("Object.getPrototypeOf(" + arrType + ")");
+        ok(r === Function.prototype, arrType + "'s prototype is not Function.prototype: " + r);
+        r = eval("Object.getPrototypeOf(" + arrType + ".prototype)");
+        ok(r === Object.prototype, arrType + ".prototype's prototype is not Object.prototype: " + r);
+        r = eval("Object.prototype.toString.call(new " + arrType + "(3))");
+        ok(r === "[object " + arrType + "]", "Object toString(new " + arrType + "(3)) = " + r);
+        r = eval(arrType + ".prototype");
+        test_own_data_prop_desc(r, "byteLength", false, false, false);
+        test_own_data_prop_desc(r, "byteOffset", false, false, false);
+        test_own_data_prop_desc(r, "length", false, false, false);
+        test_own_data_prop_desc(r, "buffer", false, false, false);
+
+        buf = ArrayBuffer(34);
+        try {
+            eval("new " + arrType + "(-1)");
+            ok(false, "new " + arrType + "(-1) did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_TYPEDARRAY_INVALID_OFFSLEN, "new " + arrType + "(-1) threw " + n);
+        }
+        try {
+            eval("new " + arrType + "(buf, -1)");
+            ok(false, "new " + arrType + "(buf, -1) did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_TYPEDARRAY_INVALID_OFFSLEN, "new " + arrType + "(buf, -1) threw " + n);
+        }
+        try {
+            eval("new " + arrType + "(buf, 36)");
+            ok(false, "new " + arrType + "(buf, 36) did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_TYPEDARRAY_INVALID_OFFSLEN, "new " + arrType + "(buf, 36) threw " + n);
+        }
+        try {
+            eval("new " + arrType + "(buf, 32, 4)");
+            ok(false, "new " + arrType + "(buf, 32, 4) did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_TYPEDARRAY_INVALID_OFFSLEN, "new " + arrType + "(buf, 32, 4) threw " + n);
+        }
+        try {
+            eval("new " + arrType + "('9')");
+            ok(false, "new " + arrType + "('9') did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_TYPEDARRAY_BAD_CTOR_ARG, "new " + arrType + "('9') threw " + n);
+        }
+        try {
+            eval("new " + arrType + "(null)");
+            ok(false, "new " + arrType + "(null) did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_TYPEDARRAY_BAD_CTOR_ARG, "new " + arrType + "(null) threw " + n);
+        }
+        try {
+            eval("new " + arrType + "({})");
+            ok(false, "new " + arrType + "({}) did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_TYPEDARRAY_BAD_CTOR_ARG, "new " + arrType + "({}) threw " + n);
+        }
+        if(typeSz > 1) {
+            /* test misalignment */
+            var a = typeSz >>> 1;
+            try {
+                eval("new " + arrType + "(buf, a, 1)");
+                ok(false, "new " + arrType + "(buf, " + a + ", 1) did not throw exception");
+            }catch(ex) {
+                var n = ex.number >>> 0;
+                ok(n === JS_E_TYPEDARRAY_INVALID_OFFSLEN, "new " + arrType + "(buf, " + a + ", 1) threw " + n);
+            }
+            a += typeSz;
+            var b = new ArrayBuffer(a);
+            try {
+                eval("new " + arrType + "(b)");
+                ok(false, "new " + arrType + "(new ArrayBuffer(" + a + ")) did not throw exception");
+            }catch(ex) {
+                var n = ex.number >>> 0;
+                ok(n === JS_E_TYPEDARRAY_INVALID_OFFSLEN, "new " + arrType + "(new ArrayBuffer(" + a + ")) threw " + n);
+            }
+        }
+
+        arr = eval("new " + arrType + "()");
+        ok(arr.byteLength === 0, arrType + "().byteLength = " + arr.byteLength);
+        ok(arr.byteOffset === 0, arrType + "().byteOffset = " + arr.byteOffset);
+        ok(arr.length === 0, arrType + "().length = " + arr.length);
+        ok(arr.buffer.byteLength === 0, arrType + "().buffer.byteLength = " + arr.buffer.byteLength);
+        test_readonly(arr, "byteLength", 0);
+        test_readonly(arr, "byteOffset", 0);
+        test_readonly(arr, "length", 0);
+        test_own_data_prop_desc(arr, "byteLength", false, false, false);
+        test_own_data_prop_desc(arr, "byteOffset", false, false, false);
+        test_own_data_prop_desc(arr, "length", false, false, false);
+        test_own_data_prop_desc(arr, "buffer", false, false, false);
+
+        ok(ArrayBuffer.isView(arr) === true, "ArrayBuffer.isView(" + arrType + "()) returned false");
+        Object.freeze(arr);
+        ok(Object.isFrozen(arr) === true, arrType + "() not frozen");
+
+        arr = eval(arrType + "(9.1)");
+        ok(arr.byteLength === 9 * typeSz, arrType + "(9.1).byteLength = " + arr.byteLength);
+        ok(arr.byteOffset === 0, arrType + "(9.1).byteOffset = " + arr.byteOffset);
+        ok(arr.length === 9, arrType + "(9.1).length = " + arr.length);
+        ok(arr.buffer.byteLength === arr.byteLength, arrType + "(9.1).buffer.byteLength = " + arr.buffer.byteLength);
+        for(var j = 0; j < 9; j++)
+            ok(arr[j] === 0, "arr[" + j + "] = " + arr[j]);
+        arr[5] = 42;
+        ok(arr[5] === 42, arrType + "(9.1)[5] = " + arr[5]);
+        arr[9] = 50;
+        ok(arr[9] === undefined, arrType + "(9.1)[9] = " + arr[9]);
+
+        eval(arrType + ".prototype[6] = 'foo'");
+        r = eval(arrType + ".prototype[6]");
+        ok(r === undefined, arrType + ".prototype[6] = " + r);
+        ok(arr[6] === 0, arrType + "(9.1)[6] after set in prototype = " + arr[6]);
+        arr[6] = 0;
+        ok(Object.prototype.hasOwnProperty.call(arr, "6"), "'6' not a property of " + arrType + "(9.1)[6]");
+        test_own_data_prop_desc(arr, "6", true, true, false);
+        r = (delete arr[6]);
+        ok(r === false, "delete " + arrType + "(9.1)[6] returned " + r);
+        try {
+            Object.defineProperty(arr, "6", {writable: false, enumerable: false, configurable: true, value: 10});
+            ok(false, "redefining " + arrType + "(9.1)[6] with different flags did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_NONCONFIGURABLE_REDEFINED, "redefining " + arrType + "(9.1)[6] with different flags threw " + n);
+        }
+        Object.defineProperty(arr, "6", {writable: true, enumerable: true, configurable: false, value: 10});
+        ok(arr[6] === 10, arrType + "(9.1)[6] after definition = " + arr[6]);
+        Object.defineProperty(arr, "6", {writable: true, enumerable: true, configurable: false, value: "foo"});
+        if(arrType.substr(0, 5) === "Float")
+            ok(arr[6] !== arr[6] /* NaN */, arrType + "(9.1)[6] after definition to string = " + arr[6]);
+        else
+            ok(arr[6] === 0, arrType + "(9.1)[6] after definition to string = " + arr[6]);
+
+        eval(arrType + ".prototype[100] = 'foobar'");
+        r = eval(arrType + ".prototype[100]");
+        ok(r === undefined, arrType + ".prototype[100] = " + r);
+        ok(arr[100] === undefined, arrType + "(9.1)[100] after set in prototype = " + arr[100]);
+        arr[100] = 0;
+        ok(arr[100] === undefined, arrType + "(9.1)[100] after set to zero = " + arr[100]);
+        ok(!Object.prototype.hasOwnProperty.call(arr, "100"), "'100' is a property of " + arrType + "(9.1)[100]");
+        r = (delete arr[100]);
+        ok(r === false, "delete " + arrType + "(9.1)[100] returned " + r);
+        try {
+            Object.defineProperty(arr, "100", {writable: false, enumerable: false, configurable: true, value: 10});
+            ok(false, "redefining " + arrType + "(9.1)[100] with different flags did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_NONCONFIGURABLE_REDEFINED, "redefining " + arrType + "(9.1)[100] with different flags threw " + n);
+        }
+        Object.defineProperty(arr, "100", {writable: true, enumerable: true, configurable: false, value: 10});
+        ok(arr[100] === undefined, arrType + "(9.1)[100] after defined to 10 = " + arr[100]);
+        ok(!Object.prototype.hasOwnProperty.call(arr, "100"), "'100' is a property of " + arrType + "(9.1)[100] after definition");
+        ok(arr[100] === undefined, arrType + "(9.1)[100] after definition = " + arr[100]);
+
+        r = 0;
+        for(var idx in arr) {
+            ok(idx === ""+r, arrType + "(9.1) enum idx " + r + " = " + idx);
+            r++;
+        }
+        ok(r === 9, arrType + "(9.1) enum did " + r + " iterations");
+
+        eval(arrType + ".prototype[-1] = 'barfoo'");
+        r = eval(arrType + ".prototype[-1]");
+        ok(r === "barfoo", arrType + ".prototype[-1] = " + r);
+        ok(arr[-1] === "barfoo", arrType + "(9.1)[-1] after set in prototype = " + arr[-1]);
+
+        eval(arrType + ".prototype.foo = 'bar'");
+        r = eval(arrType + ".prototype.foo = 'bar'");
+        ok(r === "bar", arrType + ".prototype.foo = " + r);
+        ok(arr.foo === "bar", arrType + "(9.1).foo after set in prototype = " + arr.foo);
+        Object.freeze(arr);
+        ok(Object.isFrozen(arr) === true, arrType + "(9.1) not frozen");
+        arr = eval(arrType + ".prototype");
+        delete arr[-1];
+        delete arr.foo;
+
+        arr2 = { length: 4 };
+        arr2[0] = 1.5;
+        arr2[1] = '3';
+        arr2[3] = 12;
+        var name = arrType + "(array-like object)";
+        arr = eval(arrType + "(arr2)");
+        ok(arr.byteLength === 4 * typeSz, name + ".byteLength = " + arr.byteLength);
+        ok(arr.byteOffset === 0, name + ".byteOffset = " + arr.byteOffset);
+        ok(arr.length === 4, name + ".length = " + arr.length);
+        if(isNaN(arr[2])) {
+            ok(arr[0] === 1.5, name + "[0] = " + arr[0]);
+            ok(arr[1] === 3,   name + "[1] = " + arr[1]);
+            ok(arr[3] === 12,  name + "[3] = " + arr[3]);
+        }else
+            for(var j = 0; j < 4; j++)
+                ok(arr[j] === [1, 3, 0, 12][j], name + "[" + j + "] = " + arr[j]);
+
+        name = arrType + "(buf, " + typeSz + ", 2)";
+        arr = eval(name);
+        ok(arr.byteLength === 2 * typeSz, name + ".byteLength = " + arr.byteLength);
+        ok(arr.byteOffset === typeSz, name + ".byteOffset = " + arr.byteOffset);
+        ok(arr.length === 2, name + ".length = " + arr.length);
+        ok(arr.buffer === buf, name + ".buffer = " + arr.buffer);
+        view = DataView(buf);
+        view["set" + types[i][0]](typeSz, 10, true);
+        ok(arr[0] === 10, "arr[0] after DataView(buf).set" + types[i][0] + " = " + arr[0]);
+        arr[0] = 12;
+        r = view["get" + types[i][0]](typeSz, true);
+        ok(r === 12, "DataView(buf).get" + types[i][0] + " after arr[0] set = " + r);
+        Object.freeze(arr);
+        ok(Object.isFrozen(arr) === true, name + " not frozen");
+
+        arr2 = eval(arrType + "(arr)");
+        ok(arr2.byteLength === arr.byteLength, name + " copy.byteLength = " + arr2.byteLength);
+        ok(arr2.byteOffset === 0, name + " copy.byteOffset = " + arr2.byteOffset);
+        ok(arr2.length === arr.length, name + " copy.length = " + arr2.length);
+        ok(arr2.buffer !== arr.buffer, name + " copy.buffer = " + arr2.buffer);
+        arr2 = arr.subarray(undefined, "1");
+        ok(arr2.byteLength === typeSz, name + " subarray(undefined, '1').byteLength = " + arr2.byteLength);
+        ok(arr2.byteOffset === arr.byteOffset, name + " subarray(undefined, '1').byteOffset = " + arr2.byteOffset);
+        ok(arr2.length === 1, name + " subarray(undefined, '1').length = " + arr2.length);
+        ok(arr2.buffer === arr.buffer, name + " subarray(undefined, '1').buffer = " + arr2.buffer);
+
+        name = arrType + "(10)";
+        arr = eval(name);
+        try {
+            arr.subarray.call(null, 0);
+            ok(false, arrType + ": calling subarray with null context did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_NOT_TYPEDARRAY, arrType + ": calling subarray with null context threw " + n);
+        }
+        try {
+            arr.subarray.call({}, 0);
+            ok(false, arrType + ": calling subarray with an object context did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_NOT_TYPEDARRAY, arrType + ": calling subarray with an object context threw " + n);
+        }
+        try {
+            arr.subarray();
+            ok(false, name + " subarray() did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_TYPEDARRAY_INVALID_SUBARRAY, name + " subarray() threw " + n);
+        }
+        arr2 = arr.subarray(4);
+        ok(arr2.byteLength === 6 * typeSz, name + ".subarray(4).byteLength = " + arr2.byteLength);
+        ok(arr2.byteOffset === 4 * typeSz, name + ".subarray(4).byteOffset = " + arr2.byteOffset);
+        ok(arr2.length === 6, name + ".subarray(4).length = " + arr2.length);
+        ok(arr2.buffer === arr.buffer, name + ".subarray(4).buffer = " + arr2.buffer);
+        arr2 = arr.subarray(4, 2);
+        ok(arr2.byteLength === 0, name + ".subarray(4, 2).byteLength = " + arr2.byteLength);
+        ok(arr2.byteOffset === 4 * typeSz, name + ".subarray(4, 2).byteOffset = " + arr2.byteOffset);
+        ok(arr2.length === 0, name + ".subarray(4, 2).length = " + arr2.length);
+        ok(arr2.buffer === arr.buffer, name + ".subarray(4, 2).buffer = " + arr2.buffer);
+        arr2 = arr.subarray(-3, 100);
+        ok(arr2.byteLength === 3 * typeSz, name + ".subarray(-3, 100).byteLength = " + arr2.byteLength);
+        ok(arr2.byteOffset === 7 * typeSz, name + ".subarray(-3, 100).byteOffset = " + arr2.byteOffset);
+        ok(arr2.length === 3, name + ".subarray(-3, 100).length = " + arr2.length);
+        ok(arr2.buffer === arr.buffer, name + ".subarray(-3, 100).buffer = " + arr2.buffer);
+        arr2 = arr.subarray(42, -1);
+        ok(arr2.byteLength === 0, name + ".subarray(42, -1).byteLength = " + arr2.byteLength);
+        ok(arr2.byteOffset === 10 * typeSz, name + ".subarray(42, -1).byteOffset = " + arr2.byteOffset);
+        ok(arr2.length === 0, name + ".subarray(42, -1).length = " + arr2.length);
+        ok(arr2.buffer === arr.buffer, name + ".subarray(42, -1).buffer = " + arr2.buffer);
+        arr2 = arr.subarray(2, -3);
+        ok(arr2.byteLength === 5 * typeSz, name + ".subarray(2, -3).byteLength = " + arr2.byteLength);
+        ok(arr2.byteOffset === 2 * typeSz, name + ".subarray(2, -3).byteOffset = " + arr2.byteOffset);
+        ok(arr2.length === 5, name + ".subarray(2, -3).length = " + arr2.length);
+        ok(arr2.buffer === arr.buffer, name + ".subarray(2, -3).buffer = " + arr2.buffer);
+
+        try {
+            arr.set.call(null, [1]);
+            ok(false, arrType + ": calling set with null context did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_NOT_TYPEDARRAY, arrType + ": calling set with null context threw " + n);
+        }
+        try {
+            arr.set.call({}, [1]);
+            ok(false, arrType + ": calling set with an object context did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_NOT_TYPEDARRAY, arrType + ": calling set with an object context threw " + n);
+        }
+        try {
+            arr.set();
+            ok(false, name + ".set() did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_TYPEDARRAY_INVALID_SOURCE, name + ".set() threw " + n);
+        }
+        try {
+            arr.set(null);
+            ok(false, name + ".set(null) did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_TYPEDARRAY_INVALID_SOURCE, name + ".set(null) threw " + n);
+        }
+        try {
+            arr.set([1,2,3], 8);
+            ok(false, name + ".set([1,2,3], 8) did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_TYPEDARRAY_INVALID_OFFSLEN, name + ".set([1,2,3], 8) threw " + n);
+        }
+        try {
+            arr.set([99], -3);
+            ok(false, name + ".set([99], -3) did not throw exception");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_TYPEDARRAY_INVALID_OFFSLEN, name + ".set([99], -3) threw " + n);
+        }
+
+        r = arr.set(5);
+        ok(r === undefined, name + ".set(5) returned " + r);
+        for(var j = 0; j < 10; j++)
+            ok(arr[j] === 0, name + ".set(5): arr[" + j + "] = " + arr[j]);
+
+        r = arr.set({});
+        ok(r === undefined, name + ".set({}) returned " + r);
+        for(var j = 0; j < 10; j++)
+            ok(arr[j] === 0, name + ".set({}): arr[" + j + "] = " + arr[j]);
+
+        r = arr.set("12");
+        ok(r === undefined, name + ".set('12') returned " + r);
+        for(var j = 0; j < 10; j++)
+            ok(arr[j] === [ 1, 2, 0, 0, 0, 0, 0, 0, 0, 0 ][j], name + ".set('12'): arr[" + j + "] = " + arr[j]);
+
+        arr2 = { length: 2 };
+        arr2[0] = 9;
+        arr2[1] = 7;
+        r = arr.set(arr2);
+        ok(r === undefined, name + ".set(array-like obj) returned " + r);
+        for(var j = 0; j < 10; j++)
+            ok(arr[j] === [ 9, 7, 0, 0, 0, 0, 0, 0, 0, 0 ][j], name + ".set(array-like obj): arr[" + j + "] = " + arr[j]);
+
+        r = arr.set([12, 10, 11], 3);
+        ok(r === undefined, name + ".set([12, 10, 11], 3) returned " + r);
+        for(var j = 0; j < 10; j++)
+            ok(arr[j] === [ 9, 7, 0, 12, 10, 11, 0, 0, 0, 0 ][j], name + ".set([12, 10, 11], 3): arr[" + j + "] = " + arr[j]);
+
+        r = arr.set(arr.subarray(4, 6), 5);
+        ok(r === undefined, name + ".set(arr.subarray(4, 2), 5) returned " + r);
+        for(var j = 0; j < 10; j++)
+            ok(arr[j] === [ 9, 7, 0, 12, 10, 10, 11, 0, 0, 0 ][j], name + ".set(arr.subarray(4, 2), 5): arr[" + j + "] = " + arr[j]);
+
+        r = arr.set(arr.subarray(3, 7), 2);
+        ok(r === undefined, name + ".set(arr.subarray(3, 7), 2) returned " + r);
+        for(var j = 0; j < 10; j++)
+            ok(arr[j] === [ 9, 7, 12, 10, 10, 11, 11, 0, 0, 0 ][j], name + ".set(arr.subarray(3, 7), 2): arr[" + j + "] = " + arr[j]);
+    }
+
+    arr = new Float32Array(3);
+    arr[0] = 1.125;
+    arr[1] = 2.25;
+    arr[2] = 3.375;
+    arr2 = new Uint16Array(arr);
+    ok(arr[0] === 1.125, "arr[0] = " + arr[0]);
+    ok(arr[1] === 2.25, "arr[1] = " + arr[1]);
+    ok(arr[2] === 3.375, "arr[2] = " + arr[2]);
+    ok(arr2[0] === 1, "arr2[0] = " + arr2[0]);
+    ok(arr2[1] === 2, "arr2[1] = " + arr2[1]);
+    ok(arr2[2] === 3, "arr2[2] = " + arr2[2]);
+    arr2[0] = 100;
+    ok(arr[0] === 1.125, "arr[0] after arr2[0] changed = " + arr[0]);
+    ok(arr2[0] === 100, "arr2[0] after change = " + arr2[0]);
+
+    arr = new Int16Array(2);
+    arr[0] = 65535;
+    arr[1] = -65535;
+    ok(arr[0] == -1, "16-bit arr[0] after overflow = " + arr[0]);
+    ok(arr[1] == 1, "16-bit arr[1] after overflow = " + arr[1]);
+
+    arr = new Uint8Array(2);
+    arr[0] = -2;
+    arr[1] = 258;
+    ok(arr[0] == 254, "8-bit arr[0] after overflow = " + arr[0]);
+    ok(arr[1] == 2, "8-bit arr[1] after overflow = " + arr[1]);
+
+    arr = new Int8Array(12);
+    arr.set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);
+    for(var j = 0; j < 12; j++)
+        ok(arr[j] === j + 1, "sequential arr[" + j + "] = " + arr[j]);
+    arr2 = new Int32Array(arr.buffer);
+    ok(arr2.buffer === arr.buffer, "arr2.buffer = " + arr2.buffer);
+    for(var j = 0; j < 3; j++)
+        ok(arr2[j] === [ 0x04030201, 0x08070605, 0x0c0b0a09 ][j], "sequential 32-bit arr[" + j + "] = " + arr2[j]);
+
+    /* test overlap */
+    arr2.set(arr.subarray(1, 4));
+    for(var j = 0; j < 3; j++)
+        ok(arr2[j] === j + 2, "arr with overlap[" + j + "] = " + arr[j]);
+
+    /* methods are incompatible, even though thrown error is not explicit */
+    ok(Uint16Array.prototype.subarray !== Int32Array.prototype.subarray, "Uint16Array and Int32Array have same subarray methods");
+    ok(Int8Array.prototype.set !== Float32Array.prototype.set, "Int8Array and Float32Array have same set methods");
+    try {
+        Uint8Array.prototype.set.call(arr, [12, 50]);
+        ok(false, "calling Uint8Array's set with Int8Array context did not throw exception");
+    }catch(ex) {
+        var n = ex.number >>> 0;
+        ok(n === JS_E_NOT_TYPEDARRAY, "calling Uint8Array's set with Int8Array context threw " + n);
+    }
+    try {
+        Uint32Array.prototype.subarray.call(arr2, 0);
+        ok(false, "calling Uint32Array's subarray with Int32Array context did not throw exception");
+    }catch(ex) {
+        var n = ex.number >>> 0;
+        ok(n === JS_E_NOT_TYPEDARRAY, "calling Uint32Array's subarray with Int32Array context threw " + n);
+    }
+
+    /* clamped array */
+    arr = new Uint8ClampedArray(7);
+    arr2 = new Uint8Array(7);
+    arr.set ([42, -1, 999, 0.9, NaN, Infinity, -Infinity]);
+    arr2.set([42, -1, 999, 0.9, NaN, Infinity, -Infinity]);
+    for(var j = 0; j < 7; j++) {
+        ok(arr[j] ===  [42, 0, 255, 1, 0, 255, 0][j], "clamped arr[" + j + "] = " + arr[j]);
+        ok(arr2[j] === [42, 255, 231, 0, 0, 0, 0][j], "non-clamped arr[" + j + "] = " + arr2[j]);
+    }
+    r = Object.prototype.toString.call(arr);
+    ok(r === "[object Uint8ClampedArray]", "Object toString for Uint8ClampedArray = " + r);
+});
+
 sync_test("builtin_context", function() {
     var nullDisp = external.nullDisp;
     var tests = [
@@ -1628,6 +2465,108 @@ sync_test("builtin_context", function() {
     ok(obj.valueOf() === 42, "obj = " + obj);
 });
 
+sync_test("builtin override", function() {
+    /* configurable */
+    var builtins = [
+        "ActiveXObject",
+        "Array",
+        "ArrayBuffer",
+        "Boolean",
+        "CollectGarbage",
+        "DataView",
+        "Date",
+        "decodeURI",
+        "decodeURIComponent",
+        "encodeURI",
+        "encodeURIComponent",
+        "Enumerator",
+        "Error",
+        "escape",
+        "EvalError",
+        "Float32Array",
+        "Float64Array",
+        "Function",
+        "Int8Array",
+        "Int16Array",
+        "Int32Array",
+        "isFinite",
+        "isNaN",
+        "JSON",
+        "Map",
+        "Math",
+        "Number",
+        "parseFloat",
+        "parseInt",
+        "RangeError",
+        "ReferenceError",
+        "RegExp",
+        "ScriptEngine",
+        "ScriptEngineBuildVersion",
+        "ScriptEngineMajorVersion",
+        "ScriptEngineMinorVersion",
+        "Set",
+        "String",
+        "SyntaxError",
+        "TypeError",
+        "Uint8Array",
+        "Uint16Array",
+        "Uint32Array",
+        "unescape",
+        "URIError",
+        "VBArray"
+    ];
+
+    var override = {
+        value: 12,
+        configurable: true,
+        writable: true
+    };
+    for(var i = 0; i < builtins.length; i++) {
+        var desc = Object.getOwnPropertyDescriptor(window, builtins[i]), r;
+        ok(desc !== undefined, "getOwnPropertyDescriptor('" + builtins[i] + "' returned undefined");
+        ok(desc.configurable === true, builtins[i] + " not configurable");
+        ok(desc.enumerable === false, builtins[i] + " is enumerable");
+        ok(desc.writable === true, builtins[i] + " not writable");
+
+        r = Object.defineProperty(window, builtins[i], override);
+        ok(r === window, "defineProperty('" + builtins[i] + "' returned " + r);
+        r = Object.getOwnPropertyDescriptor(window, builtins[i]);
+        ok(r !== undefined, "getOwnPropertyDescriptor('" + builtins[i] + "' after override returned undefined");
+        ok(r.value === 12, builtins[i] + " value = " + r.value);
+
+        r = eval(builtins[i]);
+        ok(r === window[builtins[i]], "Global " + builtins[i] + " does not match redefined window." + builtins[i]);
+        r = (delete window[builtins[i]]);
+        ok(r === true, "delete window." + builtins[i] + " returned " + r);
+        ok(!(builtins[i] in window), builtins[i] + " in window after delete");
+        try {
+            eval(builtins[i]);
+            ok(false, "expected exception retrieving global " + builtins[i] + " after delete.");
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === JS_E_UNDEFINED_VARIABLE, "retrieving global " + builtins[i] + " after delete threw " + n);
+        }
+
+        r = Object.defineProperty(window, builtins[i], desc);
+        ok(r === window, "defineProperty('" + builtins[i] + "' to restore returned " + r);
+    }
+
+    /* non-configurable */
+    builtins = [
+        "undefined",
+        "Infinity",
+        "NaN"
+    ];
+
+    for(var i = 0; i < builtins.length; i++) {
+        var desc = Object.getOwnPropertyDescriptor(window, builtins[i]), r;
+        ok(desc !== undefined, "getOwnPropertyDescriptor('" + builtins[i] + "' returned undefined");
+        ok(desc.configurable === false, builtins[i] + " is configurable");
+        ok(desc.enumerable === false, builtins[i] + " is enumerable");
+        ok(desc.writable === false, builtins[i] + " is writable");
+    }
+});
+
 sync_test("head_setter", function() {
     document.head = "";
     ok(typeof(document.head) === "object", "typeof(document.head) = " + typeof(document.head));
@@ -1953,6 +2892,47 @@ sync_test("functions scope", function() {
     })();
 });
 
+sync_test("input validation", function() {
+    var fired, elem = document.createElement("input");
+    elem.type = "number";
+    elem.setAttribute("min", "1");
+    elem.setAttribute("max", "4");
+    elem.addEventListener("invalid", function(e) {
+        ok(e.target === elem, "unexpected target " + e.target);
+        fired = true;
+    });
+    fired = false;
+    elem.value = 1;
+    ok(elem.checkValidity() === true, "input number (1-4) with value 1: invalid");
+    ok(fired === false, "input number (1-4) with value 1 fired invalid event");
+    fired = false;
+    elem.value = 0;
+    ok(elem.checkValidity() === false, "input number (1-4) with value 0: valid");
+    ok(fired === true, "input number (1-4) with value 0 did not fire invalid event");
+    fired = false;
+    elem.value = 5;
+    ok(elem.checkValidity() === false, "input number (1-4) with value 5: valid");
+    ok(fired === true, "input number (1-4) with value 5 did not fire invalid event");
+});
+
+sync_test("instanceof", function() {
+    var r;
+
+    try {
+        ({} instanceof { prototype: {} });
+        ok(false, "expected exception using it on non-function object");
+    }catch(e) {
+        ok(e.number === 0xa138a - 0x80000000, "using it on non-function object threw " + e.number);
+    }
+
+    r = (document.createElement("iframe") instanceof HTMLIFrameElement);
+    ok(r === true, "iframe element not instance of HTMLIFrameElement");
+    r = (document.createElement("div") instanceof HTMLIFrameElement);
+    ok(r === false, "div element instance of HTMLIFrameElement");
+    r = (document instanceof Node);
+    ok(r === true, "document not instance of Node");
+});
+
 sync_test("console", function() {
     var except
 
@@ -2016,3 +2996,206 @@ sync_test("console", function() {
     }
     ok(except, "console.timeLog: expected exception");
 });
+
+sync_test("Crypto", function() {
+    var crypto = window.msCrypto, arr, r;
+    ok(Object.prototype.hasOwnProperty.call(Object.getPrototypeOf(window), "msCrypto"), "msCrypto not a property of window's prototype.");
+    r = Object.getPrototypeOf(crypto);
+    ok(r === window.Crypto.prototype, "getPrototypeOf(crypto) = " + r);
+
+    ok("subtle" in crypto, "subtle not in crypto");
+    ok("getRandomValues" in crypto, "getRandomValues not in crypto");
+    ok(!("randomUUID" in crypto), "randomUUID is in crypto");
+
+    var list = [ "decrypt", "deriveKey", "digest", "encrypt", "exportKey", "generateKey", "importKey", "sign", "unwrapKey", "verify", "wrapKey" ];
+    for(var i = 0; i < list.length; i++)
+        ok(list[i] in crypto.subtle, list[i] + " not in crypto.subtle");
+    ok(!("deriveBits" in crypto.subtle), "deriveBits is in crypto.subtle");
+
+    list = [
+        [ "Int8Array",    65536 ],
+        [ "Uint8Array",   65536 ],
+        [ "Int16Array",   32768 ],
+        [ "Uint16Array",  32768 ],
+        [ "Int32Array",   16384 ],
+        [ "Uint32Array",  16384 ]
+    ];
+    for(var i = 0; i < list.length; i++) {
+        var arrType = list[i][0];
+        arr = eval(arrType + "(" + list[i][1] + ")");
+
+        ok(arr[0] === 0, arrType + "[0] = " + arr[0]);
+        ok(arr[1] === 0, arrType + "[1] = " + arr[1]);
+        r = crypto.getRandomValues(arr);
+        ok(r === arr, "getRandomValues returned " + r);
+
+        arr = eval(arrType + "(" + (list[i][1]+1) + ")");
+        try {
+            crypto.getRandomValues(arr);
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            todo_wine.
+            ok(ex.name === "QuotaExceededError", "getRandomValues(oversized " + arrType + ") threw " + ex.name);
+            todo_wine.
+            ok(n === 0, "getRandomValues(oversized " + arrType + ") threw code " + n);
+            todo_wine.
+            ok(ex.message === "QuotaExceededError", "getRandomValues(oversized " + arrType + ") threw message " + ex.message);
+        }
+    }
+
+    try {
+        crypto.getRandomValues(null);
+        ok(false, "getRandomValues(null) did not throw exception");
+    }catch(ex) {
+        var n = ex.number >>> 0;
+        ok(n === E_INVALIDARG, "getRandomValues(null) threw " + n);
+    }
+    try {
+        crypto.getRandomValues(external.nullDisp);
+        ok(false, "getRandomValues(nullDisp) did not throw exception");
+    }catch(ex) {
+        var n = ex.number >>> 0;
+        ok(n === E_INVALIDARG, "getRandomValues(nullDisp) threw " + n);
+    }
+    try {
+        crypto.getRandomValues([1,2,3]);
+        ok(false, "getRandomValues([1,2,3]) did not throw exception");
+    }catch(ex) {
+        var n = ex.number >>> 0;
+        ok(n === E_INVALIDARG, "getRandomValues([1,2,3]) threw " + n);
+    }
+    arr = Float32Array(2);
+    try {
+        crypto.getRandomValues(arr);
+        ok(false, "getRandomValues(Float32Array) did not throw exception");
+    }catch(ex) {
+        var n = ex.number >>> 0;
+        todo_wine.
+        ok(ex.name === "TypeMismatchError", "getRandomValues(Float32Array) threw " + ex.name);
+        todo_wine.
+        ok(n === 0, "getRandomValues(Float32Array) threw code " + n);
+    }
+    arr = Float64Array(2);
+    try {
+        crypto.getRandomValues(arr);
+        ok(false, "getRandomValues(Float64Array) did not throw exception");
+    }catch(ex) {
+        var n = ex.number >>> 0;
+        todo_wine.
+        ok(ex.name === "TypeMismatchError", "getRandomValues(Float64Array) threw " + ex.name);
+        todo_wine.
+        ok(n === 0, "getRandomValues(Float64Array) threw code " + n);
+    }
+});
+
+sync_test("DOMParser", function() {
+    var p, r = DOMParser.length, mimeType;
+    ok(r === 0, "length = " + r);
+
+    p = DOMParser();
+    r = Object.getPrototypeOf(p);
+    ok(r === DOMParser.prototype, "prototype of instance created without new = " + r);
+    ok(p !== new DOMParser(), "DOMParser() == new DOMParser()");
+    ok(new DOMParser() !== new DOMParser(), "new DOMParser() == new DOMParser()");
+
+    var teststr = { toString: function() { return "<a name=\"test\">wine</a>"; } };
+
+    // HTML mime types
+    mimeType = [
+        [ "text/hTml",               "HTML Document" ]
+    ];
+    for(var i = 0; i < mimeType.length; i++) {
+        var m = mimeType[i][0], html = p.parseFromString(teststr, m);
+        r = html.mimeType;
+        ok(r === mimeType[i][1], "mimeType of HTML document with mime type " + m + " = " + r);
+        r = html.childNodes;
+        ok(r.length === 1 || r.length === 2, "childNodes.length of HTML document with mime type " + m + " = " + r.length);
+        var html_elem = r[r.length - 1];
+        ok(html_elem.nodeName === "HTML", "child nodeName of HTML document with mime type " + m + " = " + r.nodeName);
+        ok(html_elem.nodeValue === null, "child nodeValue of HTML document with mime type " + m + " = " + r.nodeValue);
+        r = html.anchors;
+        ok(r.length === 1, "anchors.length of HTML document with mime type " + m + " = " + r.length);
+        r = r[0];
+        ok(r.nodeName === "A", "anchor nodeName of HTML document with mime type " + m + " = " + r.nodeName);
+        ok(r.nodeValue === null, "anchor nodeValue of HTML document with mime type " + m + " = " + r.nodeValue);
+        r = r.parentNode;
+        ok(r.nodeName === "BODY", "anchor parent nodeName of HTML document with mime type " + m + " = " + r.nodeName);
+        ok(r.nodeValue === null, "anchor parent nodeValue of HTML document with mime type " + m + " = " + r.nodeValue);
+        r = r.parentNode;
+        ok(r === html_elem, "body parent of HTML document with mime type " + m + " = " + r);
+    }
+
+    // XML mime types
+    mimeType = [
+        [ "text/xmL",                "XML Document" ],
+        [ "aPPlication/xml",         "XML Document" ],
+        [ "application/xhtml+xml",   "XHTML Document" ],
+        [ "image/svg+xml",           "SVG Document" ]
+    ];
+    for(var i = 0; i < mimeType.length; i++) {
+        var m = mimeType[i][0], xml = p.parseFromString(teststr, m);
+        r = xml.mimeType;
+        ok(r === mimeType[i][1], "mimeType of XML document with mime type " + m + " = " + r);
+        r = xml.childNodes;
+        ok(r.length === 1, "childNodes.length of XML document with mime type " + m + " = " + r.length);
+        r = r[0];
+        ok(r.nodeName === "a", "child nodeName of XML document with mime type " + m + " = " + r.nodeName);
+        ok(r.nodeValue === null, "child nodeValue of XML document with mime type " + m + " = " + r.nodeValue);
+        r = r.childNodes;
+        ok(r.length === 1, "childNodes of child.length of XML document with mime type " + m + " = " + r.length);
+        r = r[0];
+        ok(r.nodeName === "#text", "child of child nodeName of XML document with mime type " + m + " = " + r.nodeName);
+        ok(r.nodeValue === "wine", "child of child nodeValue of XML document with mime type " + m + " = " + r.nodeValue);
+        ok(!("test" in xml), "'test' in XML document with mime type " + m);
+
+        // test HTMLDocument specific props, which are available in DocumentPrototype,
+        // so they are shared in XMLDocument since they both have the same prototype
+        r = xml.anchors;
+        if(mimeType[i][1] === "XHTML Document") {
+            todo_wine.
+            ok(r.length === 1, "anchors.length of XML document with mime type " + m + " = " + r.length);
+            r = r[0];
+            todo_wine.
+            ok(r === xml.childNodes[0], "anchor of XML document with mime type " + m + " = " + r);
+            r = Object.prototype.toString.call(xml.getElementsByTagName("a")[0]);
+            todo_wine.
+            ok(r === "[object HTMLAnchorElement]", "element's Object.toString of XML document with mime type " + m + " = " + r);
+        }else {
+            ok(r.length === 0, "anchors.length of XML document with mime type " + m + " = " + r.length);
+            r = Object.getPrototypeOf(xml.getElementsByTagName("a")[0]);
+            ok(r === Element.prototype, "element's prototype of XML document with mime type " + m + " = " + r);
+            r = document.importNode(xml.childNodes[0], true);
+            ok(r.nodeName === "a", "imported node name of XML document with mime type " + m + " = " + r.nodeName);
+            ok(r.nodeValue === null, "imported node value of XML document with mime type " + m + " = " + r.nodeValue);
+            r = Object.getPrototypeOf(r);
+            ok(r === Element.prototype, "imported node's prototype of XML document with mime type " + m + " = " + r);
+        }
+    }
+
+    // Invalid mime types
+    mimeType = [
+        "application/html",
+        "image/jpeg",
+        "text/plain",
+        "html",
+        "xml",
+        42
+    ];
+    for(var i = 0; i < mimeType.length; i++) {
+        try {
+            p.parseFromString(teststr, mimeType[i]);
+            ok(false, "expected exception calling parseFromString with mime type " + mimeType[i]);
+        }catch(ex) {
+            var n = ex.number >>> 0;
+            ok(n === E_INVALIDARG, "parseFromString with mime type " + mimeType[i] + " threw " + n);
+        }
+    }
+
+    try {
+        r = p.parseFromString("<invalid>xml", "text/xml");
+        ok(false, "expected exception calling parseFromString with invalid xml");
+    }catch(ex) {
+        ok(ex.name === "SyntaxError", "parseFromString with invalid xml threw " + ex.name);
+    }
+    p.parseFromString("<parsererror></parsererror>", "text/xml");
+});
diff --git a/dlls/mshtml/tests/events.c b/dlls/mshtml/tests/events.c
index 4ceee799dd4..94151eaa997 100644
--- a/dlls/mshtml/tests/events.c
+++ b/dlls/mshtml/tests/events.c
@@ -1889,6 +1889,7 @@ static void test_onclick(IHTMLDocument2 *doc)
     VariantClear(&v);
 
     if(document_mode >= 9) {
+        add_event_listener((IUnknown*)div, L"click", NULL, VARIANT_FALSE);
         add_event_listener((IUnknown*)div, L"click", (IDispatch*)&div_onclick_capture_obj, VARIANT_TRUE);
         add_event_listener((IUnknown*)div, L"click", (IDispatch*)&div_onclick_bubble_obj, VARIANT_FALSE);
     }
@@ -2043,6 +2044,7 @@ static void test_onclick(IHTMLDocument2 *doc)
     doc_detach_event(doc, L"onclick", (IDispatch*)&doc_onclick_attached_obj);
 
     if(document_mode >= 9) {
+        remove_event_listener((IUnknown*)div, L"click", NULL, VARIANT_FALSE);
         remove_event_listener((IUnknown*)div, L"click", (IDispatch*)&div_onclick_capture_obj, VARIANT_TRUE);
         remove_event_listener((IUnknown*)div, L"click", (IDispatch*)&div_onclick_bubble_obj, VARIANT_FALSE);
     }
@@ -2523,11 +2525,33 @@ static void test_submit(IHTMLDocument2 *doc)
 
 static void test_timeout(IHTMLDocument2 *doc)
 {
+    VARIANT expr, var, args[2];
+    DISPPARAMS dp = { args, NULL, 2, 0 };
     IHTMLWindow3 *win3;
-    VARIANT expr, var;
+    IDispatch *disp;
+    UINT argerr;
     LONG id;
     HRESULT hres;
 
+    /* First try the IHTMLWindow2 DISPIDs via IDispatch, since they're not exposed */
+    hres = IHTMLWindow2_QueryInterface(window, &IID_IDispatch, (void**)&disp);
+    ok(hres == S_OK, "Could not get IDispatch iface: %08lx\n", hres);
+
+    V_VT(&args[1]) = VT_BSTR;
+    V_BSTR(&args[1]) = SysAllocString(L"");
+    V_VT(&args[0]) = VT_I4;
+    V_I4(&args[0]) = 1;
+    V_VT(&var) = VT_EMPTY;
+    hres = IDispatch_Invoke(disp, DISPID_IHTMLWINDOW2_SETINTERVAL, &IID_NULL, LOCALE_USER_DEFAULT,
+                            DISPATCH_METHOD, &dp, &var, NULL, &argerr);
+    ok(hres == DISP_E_MEMBERNOTFOUND, "Invoke(DISPID_IHTMLWINDOW2_SETINTERVAL) returned: %08lx\n", hres);
+
+    hres = IDispatch_Invoke(disp, DISPID_IHTMLWINDOW2_SETTIMEOUT, &IID_NULL, LOCALE_USER_DEFAULT,
+                            DISPATCH_METHOD, &dp, &var, NULL, &argerr);
+    ok(hres == DISP_E_MEMBERNOTFOUND, "Invoke(DISPID_IHTMLWINDOW2_SETTIMEOUT) returned: %08lx\n", hres);
+    SysFreeString(V_BSTR(&args[1]));
+    IDispatch_Release(disp);
+
     hres = IHTMLWindow2_QueryInterface(window, &IID_IHTMLWindow3, (void**)&win3);
     ok(hres == S_OK, "Could not get IHTMLWindow3 iface: %08lx\n", hres);
 
@@ -2550,6 +2574,9 @@ static void test_timeout(IHTMLDocument2 *doc)
     ok(hres == S_OK, "setTimeout failed: %08lx\n", hres);
     ok(id, "id = 0\n");
 
+    hres = IHTMLWindow2_clearTimeout(window, 0);
+    ok(hres == S_OK, "clearTimeout failed: %08lx\n", hres);
+
     SET_EXPECT(timeout);
     pump_msgs(&called_timeout);
     CHECK_CALLED(timeout);
@@ -2581,6 +2608,13 @@ static void test_timeout(IHTMLDocument2 *doc)
     pump_msgs(&called_timeout);
     CHECK_CALLED(timeout);
 
+    hres = IHTMLWindow2_clearInterval(window, 0);
+    ok(hres == S_OK, "clearInterval failed: %08lx\n", hres);
+
+    SET_EXPECT(timeout);
+    pump_msgs(&called_timeout);
+    CHECK_CALLED(timeout);
+
     hres = IHTMLWindow2_clearInterval(window, id);
     ok(hres == S_OK, "clearTimeout failer: %08lx\n", hres);
 
diff --git a/dlls/mshtml/tests/events.js b/dlls/mshtml/tests/events.js
index 75893cac204..813e2a53890 100644
--- a/dlls/mshtml/tests/events.js
+++ b/dlls/mshtml/tests/events.js
@@ -198,6 +198,21 @@ sync_test("add_remove_listener", function() {
     calls = "";
     div.click();
     ok(calls === "", "calls = " + calls);
+
+    /* test undefined function argument */
+    div.addEventListener("click", undefined, false);
+
+    calls = "";
+    div.click();
+    ok(calls === "", "calls = " + calls);
+
+    div.addEventListener("click", listener, false);
+    div.removeEventListener("click", undefined);
+
+    calls = "";
+    div.click();
+    ok(calls === "listener,", "calls = " + calls);
+    div.removeEventListener("click", listener);
 });
 
 sync_test("event_phase", function() {
@@ -745,6 +760,7 @@ sync_test("keyboard_event", function() {
     ok(e.location === 0, "location = " + e.location);
     ok(e.detail === 0, "detail = " + e.detail);
     ok(e.which === 0, "which = " + e.which);
+    ok(e.locale === "", "locale = " + e.locale);
 });
 
 sync_test("custom_event", function() {
@@ -808,6 +824,6 @@ async_test("message event", function() {
         next_test();
     });
 
-    window.postMessage("test", "http://winetest.example.org");
+    window.postMessage("test", "httP://wineTest.example.org");
     ok(listener_called == false, "listener already called");
 });
diff --git a/dlls/mshtml/tests/htmldoc.c b/dlls/mshtml/tests/htmldoc.c
index ff050863b6f..f3afb1d120c 100644
--- a/dlls/mshtml/tests/htmldoc.c
+++ b/dlls/mshtml/tests/htmldoc.c
@@ -7670,6 +7670,23 @@ static void test_QueryInterface(IHTMLDocument2 *htmldoc)
     IUnknown_Release(qi);
 }
 
+static void test_mimeType(IHTMLDocument2 *doc, const WCHAR *expected)
+{
+    BSTR mime_type = (BSTR)0xdeadbeef;
+    HRESULT hres;
+
+    hres = IHTMLDocument2_get_mimeType(doc, &mime_type);
+    if(expected) {
+        ok(hres == S_OK, "get_mimeType returned %08lx\n", hres);
+        ok(!lstrcmpW(mime_type, expected), "mime type = %s, expected %s\n",
+            debugstr_w(mime_type), debugstr_w(expected));
+    }else {
+        ok(hres == E_FAIL, "get_mimeType returned %08lx\n", hres);
+        ok(!mime_type, "mime type = %s, expected (null)\n", debugstr_w(mime_type));
+    }
+    SysFreeString(mime_type);
+}
+
 static void init_test(enum load_state_t ls) {
     doc_unk = NULL;
     doc_hwnd = last_hwnd = NULL;
@@ -7723,6 +7740,7 @@ static void test_HTMLDocument(BOOL do_load, BOOL mime)
         test_GetCurMoniker((IUnknown*)doc, &Moniker, NULL, FALSE);
         test_elem_from_point(doc);
     }
+    test_mimeType(doc, do_load ? L"HTML Document" : NULL);
 
     test_MSHTML_QueryStatus(doc, OLECMDF_SUPPORTED);
     test_OleCommandTarget_fail(doc);
@@ -7834,6 +7852,7 @@ static void test_MHTMLDocument(void)
     set_custom_uihandler(doc, &CustomDocHostUIHandler);
     test_GetCurMoniker((IUnknown*)doc, NULL, L"mhtml:winetest:doc", FALSE);
     test_download(0);
+    test_mimeType(doc, L"HTML Document");
 
     test_exec_onunload(doc);
     test_UIDeactivate();
diff --git a/dlls/mshtml/tests/script.c b/dlls/mshtml/tests/script.c
index da31c4d8206..32868964e8c 100644
--- a/dlls/mshtml/tests/script.c
+++ b/dlls/mshtml/tests/script.c
@@ -3723,6 +3723,7 @@ static void run_js_tests(void)
     init_protocol_handler();
 
     run_script_as_http_with_mode("xhr.js", NULL, "9");
+    run_script_as_http_with_mode("xhr.js", NULL, "10");
     run_script_as_http_with_mode("xhr.js", NULL, "11");
     run_script_as_http_with_mode("dom.js", NULL, "11");
     run_script_as_http_with_mode("es5.js", NULL, "11");
diff --git a/dlls/mshtml/tests/xhr.js b/dlls/mshtml/tests/xhr.js
index cb7e46113f3..98cf357411c 100644
--- a/dlls/mshtml/tests/xhr.js
+++ b/dlls/mshtml/tests/xhr.js
@@ -17,14 +17,39 @@
  */
 
 function test_xhr() {
+    var xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<a name=\"test\">wine</a>";
     var xhr = new XMLHttpRequest();
+    var v = document.documentMode;
     var complete_cnt = 0;
 
     xhr.onreadystatechange = function() {
         if(xhr.readyState != 4)
             return;
 
-        ok(xhr.responseText === "Testing...", "unexpected responseText " + xhr.responseText);
+        ok(xhr.responseText === xml, "unexpected responseText " + xhr.responseText);
+
+        var x = xhr.responseXML, r = Object.prototype.toString.call(x);
+        ok(r === (v < 10 ? "[object Object]" : (v < 11 ? "[object Document]" : "[object XMLDocument]")),
+                "XML document Object.toString = " + r);
+
+        r = Object.getPrototypeOf(x);
+        if(v < 10)
+            ok(r === null, "prototype of returned XML document = " + r);
+        else if(v < 11)
+            ok(r === window.Document.prototype, "prototype of returned XML document = " + r);
+        else
+            ok(r === window.XMLDocument.prototype, "prototype of returned XML document" + r);
+
+        if(v < 10) {
+            ok(!("anchors" in x), "anchors is in returned XML document");
+            ok(Object.prototype.hasOwnProperty.call(x, "createElement"), "createElement not a prop of returned XML document");
+        }else {
+            ok("anchors" in x, "anchors not in returned XML document");
+            ok(!x.hasOwnProperty("createElement"), "createElement is a prop of returned XML document");
+            r = x.anchors;
+            ok(r.length === 0, "anchors.length of returned XML document = " + r.length);
+        }
+
         if(complete_cnt++)
             next_test();
     }
@@ -37,7 +62,7 @@ function test_xhr() {
 
     xhr.open("POST", "echo.php", true);
     xhr.setRequestHeader("X-Test", "True");
-    xhr.send("Testing...");
+    xhr.send(xml);
 }
 
 var tests = [
diff --git a/dlls/mshtml/tests/xmlhttprequest.c b/dlls/mshtml/tests/xmlhttprequest.c
index 0db5cb9717b..f182deb8614 100644
--- a/dlls/mshtml/tests/xmlhttprequest.c
+++ b/dlls/mshtml/tests/xmlhttprequest.c
@@ -489,10 +489,14 @@ static void _set_request_header(unsigned line, IHTMLXMLHttpRequest *xhr, const W
 static void test_responseXML(const WCHAR *expect_text)
 {
     IDispatch *disp;
+    IHTMLDocument2 *html_doc;
     IXMLDOMDocument *xmldom;
     IObjectSafety *safety;
+    IHTMLDOMNode *node;
     DWORD enabled = 0, supported = 0;
+    DISPID dispid;
     HRESULT hres;
+    BSTR str;
 
     disp = NULL;
     hres = IHTMLXMLHttpRequest_get_responseXML(xhr, &disp);
@@ -515,6 +519,17 @@ static void test_responseXML(const WCHAR *expect_text)
         "Expected enabled: (INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA | INTERFACE_USES_SECURITY_MANAGER), got 0x%08lx\n", enabled);
     IObjectSafety_Release(safety);
 
+    hres = IXMLDOMDocument_QueryInterface(xmldom, &IID_IHTMLDOMNode, (void**)&node);
+    ok(hres == E_NOINTERFACE, "QueryInterface(IHTMLDOMNode) returned: %08lx\n", hres);
+
+    hres = IXMLDOMDocument_QueryInterface(xmldom, &IID_IHTMLDocument2, (void**)&html_doc);
+    ok(hres == E_NOINTERFACE, "QueryInterface(IHTMLDocument2) returned: %08lx\n", hres);
+
+    str = SysAllocString(L"anchors");
+    hres = IDispatch_GetIDsOfNames(disp, &IID_NULL, &str, 1, LOCALE_USER_DEFAULT, &dispid);
+    ok(hres == DISP_E_UNKNOWNNAME, "GetIDsOfNames(\"anchors\") returned: %08lx\n", hres);
+    SysFreeString(str);
+
     if(!expect_text)
         test_illegal_xml(xmldom);
 
diff --git a/dlls/mshtml/xmlhttprequest.c b/dlls/mshtml/xmlhttprequest.c
index 0ae69df3bda..a538e11b1a2 100644
--- a/dlls/mshtml/xmlhttprequest.c
+++ b/dlls/mshtml/xmlhttprequest.c
@@ -31,8 +31,6 @@
 #include "htmlevent.h"
 #include "mshtmdid.h"
 #include "initguid.h"
-#include "msxml6.h"
-#include "objsafe.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(mshtml);
 
@@ -107,6 +105,7 @@ struct HTMLXMLHttpRequest {
     IHTMLXMLHttpRequest IHTMLXMLHttpRequest_iface;
     IProvideClassInfo2 IProvideClassInfo2_iface;
     LONG ref;
+    HTMLDocumentNode *doc;
     nsIXMLHttpRequest *nsxhr;
     XMLHttpReqEventListener *event_listener;
 };
@@ -204,7 +203,7 @@ static nsresult NSAPI XMLHttpReqEventListener_HandleEvent(nsIDOMEventListener *i
     if(!This->xhr)
         return NS_OK;
 
-    hres = create_event_from_nsevent(nsevent, dispex_compat_mode(&This->xhr->event_target.dispex), &event);
+    hres = create_event_from_nsevent(nsevent, This->xhr->doc, dispex_compat_mode(&This->xhr->event_target.dispex), &event);
     if(SUCCEEDED(hres) ){
         dispatch_event(&This->xhr->event_target, event);
         IDOMEvent_Release(&event->IDOMEvent_iface);
@@ -268,6 +267,7 @@ static ULONG WINAPI HTMLXMLHttpRequest_Release(IHTMLXMLHttpRequest *iface)
     if(!ref) {
         if(This->event_listener)
             detach_xhr_event_listener(This->event_listener);
+        htmldoc_release(&This->doc->basedoc);
         release_event_target(&This->event_target);
         release_dispex(&This->event_target.dispex);
         nsIXMLHttpRequest_Release(This->nsxhr);
@@ -354,42 +354,21 @@ static HRESULT WINAPI HTMLXMLHttpRequest_get_responseText(IHTMLXMLHttpRequest *i
 static HRESULT WINAPI HTMLXMLHttpRequest_get_responseXML(IHTMLXMLHttpRequest *iface, IDispatch **p)
 {
     HTMLXMLHttpRequest *This = impl_from_IHTMLXMLHttpRequest(iface);
-    IXMLDOMDocument *xmldoc = NULL;
     BSTR str;
     HRESULT hres;
-    VARIANT_BOOL vbool;
-    IObjectSafety *safety;
 
     TRACE("(%p)->(%p)\n", This, p);
 
-    hres = CoCreateInstance(&CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, &IID_IXMLDOMDocument, (void**)&xmldoc);
-    if(FAILED(hres)) {
-        ERR("CoCreateInstance failed: %08lx\n", hres);
-        return hres;
-    }
-
     hres = IHTMLXMLHttpRequest_get_responseText(iface, &str);
     if(FAILED(hres)) {
-        IXMLDOMDocument_Release(xmldoc);
         ERR("get_responseText failed: %08lx\n", hres);
         return hres;
     }
-
-    hres = IXMLDOMDocument_loadXML(xmldoc, str, &vbool);
+    hres = create_xml_document(str, This->doc, DOCTYPE_XML,
+                               dispex_compat_mode(&This->event_target.dispex) >= COMPAT_MODE_IE10, p);
     SysFreeString(str);
-    if(hres != S_OK || vbool != VARIANT_TRUE)
-        WARN("loadXML failed: %08lx, returning an empty xmldoc\n", hres);
-
-    hres = IXMLDOMDocument_QueryInterface(xmldoc, &IID_IObjectSafety, (void**)&safety);
-    assert(SUCCEEDED(hres));
-    hres = IObjectSafety_SetInterfaceSafetyOptions(safety, NULL,
-        INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA | INTERFACE_USES_SECURITY_MANAGER,
-        INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA | INTERFACE_USES_SECURITY_MANAGER);
-    assert(SUCCEEDED(hres));
-    IObjectSafety_Release(safety);
-
-    *p = (IDispatch*)xmldoc;
-    return S_OK;
+
+    return hres;
 }
 
 static HRESULT WINAPI HTMLXMLHttpRequest_get_status(IHTMLXMLHttpRequest *iface, LONG *p)
@@ -508,8 +487,12 @@ static HRESULT WINAPI HTMLXMLHttpRequest_open(IHTMLXMLHttpRequest *iface, BSTR b
     TRACE("(%p)->(%s %s %s %s %s)\n", This, debugstr_w(bstrMethod), debugstr_w(bstrUrl), debugstr_variant(&varAsync), debugstr_variant(&varUser), debugstr_variant(&varPassword));
 
     if(V_VT(&varAsync) != VT_BOOL) {
-        FIXME("varAsync not supported: %s\n", debugstr_variant(&varAsync));
-        return E_FAIL;
+        LCID lcid = MAKELCID(MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US),SORT_DEFAULT);
+        hres = VariantChangeTypeEx(&varAsync, &varAsync, lcid, 0, VT_BOOL);
+        if(FAILED(hres)) {
+            WARN("Failed to convert varAsync to BOOL: %#lx\n", hres);
+            return hres;
+        }
     }
 
     /* Note: Starting with Gecko 30.0 (Firefox 30.0 / Thunderbird 30.0 / SeaMonkey 2.27),
@@ -783,8 +766,8 @@ static HRESULT HTMLXMLHttpRequest_get_dispid(DispatchEx *dispex, BSTR name, DWOR
     return DISP_E_UNKNOWNNAME;
 }
 
-static HRESULT HTMLXMLHttpRequest_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
-        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+static HRESULT HTMLXMLHttpRequest_invoke(DispatchEx *dispex, IDispatch *this_obj, DISPID id, LCID lcid, WORD flags,
+        DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
     HTMLXMLHttpRequest *This = impl_from_DispatchEx(dispex);
 
@@ -893,9 +876,10 @@ static event_target_vtbl_t HTMLXMLHttpRequest_event_target_vtbl = {
 static const tid_t HTMLXMLHttpRequest_iface_tids[] = {
     0
 };
-static dispex_static_data_t HTMLXMLHttpRequest_dispex = {
+dispex_static_data_t HTMLXMLHttpRequest_dispex = {
     L"XMLHttpRequest",
     &HTMLXMLHttpRequest_event_target_vtbl.dispex_vtbl,
+    PROTO_ID_HTMLXMLHttpRequest,
     DispHTMLXMLHttpRequest_tid,
     HTMLXMLHttpRequest_iface_tids,
     HTMLXMLHttpRequest_init_dispex_info
@@ -903,14 +887,14 @@ static dispex_static_data_t HTMLXMLHttpRequest_dispex = {
 
 
 /* IHTMLXMLHttpRequestFactory */
-static inline HTMLXMLHttpRequestFactory *impl_from_IHTMLXMLHttpRequestFactory(IHTMLXMLHttpRequestFactory *iface)
+static inline struct compat_ctor *impl_from_IHTMLXMLHttpRequestFactory(IHTMLXMLHttpRequestFactory *iface)
 {
-    return CONTAINING_RECORD(iface, HTMLXMLHttpRequestFactory, IHTMLXMLHttpRequestFactory_iface);
+    return CONTAINING_RECORD(iface, struct compat_ctor, IHTMLXMLHttpRequestFactory_iface);
 }
 
 static HRESULT WINAPI HTMLXMLHttpRequestFactory_QueryInterface(IHTMLXMLHttpRequestFactory *iface, REFIID riid, void **ppv)
 {
-    HTMLXMLHttpRequestFactory *This = impl_from_IHTMLXMLHttpRequestFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLXMLHttpRequestFactory(iface);
 
     TRACE("(%p)->(%s %p)\n", This, debugstr_mshtml_guid(riid), ppv);
 
@@ -934,7 +918,7 @@ static HRESULT WINAPI HTMLXMLHttpRequestFactory_QueryInterface(IHTMLXMLHttpReque
 
 static ULONG WINAPI HTMLXMLHttpRequestFactory_AddRef(IHTMLXMLHttpRequestFactory *iface)
 {
-    HTMLXMLHttpRequestFactory *This = impl_from_IHTMLXMLHttpRequestFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLXMLHttpRequestFactory(iface);
     LONG ref = InterlockedIncrement(&This->ref);
 
     TRACE("(%p) ref=%ld\n", This, ref);
@@ -944,7 +928,7 @@ static ULONG WINAPI HTMLXMLHttpRequestFactory_AddRef(IHTMLXMLHttpRequestFactory
 
 static ULONG WINAPI HTMLXMLHttpRequestFactory_Release(IHTMLXMLHttpRequestFactory *iface)
 {
-    HTMLXMLHttpRequestFactory *This = impl_from_IHTMLXMLHttpRequestFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLXMLHttpRequestFactory(iface);
     LONG ref = InterlockedDecrement(&This->ref);
 
     TRACE("(%p) ref=%ld\n", This, ref);
@@ -959,14 +943,14 @@ static ULONG WINAPI HTMLXMLHttpRequestFactory_Release(IHTMLXMLHttpRequestFactory
 
 static HRESULT WINAPI HTMLXMLHttpRequestFactory_GetTypeInfoCount(IHTMLXMLHttpRequestFactory *iface, UINT *pctinfo)
 {
-    HTMLXMLHttpRequestFactory *This = impl_from_IHTMLXMLHttpRequestFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLXMLHttpRequestFactory(iface);
     return IDispatchEx_GetTypeInfoCount(&This->dispex.IDispatchEx_iface, pctinfo);
 }
 
 static HRESULT WINAPI HTMLXMLHttpRequestFactory_GetTypeInfo(IHTMLXMLHttpRequestFactory *iface, UINT iTInfo,
         LCID lcid, ITypeInfo **ppTInfo)
 {
-    HTMLXMLHttpRequestFactory *This = impl_from_IHTMLXMLHttpRequestFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLXMLHttpRequestFactory(iface);
 
     return IDispatchEx_GetTypeInfo(&This->dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
 }
@@ -974,7 +958,7 @@ static HRESULT WINAPI HTMLXMLHttpRequestFactory_GetTypeInfo(IHTMLXMLHttpRequestF
 static HRESULT WINAPI HTMLXMLHttpRequestFactory_GetIDsOfNames(IHTMLXMLHttpRequestFactory *iface, REFIID riid, LPOLESTR *rgszNames, UINT cNames,
         LCID lcid, DISPID *rgDispId)
 {
-    HTMLXMLHttpRequestFactory *This = impl_from_IHTMLXMLHttpRequestFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLXMLHttpRequestFactory(iface);
 
     return IDispatchEx_GetIDsOfNames(&This->dispex.IDispatchEx_iface, riid, rgszNames, cNames,
             lcid, rgDispId);
@@ -983,7 +967,7 @@ static HRESULT WINAPI HTMLXMLHttpRequestFactory_GetIDsOfNames(IHTMLXMLHttpReques
 static HRESULT WINAPI HTMLXMLHttpRequestFactory_Invoke(IHTMLXMLHttpRequestFactory *iface, DISPID dispIdMember, REFIID riid, LCID lcid,
         WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
 {
-    HTMLXMLHttpRequestFactory *This = impl_from_IHTMLXMLHttpRequestFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLXMLHttpRequestFactory(iface);
 
     return IDispatchEx_Invoke(&This->dispex.IDispatchEx_iface, dispIdMember, riid, lcid, wFlags,
             pDispParams, pVarResult, pExcepInfo, puArgErr);
@@ -991,7 +975,7 @@ static HRESULT WINAPI HTMLXMLHttpRequestFactory_Invoke(IHTMLXMLHttpRequestFactor
 
 static HRESULT WINAPI HTMLXMLHttpRequestFactory_create(IHTMLXMLHttpRequestFactory *iface, IHTMLXMLHttpRequest **p)
 {
-    HTMLXMLHttpRequestFactory *This = impl_from_IHTMLXMLHttpRequestFactory(iface);
+    struct compat_ctor *This = impl_from_IHTMLXMLHttpRequestFactory(iface);
     HTMLXMLHttpRequest        *ret;
     nsIXMLHttpRequest         *nsxhr;
 
@@ -1007,18 +991,21 @@ static HRESULT WINAPI HTMLXMLHttpRequestFactory_create(IHTMLXMLHttpRequestFactor
         return E_OUTOFMEMORY;
     }
     ret->nsxhr = nsxhr;
+    ret->doc = This->window->doc;
+    if(ret->doc)
+        htmldoc_addref(&ret->doc->basedoc);
 
     ret->IHTMLXMLHttpRequest_iface.lpVtbl = &HTMLXMLHttpRequestVtbl;
     ret->IProvideClassInfo2_iface.lpVtbl = &ProvideClassInfo2Vtbl;
     EventTarget_Init(&ret->event_target, (IUnknown*)&ret->IHTMLXMLHttpRequest_iface,
-                     &HTMLXMLHttpRequest_dispex, This->window->doc->document_mode);
+                     &HTMLXMLHttpRequest_dispex, ret->doc);
     ret->ref = 1;
 
     *p = &ret->IHTMLXMLHttpRequest_iface;
     return S_OK;
 }
 
-static const IHTMLXMLHttpRequestFactoryVtbl HTMLXMLHttpRequestFactoryVtbl = {
+const IHTMLXMLHttpRequestFactoryVtbl HTMLXMLHttpRequestFactoryVtbl = {
     HTMLXMLHttpRequestFactory_QueryInterface,
     HTMLXMLHttpRequestFactory_AddRef,
     HTMLXMLHttpRequestFactory_Release,
@@ -1029,24 +1016,22 @@ static const IHTMLXMLHttpRequestFactoryVtbl HTMLXMLHttpRequestFactoryVtbl = {
     HTMLXMLHttpRequestFactory_create
 };
 
-static inline HTMLXMLHttpRequestFactory *factory_from_DispatchEx(DispatchEx *iface)
+static inline struct compat_ctor *ctor_from_DispatchEx(DispatchEx *iface)
 {
-    return CONTAINING_RECORD(iface, HTMLXMLHttpRequestFactory, dispex);
+    return CONTAINING_RECORD(iface, struct compat_ctor, dispex);
 }
 
 static HRESULT HTMLXMLHttpRequestFactory_value(DispatchEx *iface, LCID lcid, WORD flags, DISPPARAMS *params,
         VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
-    HTMLXMLHttpRequestFactory *This = factory_from_DispatchEx(iface);
+    struct compat_ctor *This = ctor_from_DispatchEx(iface);
     IHTMLXMLHttpRequest *xhr;
     HRESULT hres;
 
     TRACE("\n");
 
-    if(flags != DISPATCH_CONSTRUCT) {
-        FIXME("flags %x not supported\n", flags);
-        return E_NOTIMPL;
-    }
+    if(flags != DISPATCH_CONSTRUCT)
+        return S_FALSE;
 
     hres = IHTMLXMLHttpRequestFactory_create(&This->IHTMLXMLHttpRequestFactory_iface, &xhr);
     if(FAILED(hres))
@@ -1058,35 +1043,44 @@ static HRESULT HTMLXMLHttpRequestFactory_value(DispatchEx *iface, LCID lcid, WOR
 }
 
 static const dispex_static_data_vtbl_t HTMLXMLHttpRequestFactory_dispex_vtbl = {
-    HTMLXMLHttpRequestFactory_value
+    HTMLXMLHttpRequestFactory_value,
+    compat_ctor_get_dispid,
+    compat_ctor_invoke,
+    compat_ctor_delete
 };
 
 static const tid_t HTMLXMLHttpRequestFactory_iface_tids[] = {
     IHTMLXMLHttpRequestFactory_tid,
     0
 };
-static dispex_static_data_t HTMLXMLHttpRequestFactory_dispex = {
-    L"Function",
+dispex_static_data_t HTMLXMLHttpRequestFactory_dispex = {
+    L"XMLHttpRequest",
     &HTMLXMLHttpRequestFactory_dispex_vtbl,
+    PROTO_ID_NULL,
     IHTMLXMLHttpRequestFactory_tid,
     HTMLXMLHttpRequestFactory_iface_tids
 };
 
-HRESULT HTMLXMLHttpRequestFactory_Create(HTMLInnerWindow* window, HTMLXMLHttpRequestFactory **ret_ptr)
+static HRESULT HTMLXMLHttpRequestCtor_value(DispatchEx *iface, LCID lcid, WORD flags, DISPPARAMS *params,
+        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
-    HTMLXMLHttpRequestFactory *ret;
-
-    ret = heap_alloc(sizeof(*ret));
-    if(!ret)
-        return E_OUTOFMEMORY;
+    if(flags == DISPATCH_CONSTRUCT)
+        return HTMLXMLHttpRequestFactory_value(iface, lcid, flags, params, res, ei, caller);
 
-    ret->IHTMLXMLHttpRequestFactory_iface.lpVtbl = &HTMLXMLHttpRequestFactoryVtbl;
-    ret->ref = 1;
-    ret->window = window;
+    return compat_ctor_value(iface, lcid, flags, params, res, ei, caller);
+}
 
-    init_dispatch(&ret->dispex, (IUnknown*)&ret->IHTMLXMLHttpRequestFactory_iface,
-                  &HTMLXMLHttpRequestFactory_dispex, dispex_compat_mode(&window->event_target.dispex));
+static const dispex_static_data_vtbl_t HTMLXMLHttpRequestCtor_dispex_vtbl = {
+    HTMLXMLHttpRequestCtor_value,
+    compat_ctor_get_dispid,
+    compat_ctor_invoke,
+    compat_ctor_delete
+};
 
-    *ret_ptr = ret;
-    return S_OK;
-}
+dispex_static_data_t HTMLXMLHttpRequestCtor_dispex = {
+    L"XMLHttpRequest",
+    &HTMLXMLHttpRequestCtor_dispex_vtbl,
+    PROTO_ID_NULL,
+    IHTMLXMLHttpRequestFactory_tid,
+    HTMLXMLHttpRequestFactory_iface_tids
+};
diff --git a/dlls/urlmon/Makefile.in b/dlls/urlmon/Makefile.in
index a29c831e455..f95e7972829 100644
--- a/dlls/urlmon/Makefile.in
+++ b/dlls/urlmon/Makefile.in
@@ -1,6 +1,7 @@
 MODULE    = urlmon.dll
 IMPORTLIB = urlmon
 IMPORTS   = uuid ole32 oleaut32 shell32 rpcrt4 shlwapi wininet user32 advapi32
+EXTRADEFS = -D_URLMON_
 DELAYIMPORTS = advpack
 
 C_SRCS = \
diff --git a/dlls/urlmon/sec_mgr.c b/dlls/urlmon/sec_mgr.c
index 4529f439b7d..5c79cb2b250 100644
--- a/dlls/urlmon/sec_mgr.c
+++ b/dlls/urlmon/sec_mgr.c
@@ -1153,8 +1153,8 @@ static HRESULT WINAPI SecManagerImpl_ProcessUrlActionEx2(IInternetSecurityManage
         DWORD dwFlags, DWORD_PTR dwReserved, DWORD *pdwOutFlags)
 {
     SecManagerImpl *This = impl_from_IInternetSecurityManagerEx2(iface);
-    FIXME("(%p)->(%p %08lx %p %ld %p %ld %08lx %08Ix %p) stub\n", This, pUri, dwAction, pPolicy,
-          cbPolicy, pContext, cbContext, dwFlags, dwReserved, pdwOutFlags);
+    FIXME("(%p)->(%p %08lx %p %ld %p %ld %08lx %08lx %p) stub\n", This, pUri, dwAction, pPolicy,
+          cbPolicy, pContext, cbContext, dwFlags, (DWORD)dwReserved, pdwOutFlags);
     return E_NOTIMPL;
 }
 
@@ -1162,7 +1162,7 @@ static HRESULT WINAPI SecManagerImpl_GetSecurityIdEx2(IInternetSecurityManagerEx
         IUri *pUri, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved)
 {
     SecManagerImpl *This = impl_from_IInternetSecurityManagerEx2(iface);
-    TRACE("(%p)->(%p %p %p %08Ix) stub\n", This, pUri, pbSecurityId, pcbSecurityId, dwReserved);
+    TRACE("(%p)->(%p %p %p %08lx) stub\n", This, pUri, pbSecurityId, pcbSecurityId, (DWORD)dwReserved);
 
     if(dwReserved)
         FIXME("dwReserved is not supported yet\n");
@@ -1178,8 +1178,8 @@ static HRESULT WINAPI SecManagerImpl_QueryCustomPolicyEx2(IInternetSecurityManag
         DWORD cbContext, DWORD_PTR dwReserved)
 {
     SecManagerImpl *This = impl_from_IInternetSecurityManagerEx2(iface);
-    FIXME("(%p)->(%p %s %p %p %p %ld %08Ix) stub\n", This, pUri, debugstr_guid(guidKey), ppPolicy, pcbPolicy,
-          pContext, cbContext, dwReserved);
+    FIXME("(%p)->(%p %s %p %p %p %ld %08lx) stub\n", This, pUri, debugstr_guid(guidKey), ppPolicy, pcbPolicy,
+          pContext, cbContext, (DWORD)dwReserved);
     return E_NOTIMPL;
 }
 
@@ -1993,7 +1993,7 @@ HRESULT WINAPI CoInternetGetSecurityUrlEx(IUri *pUri, IUri **ppSecUri, PSUACTION
     WCHAR *ret_url;
     HRESULT hres;
 
-    TRACE("(%p,%p,%u,%Iu)\n", pUri, ppSecUri, psuAction, dwReserved);
+    TRACE("(%p,%p,%u,%lu)\n", pUri, ppSecUri, psuAction, (DWORD)dwReserved);
 
     if(!pUri || !ppSecUri)
         return E_INVALIDARG;
diff --git a/dlls/urlmon/tests/misc.c b/dlls/urlmon/tests/misc.c
index 638dcae16cd..504331a2eee 100644
--- a/dlls/urlmon/tests/misc.c
+++ b/dlls/urlmon/tests/misc.c
@@ -2301,7 +2301,7 @@ static void test_bsc_marshaling(void)
     ok(!in_bindinfo.dwOptions, "dwOptions = %lu\n", in_bindinfo.dwOptions);
     ok(!in_bindinfo.dwOptionsFlags, "dwOptionsFlags = %lu\n", in_bindinfo.dwOptionsFlags);
     ok(!in_bindinfo.dwCodePage, "dwCodePage = %lu\n", in_bindinfo.dwCodePage);
-    ok(!in_bindinfo.iid.Data1, "iid = %s\n", debugstr_guid(&in_bindinfo.iid));
+    ok(!in_bindinfo.iid.Data1, "iid.Data1 = %lu\n", in_bindinfo.iid.Data1);
     ok(!in_bindinfo.pUnk, "pUnk = %p\n", in_bindinfo.pUnk);
     ok(!in_bindinfo.dwReserved, "dwReserved = %lu\n", in_bindinfo.dwReserved);
     ok(!in_bindinfo.securityAttributes.nLength, "securityAttributes.nLength = %lu\n",
@@ -2326,7 +2326,7 @@ static void test_bsc_marshaling(void)
     ok(bindinfo.dwOptions == 24, "dwOptions = %lu\n", bindinfo.dwOptions);
     ok(bindinfo.dwOptionsFlags == 25, "dwOptionsFlags = %lu\n", bindinfo.dwOptionsFlags);
     ok(bindinfo.dwCodePage, "dwCodePage = %lu\n", bindinfo.dwCodePage);
-    ok(!bindinfo.iid.Data1, "iid = %s\n", debugstr_guid(&bindinfo.iid));
+    ok(!bindinfo.iid.Data1, "iid.Data1 = %lu\n", bindinfo.iid.Data1);
     ok(!bindinfo.pUnk, "pUnk = %p\n", bindinfo.pUnk);
     ok(bindinfo.dwReserved == 18, "dwReserved = %lu\n", bindinfo.dwReserved);
     ok(bindinfo.securityAttributes.nLength == 30, "securityAttributes.nLength = %lu\n",
@@ -2518,7 +2518,7 @@ static void test_bsc_marshaling(void)
         ok(!in_bindinfo.dwOptions, "dwOptions = %lu\n", in_bindinfo.dwOptions);
         ok(!in_bindinfo.dwOptionsFlags, "dwOptionsFlags = %lu\n", in_bindinfo.dwOptionsFlags);
         ok(!in_bindinfo.dwCodePage, "dwCodePage = %lu\n", in_bindinfo.dwCodePage);
-        ok(!in_bindinfo.iid.Data1, "iid = %s\n", debugstr_guid(&in_bindinfo.iid));
+        ok(!in_bindinfo.iid.Data1, "iid.Data1 = %lu\n", in_bindinfo.iid.Data1);
         ok(!in_bindinfo.pUnk, "pUnk = %p\n", in_bindinfo.pUnk);
         ok(!in_bindinfo.dwReserved, "dwReserved = %lu\n", in_bindinfo.dwReserved);
         ok(!in_bindinfo.securityAttributes.nLength, "securityAttributes.nLength = %lu\n",
@@ -2542,7 +2542,7 @@ static void test_bsc_marshaling(void)
         ok(bindinfo.dwOptions == 24, "dwOptions = %lu\n", bindinfo.dwOptions);
         ok(bindinfo.dwOptionsFlags == 25, "dwOptionsFlags = %lu\n", bindinfo.dwOptionsFlags);
         ok(bindinfo.dwCodePage, "dwCodePage = %lu\n", bindinfo.dwCodePage);
-        ok(!bindinfo.iid.Data1, "iid = %s\n", debugstr_guid(&bindinfo.iid));
+        ok(!bindinfo.iid.Data1, "iid.Data1 = %lu\n", bindinfo.iid.Data1);
         ok(!bindinfo.pUnk, "pUnk = %p\n", bindinfo.pUnk);
         ok(bindinfo.dwReserved == 18, "dwReserved = %lu\n", bindinfo.dwReserved);
         ok(bindinfo.securityAttributes.nLength == 30, "securityAttributes.nLength = %lu\n",
diff --git a/dlls/urlmon/uri.c b/dlls/urlmon/uri.c
index c774fdf01ad..838f1d0619d 100644
--- a/dlls/urlmon/uri.c
+++ b/dlls/urlmon/uri.c
@@ -4662,7 +4662,7 @@ static HRESULT WINAPI UriBuilderFactory_CreateIUriBuilder(IUriBuilderFactory *if
                                                           IUriBuilder **ppIUriBuilder)
 {
     Uri *This = impl_from_IUriBuilderFactory(iface);
-    TRACE("(%p)->(%08lx %08Ix %p)\n", This, dwFlags, dwReserved, ppIUriBuilder);
+    TRACE("(%p)->(%08lx %08lx %p)\n", This, dwFlags, (DWORD)dwReserved, ppIUriBuilder);
 
     if(!ppIUriBuilder)
         return E_POINTER;
@@ -4681,7 +4681,7 @@ static HRESULT WINAPI UriBuilderFactory_CreateInitializedIUriBuilder(IUriBuilder
                                                                      IUriBuilder **ppIUriBuilder)
 {
     Uri *This = impl_from_IUriBuilderFactory(iface);
-    TRACE("(%p)->(%08lx %08Ix %p)\n", This, dwFlags, dwReserved, ppIUriBuilder);
+    TRACE("(%p)->(%08lx %08lx %p)\n", This, dwFlags, (DWORD)dwReserved, ppIUriBuilder);
 
     if(!ppIUriBuilder)
         return E_POINTER;
@@ -5286,7 +5286,7 @@ HRESULT WINAPI CreateUri(LPCWSTR pwzURI, DWORD dwFlags, DWORD_PTR dwReserved, IU
     HRESULT hr;
     parse_data data;
 
-    TRACE("(%s %lx %Ix %p)\n", debugstr_w(pwzURI), dwFlags, dwReserved, ppURI);
+    TRACE("(%s %lx %lx %p)\n", debugstr_w(pwzURI), dwFlags, (DWORD)dwReserved, ppURI);
 
     if(!ppURI)
         return E_INVALIDARG;
@@ -5374,7 +5374,7 @@ HRESULT WINAPI CreateUriWithFragment(LPCWSTR pwzURI, LPCWSTR pwzFragment, DWORD
                                      DWORD_PTR dwReserved, IUri **ppURI)
 {
     HRESULT hres;
-    TRACE("(%s %s %lx %Ix %p)\n", debugstr_w(pwzURI), debugstr_w(pwzFragment), dwFlags, dwReserved, ppURI);
+    TRACE("(%s %s %lx %lx %p)\n", debugstr_w(pwzURI), debugstr_w(pwzFragment), dwFlags, (DWORD)dwReserved, ppURI);
 
     if(!ppURI)
         return E_INVALIDARG;
@@ -5547,11 +5547,11 @@ static HRESULT WINAPI UriBuilder_CreateUriSimple(IUriBuilder *iface,
 {
     UriBuilder *This = impl_from_IUriBuilder(iface);
     HRESULT hr;
-    TRACE("(%p)->(%ld %Id %p)\n", This, dwAllowEncodingPropertyMask, dwReserved, ppIUri);
+    TRACE("(%p)->(%ld %ld %p)\n", This, dwAllowEncodingPropertyMask, (DWORD)dwReserved, ppIUri);
 
     hr = build_uri(This, ppIUri, 0, UriBuilder_USE_ORIGINAL_FLAGS, dwAllowEncodingPropertyMask);
     if(hr == E_NOTIMPL)
-        FIXME("(%p)->(%ld %Id %p)\n", This, dwAllowEncodingPropertyMask, dwReserved, ppIUri);
+        FIXME("(%p)->(%ld %ld %p)\n", This, dwAllowEncodingPropertyMask, (DWORD)dwReserved, ppIUri);
     return hr;
 }
 
@@ -5563,7 +5563,7 @@ static HRESULT WINAPI UriBuilder_CreateUri(IUriBuilder *iface,
 {
     UriBuilder *This = impl_from_IUriBuilder(iface);
     HRESULT hr;
-    TRACE("(%p)->(0x%08lx %ld %Id %p)\n", This, dwCreateFlags, dwAllowEncodingPropertyMask, dwReserved, ppIUri);
+    TRACE("(%p)->(0x%08lx %ld %ld %p)\n", This, dwCreateFlags, dwAllowEncodingPropertyMask, (DWORD)dwReserved, ppIUri);
 
     if(dwCreateFlags == -1)
         hr = build_uri(This, ppIUri, 0, UriBuilder_USE_ORIGINAL_FLAGS, dwAllowEncodingPropertyMask);
@@ -5571,7 +5571,7 @@ static HRESULT WINAPI UriBuilder_CreateUri(IUriBuilder *iface,
         hr = build_uri(This, ppIUri, dwCreateFlags, 0, dwAllowEncodingPropertyMask);
 
     if(hr == E_NOTIMPL)
-        FIXME("(%p)->(0x%08lx %ld %Id %p)\n", This, dwCreateFlags, dwAllowEncodingPropertyMask, dwReserved, ppIUri);
+        FIXME("(%p)->(0x%08lx %ld %ld %p)\n", This, dwCreateFlags, dwAllowEncodingPropertyMask, (DWORD)dwReserved, ppIUri);
     return hr;
 }
 
@@ -5584,13 +5584,13 @@ static HRESULT WINAPI UriBuilder_CreateUriWithFlags(IUriBuilder *iface,
 {
     UriBuilder *This = impl_from_IUriBuilder(iface);
     HRESULT hr;
-    TRACE("(%p)->(0x%08lx 0x%08lx %ld %Id %p)\n", This, dwCreateFlags, dwUriBuilderFlags,
-        dwAllowEncodingPropertyMask, dwReserved, ppIUri);
+    TRACE("(%p)->(0x%08lx 0x%08lx %ld %ld %p)\n", This, dwCreateFlags, dwUriBuilderFlags,
+        dwAllowEncodingPropertyMask, (DWORD)dwReserved, ppIUri);
 
     hr = build_uri(This, ppIUri, dwCreateFlags, dwUriBuilderFlags, dwAllowEncodingPropertyMask);
     if(hr == E_NOTIMPL)
-        FIXME("(%p)->(0x%08lx 0x%08lx %ld %Id %p)\n", This, dwCreateFlags, dwUriBuilderFlags,
-            dwAllowEncodingPropertyMask, dwReserved, ppIUri);
+        FIXME("(%p)->(0x%08lx 0x%08lx %ld %ld %p)\n", This, dwCreateFlags, dwUriBuilderFlags,
+            dwAllowEncodingPropertyMask, (DWORD)dwReserved, ppIUri);
     return hr;
 }
 
@@ -5932,7 +5932,7 @@ HRESULT WINAPI CreateIUriBuilder(IUri *pIUri, DWORD dwFlags, DWORD_PTR dwReserve
 {
     UriBuilder *ret;
 
-    TRACE("(%p %lx %Ix %p)\n", pIUri, dwFlags, dwReserved, ppIUriBuilder);
+    TRACE("(%p %lx %lx %p)\n", pIUri, dwFlags, (DWORD)dwReserved, ppIUriBuilder);
 
     if(!ppIUriBuilder)
         return E_POINTER;
@@ -5962,8 +5962,8 @@ HRESULT WINAPI CreateIUriBuilder(IUri *pIUri, DWORD dwFlags, DWORD_PTR dwReserve
         } else {
             heap_free(ret);
             *ppIUriBuilder = NULL;
-            FIXME("(%p %lx %Ix %p): Unknown IUri types not supported yet.\n", pIUri, dwFlags,
-                  dwReserved, ppIUriBuilder);
+            FIXME("(%p %lx %lx %p): Unknown IUri types not supported yet.\n", pIUri, dwFlags,
+                (DWORD)dwReserved, ppIUriBuilder);
             return E_NOTIMPL;
         }
     }
@@ -6295,7 +6295,7 @@ HRESULT WINAPI CoInternetCombineIUri(IUri *pBaseUri, IUri *pRelativeUri, DWORD d
     HRESULT hr;
     IInternetProtocolInfo *info;
     Uri *relative, *base;
-    TRACE("(%p %p %lx %p %Ix)\n", pBaseUri, pRelativeUri, dwCombineFlags, ppCombinedUri, dwReserved);
+    TRACE("(%p %p %lx %p %lx)\n", pBaseUri, pRelativeUri, dwCombineFlags, ppCombinedUri, (DWORD)dwReserved);
 
     if(!ppCombinedUri)
         return E_INVALIDARG;
@@ -6309,8 +6309,8 @@ HRESULT WINAPI CoInternetCombineIUri(IUri *pBaseUri, IUri *pRelativeUri, DWORD d
     base = get_uri_obj(pBaseUri);
     if(!relative || !base) {
         *ppCombinedUri = NULL;
-        FIXME("(%p %p %lx %p %Ix) Unknown IUri types not supported yet.\n",
-            pBaseUri, pRelativeUri, dwCombineFlags, ppCombinedUri, dwReserved);
+        FIXME("(%p %p %lx %p %lx) Unknown IUri types not supported yet.\n",
+            pBaseUri, pRelativeUri, dwCombineFlags, ppCombinedUri, (DWORD)dwReserved);
         return E_NOTIMPL;
     }
 
@@ -6343,8 +6343,8 @@ HRESULT WINAPI CoInternetCombineUrlEx(IUri *pBaseUri, LPCWSTR pwzRelativeUrl, DW
     HRESULT hr;
     IInternetProtocolInfo *info;
 
-    TRACE("(%p %s %lx %p %Ix)\n", pBaseUri, debugstr_w(pwzRelativeUrl), dwCombineFlags,
-        ppCombinedUri, dwReserved);
+    TRACE("(%p %s %lx %p %lx)\n", pBaseUri, debugstr_w(pwzRelativeUrl), dwCombineFlags,
+        ppCombinedUri, (DWORD)dwReserved);
 
     if(!ppCombinedUri)
         return E_POINTER;
@@ -6362,8 +6362,8 @@ HRESULT WINAPI CoInternetCombineUrlEx(IUri *pBaseUri, LPCWSTR pwzRelativeUrl, DW
     base = get_uri_obj(pBaseUri);
     if(!base) {
         *ppCombinedUri = NULL;
-        FIXME("(%p %s %lx %p %Ix) Unknown IUri's not supported yet.\n", pBaseUri, debugstr_w(pwzRelativeUrl),
-            dwCombineFlags, ppCombinedUri, dwReserved);
+        FIXME("(%p %s %lx %p %lx) Unknown IUri's not supported yet.\n", pBaseUri, debugstr_w(pwzRelativeUrl),
+            dwCombineFlags, ppCombinedUri, (DWORD)dwReserved);
         return E_NOTIMPL;
     }
 
@@ -6828,8 +6828,8 @@ HRESULT WINAPI CoInternetParseIUri(IUri *pIUri, PARSEACTION ParseAction, DWORD d
     Uri *uri;
     IInternetProtocolInfo *info;
 
-    TRACE("(%p %d %lx %p %ld %p %Ix)\n", pIUri, ParseAction, dwFlags, pwzResult,
-        cchResult, pcchResult, dwReserved);
+    TRACE("(%p %d %lx %p %ld %p %lx)\n", pIUri, ParseAction, dwFlags, pwzResult,
+        cchResult, pcchResult, (DWORD)dwReserved);
 
     if(!pcchResult)
         return E_POINTER;
@@ -6841,8 +6841,8 @@ HRESULT WINAPI CoInternetParseIUri(IUri *pIUri, PARSEACTION ParseAction, DWORD d
 
     if(!(uri = get_uri_obj(pIUri))) {
         *pcchResult = 0;
-        FIXME("(%p %d %lx %p %ld %p %Ix) Unknown IUri's not supported for this action.\n",
-            pIUri, ParseAction, dwFlags, pwzResult, cchResult, pcchResult, dwReserved);
+        FIXME("(%p %d %lx %p %ld %p %lx) Unknown IUri's not supported for this action.\n",
+            pIUri, ParseAction, dwFlags, pwzResult, cchResult, pcchResult, (DWORD)dwReserved);
         return E_NOTIMPL;
     }
 
@@ -6896,8 +6896,8 @@ HRESULT WINAPI CoInternetParseIUri(IUri *pIUri, PARSEACTION ParseAction, DWORD d
     default:
         *pcchResult = 0;
         hr = E_NOTIMPL;
-        FIXME("(%p %d %lx %p %ld %p %Ix) Partial stub.\n", pIUri, ParseAction, dwFlags,
-            pwzResult, cchResult, pcchResult, dwReserved);
+        FIXME("(%p %d %lx %p %ld %p %lx) Partial stub.\n", pIUri, ParseAction, dwFlags,
+            pwzResult, cchResult, pcchResult, (DWORD)dwReserved);
     }
 
     return hr;
diff --git a/dlls/wininet/tests/http.c b/dlls/wininet/tests/http.c
index ec576ae81e2..bc1b829fca2 100644
--- a/dlls/wininet/tests/http.c
+++ b/dlls/wininet/tests/http.c
@@ -4526,6 +4526,13 @@ static const http_status_test_t http_status_tests[] = {
         200,
         ""
     },
+    {
+        "HTTP/1.1 200 \r\n"
+        "Content-Length: 1\r\n"
+        "\r\nx",
+        200,
+        ""
+    },
     {
         "HTTP/1.1 410 \r\n"
         "Content-Length: 1\r\n"
diff --git a/include/mshtmdid.h b/include/mshtmdid.h
index 31e75709db6..7f0161a2fd6 100644
--- a/include/mshtmdid.h
+++ b/include/mshtmdid.h
@@ -105,6 +105,7 @@
 #define DISPID_NAMESPACE                          DISPID_NORMAL_FIRST
 #define DISPID_TAGNAMES_COLLECTION                DISPID_NORMAL_FIRST
 #define DISPID_XMLHTTPREQUEST                     DISPID_NORMAL_FIRST
+#define DISPID_DOMPARSER                          DISPID_NORMAL_FIRST
 #define DISPID_DOCUMENTCOMPATIBLEINFO_COLLECTION  DISPID_NORMAL_FIRST
 #define DISPID_DOCUMENTCOMPATIBLEINFO             DISPID_NORMAL_FIRST
 #define DISPID_XDOMAINREQUEST   DISPID_NORMAL_FIRST
@@ -4625,6 +4626,9 @@
 #define DISPID_IHTMLDOMCONSTRUCTORCOLLECTION_XDOMAINREQUEST              DISPID_WINDOW+8001+DomConstructorXDomainRequest
 #define DISPID_IHTMLDOMCONSTRUCTORCOLLECTION_XMLHTTPREQUEST              DISPID_WINDOW+8001+DomConstructorXMLHttpRequest
 
+/* IDOMParser */
+#define DISPID_IDOMPARSER_PARSEFROMSTRING        DISPID_DOMPARSER
+
 /* IEventTarget */
 #define DISPID_IEVENTTARGET_ADDEVENTLISTENER     DISPID_HTMLOBJECT+10
 #define DISPID_IEVENTTARGET_REMOVEEVENTLISTENER  DISPID_HTMLOBJECT+11
diff --git a/include/mshtml.idl b/include/mshtml.idl
index 162a9691fb6..b08c1791cdd 100644
--- a/include/mshtml.idl
+++ b/include/mshtml.idl
@@ -34,6 +34,8 @@ import "dispex.idl";
 cpp_quote("#include <olectl.h>")
 
 cpp_quote("DEFINE_GUID(CLSID_MHTMLDocument,     0x3050f3d9,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);")
+cpp_quote("DEFINE_GUID(CLSID_XHTMLDocument,     0x30590067,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);")
+cpp_quote("DEFINE_GUID(CLSID_SVGDocument,       0x30590066,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);")
 
 cpp_quote("DEFINE_GUID(SID_SEditCommandTarget,  0x3050f4b5,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);")
 cpp_quote("DEFINE_GUID(SID_SHTMLEditHost,       0x3050f6a0,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);")
@@ -29342,6 +29344,46 @@ interface IHTMLDOMConstructorCollection : IDispatch
     HRESULT XMLHttpRequest([out, retval] IDispatch **p);
 }
 
+/*****************************************************************************
+ *    IDOMParser interface
+ */
+[
+    odl,
+    oleautomation,
+    dual,
+    uuid(30510781-98b5-11cf-bb82-00aa00bdce0b)
+]
+interface IDOMParser : IDispatch
+{
+    [id(DISPID_IDOMPARSER_PARSEFROMSTRING)]
+    HRESULT parseFromString([in] BSTR string, [in] BSTR mimeType, [retval, out] IHTMLDocument2 **ppNode);
+}
+
+/*****************************************************************************
+ *    DispDOMParser dispinterface
+ */
+[
+    hidden,
+    uuid(305900ae-98b5-11cf-bb82-00aa00bdce0b)
+]
+dispinterface DispDOMParser
+{
+properties:
+methods:
+    [id(DISPID_IDOMPARSER_PARSEFROMSTRING)]
+    IHTMLDocument2 *parseFromString([in] BSTR string, [in] BSTR mimeType);
+}
+
+[
+    noncreatable,
+    uuid(30510782-98b5-11cf-bb82-00aa00bdce0b)
+]
+coclass DOMParser
+{
+    [default] dispinterface DispDOMParser;
+    interface IDOMParser;
+}
+
 /*****************************************************************************
  *    IXMLGenericParse interface
  */
-- 
2.32.1 (Apple Git-133)

